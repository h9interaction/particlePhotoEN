This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
workers/
  ImageProcessorWorker.js
  ParticleCalculatorWorker.js
.gitattributes
.gitignore
admin.css
admin.html
admin.js
AnimationManager.js
deploy.sh
firebase.js
imageLoader.js
ImageWorkerManager.js
index.html
integration.test.js
main.js
OptimizedParticlePool.js
package.json
particle_photo_data_2025-07-03_15-20-13.csv
Particle.js
ParticleCalculatorWorkerManager.js
peopleDataLoader.js
peopleDataLoader.test.js
PerformanceMonitor.js
Procfile
render.yaml
server.js
server.test.js
start_server.bat
styles.css
words.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(grep:*)",
      "Bash(npm install:*)"
    ],
    "deny": []
  }
}
</file>

<file path="workers/ImageProcessorWorker.js">
/**
 * ImageProcessorWorker.js
 * 이미지 처리 작업을 백그라운드에서 수행하는 웹 워커
 * 메인 스레드의 UI 블로킹을 방지하고 성능을 개선
 */

class ImageProcessorWorker {
    constructor() {
        self.onmessage = this.handleMessage.bind(this);
        console.log('ImageProcessorWorker 초기화 완료');
    }
    
    handleMessage(event) {
        const { type, data, taskId } = event.data;
        
        try {
            switch (type) {
                case 'PROCESS_IMAGE':
                    this.processImageData(data, taskId);
                    break;
                case 'BATCH_PROCESS':
                    this.batchProcessImages(data, taskId);
                    break;
                case 'PING':
                    this.sendResponse('PONG', { message: 'Worker is alive' }, taskId);
                    break;
                default:
                    this.sendError(`Unknown message type: ${type}`, taskId);
            }
        } catch (error) {
            this.sendError(error.message, taskId);
        }
    }
    
    /**
     * 단일 이미지 데이터를 처리
     * @param {Object} data - 이미지 처리 데이터
     * @param {string} taskId - 작업 ID
     */
    processImageData(data, taskId) {
        const { imageData, stepPixel, canvasWidth, canvasHeight, offsetX = 0, offsetY = 0, drawWidth, drawHeight } = data;
        
        if (!imageData || !imageData.data) {
            throw new Error('Invalid imageData provided');
        }
        
        const pixelData = [];
        const pixels = imageData.data;
        const imageWidth = imageData.width;
        
        // 기존 main.js의 이미지 처리 로직과 동일하게 유지
        for (let y = 0; y < drawHeight; y += stepPixel) {
            for (let x = 0; x < drawWidth; x += stepPixel) {
                const actualX = Math.floor(x + offsetX);
                const actualY = Math.floor(y + offsetY);
                
                // 경계 검사
                if (actualX >= 0 && actualY >= 0 && actualX < canvasWidth && actualY < canvasHeight) {
                    const idx = (actualY * imageWidth + actualX) * 4;
                    
                    if (idx < pixels.length - 2) {
                        const r = pixels[idx];
                        const g = pixels[idx + 1];
                        const b = pixels[idx + 2];
                        
                        // 기존과 동일한 색상 반전 로직
                        const invertedR = 255 - r;
                        const invertedG = 255 - g;
                        const invertedB = 255 - b;
                        
                        pixelData.push({
                            x: actualX,
                            y: actualY,
                            color: { r: invertedR, g: invertedG, b: invertedB }
                        });
                    }
                }
            }
        }
        
        this.sendResponse('IMAGE_PROCESSED', {
            pixelData,
            processingTime: performance.now() - data.startTime,
            particleCount: pixelData.length
        }, taskId);
    }
    
    /**
     * 여러 이미지를 배치로 처리
     * @param {Object} data - 배치 처리 데이터
     * @param {string} taskId - 작업 ID
     */
    batchProcessImages(data, taskId) {
        const { images, stepPixel } = data;
        const results = [];
        
        for (let i = 0; i < images.length; i++) {
            const imageInfo = images[i];
            try {
                const processedData = this.processImageData({
                    ...imageInfo,
                    stepPixel,
                    startTime: performance.now()
                });
                
                results.push({
                    index: i,
                    success: true,
                    data: processedData.data
                });
            } catch (error) {
                results.push({
                    index: i,
                    success: false,
                    error: error.message
                });
            }
        }
        
        this.sendResponse('BATCH_PROCESSED', {
            results,
            totalProcessed: results.length,
            successCount: results.filter(r => r.success).length
        }, taskId);
    }
    
    /**
     * 성공 응답 전송
     * @param {string} type - 응답 타입
     * @param {Object} data - 응답 데이터
     * @param {string} taskId - 작업 ID
     */
    sendResponse(type, data, taskId) {
        self.postMessage({
            type,
            data,
            taskId,
            timestamp: performance.now()
        });
    }
    
    /**
     * 에러 응답 전송
     * @param {string} errorMessage - 에러 메시지
     * @param {string} taskId - 작업 ID
     */
    sendError(errorMessage, taskId) {
        self.postMessage({
            type: 'ERROR',
            data: { error: errorMessage },
            taskId,
            timestamp: performance.now()
        });
    }
}

// 워커 인스턴스 생성
new ImageProcessorWorker();
</file>

<file path="workers/ParticleCalculatorWorker.js">
/**
 * ParticleCalculatorWorker.js
 * 파티클 위치 계산을 백그라운드에서 수행하는 웹 워커
 * 8200개 파티클의 복잡한 계산을 메인 스레드에서 분리
 */

class ParticleCalculatorWorker {
    constructor() {
        self.onmessage = this.handleMessage.bind(this);
        console.log('ParticleCalculatorWorker 초기화 완료');
    }
    
    handleMessage(event) {
        const { type, data, taskId } = event.data;
        
        try {
            switch (type) {
                case 'UPDATE_PARTICLES':
                    this.updateParticles(data, taskId);
                    break;
                case 'CALCULATE_EXPLOSION':
                    this.calculateExplosion(data, taskId);
                    break;
                case 'BATCH_UPDATE':
                    this.batchUpdateParticles(data, taskId);
                    break;
                case 'PING':
                    this.sendResponse('PONG', { message: 'ParticleWorker is alive' }, taskId);
                    break;
                default:
                    this.sendError(`Unknown message type: ${type}`, taskId);
            }
        } catch (error) {
            this.sendError(error.message, taskId);
        }
    }
    
    /**
     * 파티클들의 위치를 업데이트
     * @param {Object} data - 파티클 업데이트 데이터
     * @param {string} taskId - 작업 ID
     */
    updateParticles(data, taskId) {
        const { particles, currentTime } = data;
        const updatedParticles = [];
        
        for (let i = 0; i < particles.length; i++) {
            const particle = particles[i];
            
            if (!particle.exploding) {
                const updatedParticle = this.updateFormationParticle(particle, currentTime);
                updatedParticles.push(updatedParticle);
            } else {
                const updatedParticle = this.updateExplodingParticle(particle, currentTime);
                updatedParticles.push(updatedParticle);
            }
        }
        
        this.sendResponse('PARTICLES_UPDATED', {
            particles: updatedParticles,
            timestamp: currentTime
        }, taskId);
    }
    
    /**
     * 형성 단계 파티클 업데이트 (기존 로직과 동일)
     * @param {Object} particle - 파티클 데이터
     * @param {number} currentTime - 현재 시간
     * @returns {Object} 업데이트된 파티클
     */
    updateFormationParticle(particle, currentTime) {
        const timeElapsed = (currentTime - particle.startTime) / particle.duration;
        const progress = this.easeInOutQuart(Math.min(Math.max(timeElapsed, 0), 1));
        
        // 기존과 동일한 로직
        const growthFactor = 2.5;
        const speed = Math.pow(progress, growthFactor);
        
        const newParticle = {
            ...particle,
            pos: {
                x: particle.target.x * speed + particle.pos.x * (1 - speed),
                y: particle.target.y * speed + particle.pos.y * (1 - speed)
            },
            size: particle.targetSize * speed,
            atTarget: timeElapsed >= 1
        };
        
        // 타겟에 도달했을 때 정확한 위치로 설정
        if (timeElapsed >= 1) {
            newParticle.pos.x = particle.target.x;
            newParticle.pos.y = particle.target.y;
            newParticle.size = particle.targetSize;
            newParticle.atTarget = true;
        }
        
        return newParticle;
    }
    
    /**
     * 폭발 단계 파티클 업데이트 (기존 로직과 동일)
     * @param {Object} particle - 파티클 데이터
     * @param {number} currentTime - 현재 시간
     * @returns {Object} 업데이트된 파티클
     */
    updateExplodingParticle(particle, currentTime) {
        return {
            ...particle,
            velocity: {
                x: particle.velocity.x * 1.02,
                y: particle.velocity.y * 1.02
            },
            pos: {
                x: particle.pos.x + particle.velocity.x * 1.02,
                y: particle.pos.y + particle.velocity.y * 1.02
            },
            size: Math.max(0, particle.size - 0.5)
        };
    }
    
    /**
     * 폭발 계산 (기존 로직과 동일)
     * @param {Object} data - 폭발 데이터
     * @param {string} taskId - 작업 ID
     */
    calculateExplosion(data, taskId) {
        const { particles, explosionDelay } = data;
        const explosionData = [];
        
        for (let i = 0; i < particles.length; i++) {
            const delay = Math.random() * explosionDelay;
            const velocity = {
                x: (Math.random() - 0.5) * 3,
                y: (Math.random() - 0.5) * 2
            };
            
            explosionData.push({
                index: i,
                delay,
                velocity,
                exploding: true
            });
        }
        
        this.sendResponse('EXPLOSION_CALCULATED', {
            explosionData,
            totalParticles: particles.length
        }, taskId);
    }
    
    /**
     * 배치 파티클 업데이트 (성능 최적화)
     * @param {Object} data - 배치 데이터
     * @param {string} taskId - 작업 ID
     */
    batchUpdateParticles(data, taskId) {
        const { batches, currentTime } = data;
        const results = [];
        
        for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
            const batch = batches[batchIndex];
            const updatedBatch = [];
            
            for (let i = 0; i < batch.length; i++) {
                const particle = batch[i];
                
                if (!particle.exploding) {
                    updatedBatch.push(this.updateFormationParticle(particle, currentTime));
                } else {
                    updatedBatch.push(this.updateExplodingParticle(particle, currentTime));
                }
            }
            
            results.push({
                batchIndex,
                particles: updatedBatch
            });
        }
        
        this.sendResponse('BATCH_UPDATED', {
            results,
            processedBatches: results.length
        }, taskId);
    }
    
    /**
     * Easing 함수 (기존과 동일)
     * @param {number} t - 진행률 (0-1)
     * @returns {number} eased 값
     */
    easeInOutQuart(t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
    }
    
    /**
     * 성공 응답 전송
     * @param {string} type - 응답 타입
     * @param {Object} data - 응답 데이터
     * @param {string} taskId - 작업 ID
     */
    sendResponse(type, data, taskId) {
        self.postMessage({
            type,
            data,
            taskId,
            timestamp: performance.now()
        });
    }
    
    /**
     * 에러 응답 전송
     * @param {string} errorMessage - 에러 메시지
     * @param {string} taskId - 작업 ID
     */
    sendError(errorMessage, taskId) {
        self.postMessage({
            type: 'ERROR',
            data: { error: errorMessage },
            taskId,
            timestamp: performance.now()
        });
    }
}

// 워커 인스턴스 생성
new ParticleCalculatorWorker();
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path="AnimationManager.js">
/**
 * AnimationManager.js
 * 애니메이션 성능 최적화 및 리소스 관리 클래스
 * 메모리 누수 방지 및 렌더링 최적화
 */

class AnimationManager {
    constructor() {
        this.timers = new Set();
        this.animationFrames = new Set();
        this.canvasContexts = new Map();
        this.lastFrameTime = 0;
        this.targetFPS = 120;
        this.frameInterval = 1000 / this.targetFPS;
        
        // 성능 모니터링
        this.frameCount = 0;
        this.lastFPSUpdate = 0;
        this.currentFPS = 0;
    }
    
    /**
     * Canvas 컨텍스트를 캐시하여 성능 향상
     * @param {string} canvasId - 캔버스 ID
     * @returns {CanvasRenderingContext2D} 캐시된 컨텍스트
     */
    getOptimizedContext(canvasId) {
        if (!this.canvasContexts.has(canvasId)) {
            const canvas = document.getElementById(canvasId);
            if (canvas) {
                const ctx = canvas.getContext('2d', {
                    alpha: false,  // 투명도 비활성화로 성능 향상
                    willReadFrequently: true,
                    desynchronized: true  // 성능 향상을 위한 비동기 렌더링
                });
                this.canvasContexts.set(canvasId, ctx);
            }
        }
        return this.canvasContexts.get(canvasId);
    }
    
    /**
     * 메모리 누수 방지를 위한 setTimeout 래퍼
     * @param {Function} callback - 실행할 함수
     * @param {number} delay - 지연 시간
     * @returns {number} 타이머 ID
     */
    setTimeout(callback, delay) {
        const id = setTimeout(() => {
            this.timers.delete(id);
            callback();
        }, delay);
        this.timers.add(id);
        return id;
    }
    
    /**
     * 메모리 누수 방지를 위한 requestAnimationFrame 래퍼
     * @param {Function} callback - 애니메이션 함수
     * @returns {number} 애니메이션 프레임 ID
     */
    requestAnimationFrame(callback) {
        const id = requestAnimationFrame((timestamp) => {
            this.animationFrames.delete(id);
            
            // FPS 모니터링 (제한 없이 자연스러운 애니메이션 허용)
            this.updateFPS(timestamp);
            callback(timestamp);
            this.lastFrameTime = timestamp;
        });
        this.animationFrames.add(id);
        return id;
    }
    
    /**
     * FPS 모니터링
     * @param {number} timestamp - 현재 타임스탬프
     */
    updateFPS(timestamp) {
        this.frameCount++;
        if (timestamp - this.lastFPSUpdate >= 1000) {
            this.currentFPS = this.frameCount;
            this.frameCount = 0;
            this.lastFPSUpdate = timestamp;
            
            // 성능 경고 (개발 모드에서만)
            if (this.currentFPS < 30) {
                console.warn(`낮은 FPS 감지: ${this.currentFPS}fps`);
            }
        }
    }
    
    /**
     * 특정 타이머 취소
     * @param {number} id - 타이머 ID
     */
    clearTimeout(id) {
        if (this.timers.has(id)) {
            clearTimeout(id);
            this.timers.delete(id);
        }
    }
    
    /**
     * 특정 애니메이션 프레임 취소
     * @param {number} id - 애니메이션 프레임 ID
     */
    cancelAnimationFrame(id) {
        if (this.animationFrames.has(id)) {
            cancelAnimationFrame(id);
            this.animationFrames.delete(id);
        }
    }
    
    /**
     * 모든 타이머 및 애니메이션 정리
     */
    cleanup() {
        // 모든 타이머 정리
        this.timers.forEach(id => clearTimeout(id));
        this.timers.clear();
        
        // 모든 애니메이션 프레임 정리
        this.animationFrames.forEach(id => cancelAnimationFrame(id));
        this.animationFrames.clear();
        
        // 컨텍스트 캐시 정리
        this.canvasContexts.clear();
        
        console.log('AnimationManager 리소스 정리 완료');
    }
    
    /**
     * 현재 FPS 반환
     * @returns {number} 현재 FPS
     */
    getCurrentFPS() {
        return this.currentFPS;
    }
    
    /**
     * 활성 리소스 정보 반환
     * @returns {Object} 리소스 정보
     */
    getResourceInfo() {
        return {
            activeTimers: this.timers.size,
            activeAnimations: this.animationFrames.size,
            cachedContexts: this.canvasContexts.size,
            currentFPS: this.currentFPS
        };
    }
}

// 싱글톤 인스턴스
const animationManager = new AnimationManager();

export default animationManager;
</file>

<file path="deploy.sh">
#!/bin/bash

# Render.com 배포 스크립트
echo "🚀 Particle Photo Admin 배포 준비 중..."

# 1. 현재 상태 확인
echo "📋 현재 Git 상태 확인..."
git status

# 2. 변경사항 커밋
echo "💾 변경사항 커밋 중..."
git add .
git commit -m "Deploy to Render.com - $(date)"

# 3. GitHub에 푸시
echo "📤 GitHub에 푸시 중..."
git push origin main

echo "✅ 배포 준비 완료!"
echo ""
echo "📝 다음 단계:"
echo "1. Render.com에 로그인"
echo "2. 'New +' → 'Web Service' 선택"
echo "3. GitHub 저장소 연결"
echo "4. 환경 변수 설정 (DEPLOYMENT_CHECKLIST.md 참고)"
echo "5. 'Create Web Service' 클릭"
echo ""
echo "🔗 배포 체크리스트: DEPLOYMENT_CHECKLIST.md"
echo "�� 상세 가이드: README.md"
</file>

<file path="firebase.js">
// 환경 변수 로드
require('dotenv').config();

const admin = require('firebase-admin');

// 환경 변수에서 Firebase 설정 읽기
const serviceAccount = {
  type: process.env.FIREBASE_TYPE || 'service_account',
  project_id: process.env.FIREBASE_PROJECT_ID,
  private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
  private_key: process.env.FIREBASE_PRIVATE_KEY ? 
    process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n') : undefined,
  client_email: process.env.FIREBASE_CLIENT_EMAIL,
  client_id: process.env.FIREBASE_CLIENT_ID,
  auth_uri: process.env.FIREBASE_AUTH_URI || 'https://accounts.google.com/o/oauth2/auth',
  token_uri: process.env.FIREBASE_TOKEN_URI || 'https://oauth2.googleapis.com/token',
  auth_provider_x509_cert_url: process.env.FIREBASE_AUTH_PROVIDER_X509_CERT_URL || 'https://www.googleapis.com/oauth2/v1/certs',
  client_x509_cert_url: process.env.FIREBASE_CLIENT_X509_CERT_URL
};

// Firebase 초기화 (환경 변수가 설정된 경우에만)
let db, bucket, auth;

if (process.env.FIREBASE_PROJECT_ID && process.env.FIREBASE_PRIVATE_KEY) {
  try {
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
      storageBucket: process.env.FIREBASE_STORAGE_BUCKET
    });

    db = admin.firestore();
    bucket = admin.storage().bucket();
    auth = admin.auth();
    
    console.log('Firebase 초기화 성공');
  } catch (error) {
    console.error('Firebase 초기화 실패:', error.message);
    console.log('Firebase 기능을 사용할 수 없습니다. 로컬 파일 시스템을 사용합니다.');
  }
} else {
  console.log('Firebase 환경 변수가 설정되지 않았습니다. 로컬 파일 시스템을 사용합니다.');
}

module.exports = { admin, db, bucket, auth };
</file>

<file path="ImageWorkerManager.js">
/**
 * ImageWorkerManager.js
 * ImageProcessorWorker와 메인 스레드 간의 통신을 관리하는 클래스
 * Promise 기반 비동기 처리 및 작업 큐 관리
 */

class ImageWorkerManager {
    constructor() {
        this.worker = null;
        this.pendingTasks = new Map();
        this.taskIdCounter = 0;
        this.isInitialized = false;
        this.retryCount = 3;
        
        this.initWorker();
    }
    
    /**
     * 워커 초기화
     */
    initWorker() {
        try {
            this.worker = new Worker('./workers/ImageProcessorWorker.js');
            this.worker.onmessage = this.handleWorkerMessage.bind(this);
            this.worker.onerror = this.handleWorkerError.bind(this);
            
            // 워커 생존 확인
            this.pingWorker().then(() => {
                this.isInitialized = true;
                console.log('ImageWorkerManager 초기화 완료');
            }).catch((error) => {
                console.error('워커 초기화 실패:', error);
                this.fallbackToMainThread = true;
            });
            
        } catch (error) {
            console.error('웹 워커 생성 실패:', error);
            this.fallbackToMainThread = true;
        }
    }
    
    /**
     * 워커 생존 확인
     * @returns {Promise} 핑 결과
     */
    pingWorker() {
        return this.sendMessage('PING', {});
    }
    
    /**
     * 이미지 데이터를 비동기로 처리
     * @param {ImageData} imageData - 처리할 이미지 데이터
     * @param {number} stepPixel - 픽셀 스텝
     * @param {number} canvasWidth - 캔버스 너비
     * @param {number} canvasHeight - 캔버스 높이
     * @param {Object} cropInfo - 크롭 정보
     * @returns {Promise<Array>} 처리된 픽셀 데이터
     */
    async processImageAsync(imageData, stepPixel, canvasWidth, canvasHeight, cropInfo = {}) {
        // 워커가 초기화되지 않았거나 폴백 모드인 경우 메인 스레드에서 처리
        if (!this.isInitialized || this.fallbackToMainThread) {
            return this.processImageMainThread(imageData, stepPixel, canvasWidth, canvasHeight, cropInfo);
        }
        
        try {
            const result = await this.sendMessage('PROCESS_IMAGE', {
                imageData: {
                    data: imageData.data,
                    width: imageData.width,
                    height: imageData.height
                },
                stepPixel,
                canvasWidth,
                canvasHeight,
                offsetX: cropInfo.offsetX || 0,
                offsetY: cropInfo.offsetY || 0,
                drawWidth: cropInfo.drawWidth || canvasWidth,
                drawHeight: cropInfo.drawHeight || canvasHeight,
                startTime: performance.now()
            });
            
            return result.pixelData;
            
        } catch (error) {
            console.warn('워커에서 이미지 처리 실패, 메인 스레드로 폴백:', error);
            return this.processImageMainThread(imageData, stepPixel, canvasWidth, canvasHeight, cropInfo);
        }
    }
    
    /**
     * 메인 스레드에서 이미지 처리 (폴백)
     * @param {ImageData} imageData - 처리할 이미지 데이터
     * @param {number} stepPixel - 픽셀 스텝  
     * @param {number} canvasWidth - 캔버스 너비
     * @param {number} canvasHeight - 캔버스 높이
     * @param {Object} cropInfo - 크롭 정보
     * @returns {Array} 처리된 픽셀 데이터
     */
    processImageMainThread(imageData, stepPixel, canvasWidth, canvasHeight, cropInfo = {}) {
        const pixelData = [];
        const data = imageData.data;
        const { offsetX = 0, offsetY = 0, drawWidth = canvasWidth, drawHeight = canvasHeight } = cropInfo;
        
        // 기존 imageLoader.js와 동일한 로직
        for (let y = 0; y < drawHeight; y += stepPixel) {
            for (let x = 0; x < drawWidth; x += stepPixel) {
                const actualX = Math.floor(x + offsetX);
                const actualY = Math.floor(y + offsetY);
                
                if (actualX >= 0 && actualY >= 0 && actualX < canvasWidth && actualY < canvasHeight) {
                    const idx = (actualY * canvasWidth + actualX) * 4;
                    
                    if (idx < data.length - 2) {
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        // 색상 반전
                        const invertedR = 255 - r;
                        const invertedG = 255 - g;
                        const invertedB = 255 - b;
                        
                        pixelData.push({
                            x: actualX,
                            y: actualY,
                            color: { r: invertedR, g: invertedG, b: invertedB }
                        });
                    }
                }
            }
        }
        
        return pixelData;
    }
    
    /**
     * 워커에게 메시지 전송
     * @param {string} type - 메시지 타입
     * @param {Object} data - 전송할 데이터
     * @returns {Promise} 응답 Promise
     */
    sendMessage(type, data) {
        return new Promise((resolve, reject) => {
            const taskId = this.generateTaskId();
            const timeout = setTimeout(() => {
                this.pendingTasks.delete(taskId);
                reject(new Error(`워커 응답 시간 초과: ${type}`));
            }, 10000); // 10초 타임아웃
            
            this.pendingTasks.set(taskId, { resolve, reject, timeout });
            
            this.worker.postMessage({
                type,
                data,
                taskId
            });
        });
    }
    
    /**
     * 워커 메시지 처리
     * @param {MessageEvent} event - 워커 메시지 이벤트
     */
    handleWorkerMessage(event) {
        const { type, data, taskId } = event.data;
        
        const task = this.pendingTasks.get(taskId);
        if (!task) {
            console.warn('알 수 없는 작업 ID:', taskId);
            return;
        }
        
        clearTimeout(task.timeout);
        this.pendingTasks.delete(taskId);
        
        if (type === 'ERROR') {
            task.reject(new Error(data.error));
        } else {
            task.resolve(data);
        }
    }
    
    /**
     * 워커 에러 처리
     * @param {ErrorEvent} error - 워커 에러 이벤트
     */
    handleWorkerError(error) {
        console.error('ImageProcessorWorker 에러:', error);
        
        // 모든 대기 중인 작업을 실패로 처리
        this.pendingTasks.forEach((task) => {
            clearTimeout(task.timeout);
            task.reject(new Error('워커 에러 발생'));
        });
        this.pendingTasks.clear();
        
        // 폴백 모드로 전환
        this.fallbackToMainThread = true;
    }
    
    /**
     * 고유 작업 ID 생성
     * @returns {string} 작업 ID
     */
    generateTaskId() {
        return `task_${++this.taskIdCounter}_${Date.now()}`;
    }
    
    /**
     * 워커 정리
     */
    cleanup() {
        if (this.worker) {
            this.worker.terminate();
            this.worker = null;
        }
        
        // 모든 대기 중인 작업 취소
        this.pendingTasks.forEach((task) => {
            clearTimeout(task.timeout);
            task.reject(new Error('워커가 종료됨'));
        });
        this.pendingTasks.clear();
        
        console.log('ImageWorkerManager 정리 완료');
    }
    
    /**
     * 현재 상태 정보 반환
     * @returns {Object} 상태 정보
     */
    getStatus() {
        return {
            isInitialized: this.isInitialized,
            fallbackMode: this.fallbackToMainThread,
            pendingTasks: this.pendingTasks.size,
            workerAvailable: !!this.worker
        };
    }
}

// 싱글톤 인스턴스
const imageWorkerManager = new ImageWorkerManager();

export default imageWorkerManager;
</file>

<file path="integration.test.js">
/**
 * integration.test.js
 * 리팩토링 후 기존 기능 보존 확인 테스트
 */

// Mock DOM elements
document.body.innerHTML = `
  <canvas id="imageCanvas1"></canvas>
  <canvas id="imageCanvas2"></canvas>
  <canvas id="imageCanvas3"></canvas>
  <canvas id="imageCanvas4"></canvas>
  <div id="imageCanvas1_text"></div>
  <div id="imageCanvas2_text"></div>
  <div id="imageCanvas3_text"></div>
  <div id="imageCanvas4_text"></div>
`;

// Mock Image constructor
global.Image = class {
  constructor() {
    this.onload = null;
    this.onerror = null;
    this.src = '';
  }
  
  // Simulate successful image load
  simulateLoad() {
    this.width = 100;
    this.height = 100;
    if (this.onload) this.onload();
  }
  
  // Simulate image load error
  simulateError() {
    if (this.onerror) this.onerror();
  }
};

describe('Integration Tests - Refactored Data Structure', () => {
  let mockPeopleData;
  
  beforeEach(() => {
    // Mock people 데이터
    mockPeopleData = [
      {
        name: "ShinHyokyeong",
        koreanName: "신효경",
        imageUrl: "https://storage.googleapis.com/hninepeople.appspot.com/people/ShinHyokyeong.png"
      },
      {
        name: "KimJieun",
        koreanName: "김지은", 
        imageUrl: "https://storage.googleapis.com/hninepeople.appspot.com/people/KimJieun.png"
      }
    ];
  });

  describe('Data Loading Integration', () => {
    test('loadImages가 people 데이터를 올바르게 처리해야 함', async () => {
      // Given: people 데이터
      const imageList = mockPeopleData;
      
      // When: loadImages 호출
      const result = await loadImages(imageList, 24);
      
      // Then: 올바른 구조로 반환
      expect(Array.isArray(result)).toBe(true);
      expect(result.length).toBeGreaterThan(0);
      result.forEach(item => {
        expect(item).toHaveProperty('imageName');
        expect(item).toHaveProperty('pixels');
        expect(Array.isArray(item.pixels)).toBe(true);
      });
    });

    test('imageDataArray가 올바르게 설정되어야 함', async () => {
      // Given: people 데이터
      const imageList = mockPeopleData;
      
      // When: loadImages 실행
      await loadImages(imageList, 24);
      
      // Then: imageDataArray 설정 확인
      expect(imageDataArray).toBeDefined();
      expect(Array.isArray(imageDataArray)).toBe(true);
      expect(imageDataArray.length).toBeGreaterThan(0);
    });
  });

  describe('Main Application Flow', () => {
    test('shuffleArray가 people 데이터와 호환되어야 함', () => {
      // Given: people 데이터에서 이름 추출
      const originWords = mockPeopleData.map(p => p.name);
      
      // When: 셔플 실행
      const shuffled = shuffleArray([...originWords]);
      
      // Then: 올바른 셔플 결과
      expect(shuffled).toHaveLength(originWords.length);
      expect(shuffled).toEqual(expect.arrayContaining(originWords));
    });

    test('텍스트 변환 함수가 올바르게 동작해야 함', () => {
      // Given: 카멜케이스 텍스트
      const originalText = "ShinHyokyeong";
      
      // When: 공백 추가 함수 실행
      const modifiedText = originalText.replace(/([a-z])([A-Z])/g, '$1 $2');
      
      // Then: 올바른 변환
      expect(modifiedText).toBe("Shin Hyokyeong");
    });
  });

  describe('Image Loading Fallback', () => {
    test('imageUrl이 없을 때 로컬 경로 fallback이 동작해야 함', async () => {
      // Given: imageUrl이 없는 데이터
      const imageList = [
        { name: "TestImage", imageUrl: null }
      ];
      
      // When: loadImages 실행 (실제로는 에러 처리 테스트)
      try {
        await loadImages(imageList, 24);
      } catch (error) {
        // Then: 적절한 에러 처리
        expect(error).toBeDefined();
      }
    });
  });

  describe('Canvas Animation Compatibility', () => {
    test('캔버스 크기 설정이 올바르게 동작해야 함', () => {
      // Given: 캔버스 요소
      const canvas = document.getElementById('imageCanvas1');
      const ctx = canvas.getContext('2d');
      
      // When: 캔버스 크기 설정
      canvas.width = window.innerWidth / 4;
      canvas.height = window.innerHeight;
      
      // Then: 올바른 크기 설정
      expect(canvas.width).toBe(window.innerWidth / 4);
      expect(canvas.height).toBe(window.innerHeight);
    });
  });
});

describe('Performance Tests', () => {
  test('대량의 people 데이터 처리 시 성능이 적절해야 함', async () => {
    // Given: 대량의 테스트 데이터
    const largeImageList = Array.from({ length: 100 }, (_, i) => ({
      name: `TestPerson${i}`,
      imageUrl: `https://example.com/image${i}.png`
    }));
    
    // When: 대량 데이터 처리
    const startTime = performance.now();
    try {
      await loadImages(largeImageList, 24);
    } catch (error) {
      // 에러가 발생해도 성능 측정은 가능
    }
    const endTime = performance.now();
    
    // Then: 적절한 처리 시간 (5초 이내)
    expect(endTime - startTime).toBeLessThan(5000);
  });
});
</file>

<file path="OptimizedParticlePool.js">
/**
 * OptimizedParticlePool.js
 * 메모리 효율적인 파티클 풀 관리 클래스
 * 기존 비주얼과 기능을 완전히 보존하면서 성능만 개선
 */

import Particle from './Particle.js';

class OptimizedParticlePool {
    constructor(size) {
        this.size = size;
        this.pool = new Array(size);
        this.activeParticles = [];
        this.activeCount = 0;
        
        // 전체 애니메이션 상태 관리
        this.allPositionsComplete = false;
        this.globalSizingStartTime = 0;
        this.lastPositionCheckTime = 0;
        
        // 초기화 시 한 번만 파티클 객체들을 생성
        for (let i = 0; i < size; i++) {
            this.pool[i] = new Particle(0, 0, { r: 120, g: 120, b: 120 }, 0, 0, 26);
        }
        
        console.log(`ParticlePool 초기화 완료: ${size}개 파티클`);
    }
    
    /**
     * 파티클 풀에서 활성 파티클들을 가져와서 초기화
     * @param {Array} imageData - 이미지 픽셀 데이터
     * @param {number} canvasWidth - 캔버스 너비
     * @param {number} canvasHeight - 캔버스 높이
     * @param {number} stepPixel - 픽셀 스텝
     * @returns {Array} 활성화된 파티클 배열
     */
    activateParticles(imageData, canvasWidth, canvasHeight, stepPixel) {
        this.activeParticles.length = 0; // 배열 재할당 없이 초기화
        this.activeCount = Math.min(imageData.length, this.size);
        
        // 전체 상태 초기화
        this.allPositionsComplete = false;
        this.globalSizingStartTime = 0;
        this.lastPositionCheckTime = 0;
        
        for (let i = 0; i < this.activeCount; i++) {
            const particle = this.pool[i];
            const pixel = imageData[i];
            
            // 기존과 동일한 reset 로직
            particle.reset(pixel.x, pixel.y, pixel.color, canvasWidth, canvasHeight, stepPixel);
            this.activeParticles[i] = particle;
        }
        
        return this.activeParticles;
    }
    
    /**
     * 모든 파티클을 비활성화
     */
    deactivateAll() {
        this.activeCount = 0;
        this.activeParticles.length = 0;
    }
    
    /**
     * 활성 파티클 개수 반환
     */
    getActiveCount() {
        return this.activeCount;
    }
    
    /**
     * 활성 파티클 배열 반환 (읽기 전용)
     */
    getActiveParticles() {
        return this.activeParticles;
    }
    
    /**
     * 모든 파티클의 위치 완료 상태를 확인하고 사이즈 변화 시작
     * @param {number} currentTime - 현재 시간
     */
    updateGlobalState(currentTime) {
        // 0.1초마다 체크 (성능 최적화)
        if (currentTime - this.lastPositionCheckTime < 100) {
            return;
        }
        this.lastPositionCheckTime = currentTime;
        
        // 아직 전체 위치 완료가 안됐다면 체크
        if (!this.allPositionsComplete) {
            let allInPosition = true;
            for (let i = 0; i < this.activeCount; i++) {
                const particle = this.activeParticles[i];
                if (!particle.positionComplete) {
                    allInPosition = false;
                    break;
                }
            }
            
            if (allInPosition) {
                this.allPositionsComplete = true;
                this.globalSizingStartTime = currentTime;
                console.log('All particles in position, starting global sizing animation');
                
                // 모든 파티클에게 사이즈 변화 시작 알림
                for (let i = 0; i < this.activeCount; i++) {
                    const particle = this.activeParticles[i];
                    particle.startGlobalSizing(currentTime);
                }
            }
        }
    }
}

export default OptimizedParticlePool;
</file>

<file path="particle_photo_data_2025-07-03_15-20-13.csv">
한글이름,영문이름,조직,직무,직위,이메일,이미지파일명
"장하율","JangHaYeul","IX팀","Interaction Design","수석","hayeul.jang@hnine.com","JangHaYeul.png"
</file>

<file path="ParticleCalculatorWorkerManager.js">
/**
 * ParticleCalculatorWorkerManager.js
 * ParticleCalculatorWorker와 메인 스레드 간의 통신 관리
 * 8200개 파티클의 계산을 백그라운드에서 처리하여 메인 스레드 부하 감소
 */

class ParticleCalculatorWorkerManager {
    constructor() {
        this.worker = null;
        this.isSupported = typeof Worker !== 'undefined';
        this.taskQueue = new Map();
        this.taskId = 0;
        this.isInitialized = false;
        this.fallbackMode = false;
        
        if (this.isSupported) {
            this.initializeWorker();
        } else {
            console.warn('Web Workers not supported, using fallback mode');
            this.fallbackMode = true;
        }
    }
    
    /**
     * 워커 초기화
     */
    async initializeWorker() {
        try {
            this.worker = new Worker('./workers/ParticleCalculatorWorker.js');
            this.worker.onmessage = this.handleWorkerMessage.bind(this);
            this.worker.onerror = this.handleWorkerError.bind(this);
            
            // 워커 연결 테스트
            const pingResult = await this.sendMessage('PING', {});
            if (pingResult && pingResult.message === 'ParticleWorker is alive') {
                this.isInitialized = true;
                console.log('ParticleCalculatorWorker 초기화 성공');
            } else {
                throw new Error('Worker ping failed');
            }
        } catch (error) {
            console.warn('ParticleCalculatorWorker 초기화 실패, 폴백 모드 사용:', error);
            this.fallbackMode = true;
            this.isInitialized = false;
        }
    }
    
    /**
     * 워커 메시지 처리
     */
    handleWorkerMessage(event) {
        const { type, data, taskId, timestamp } = event.data;
        
        if (this.taskQueue.has(taskId)) {
            const { resolve, reject } = this.taskQueue.get(taskId);
            this.taskQueue.delete(taskId);
            
            if (type === 'ERROR') {
                reject(new Error(data.error));
            } else {
                resolve({ type, data, timestamp });
            }
        }
    }
    
    /**
     * 워커 에러 처리
     */
    handleWorkerError(error) {
        console.error('ParticleCalculatorWorker 에러:', error);
        this.fallbackMode = true;
        
        // 대기 중인 모든 작업을 거부
        this.taskQueue.forEach(({ reject }) => {
            reject(new Error('Worker error occurred'));
        });
        this.taskQueue.clear();
    }
    
    /**
     * 워커에게 메시지 전송
     */
    sendMessage(type, data, timeout = 5000) {
        return new Promise((resolve, reject) => {
            if (this.fallbackMode || !this.worker) {
                reject(new Error('Worker not available, using fallback'));
                return;
            }
            
            const taskId = `task_${++this.taskId}_${Date.now()}`;
            
            // 타임아웃 설정
            const timeoutId = setTimeout(() => {
                if (this.taskQueue.has(taskId)) {
                    this.taskQueue.delete(taskId);
                    reject(new Error('Worker task timeout'));
                }
            }, timeout);
            
            this.taskQueue.set(taskId, { 
                resolve: (result) => {
                    clearTimeout(timeoutId);
                    resolve(result);
                },
                reject: (error) => {
                    clearTimeout(timeoutId);
                    reject(error);
                }
            });
            
            this.worker.postMessage({ type, data, taskId });
        });
    }
    
    /**
     * 파티클 업데이트 (메인 기능)
     * @param {Array} particles - 파티클 배열
     * @param {number} currentTime - 현재 시간
     * @returns {Promise<Array>} 업데이트된 파티클 배열
     */
    async updateParticles(particles, currentTime) {
        if (this.fallbackMode || !this.isInitialized) {
            return this.fallbackUpdateParticles(particles, currentTime);
        }
        
        try {
            // 파티클 데이터를 워커로 전송 가능한 형태로 변환
            const particleData = particles.map(p => ({
                pos: { x: p.pos.x, y: p.pos.y },
                target: { x: p.target.x, y: p.target.y },
                velocity: { x: p.velocity.x, y: p.velocity.y },
                size: p.size,
                targetSize: p.targetSize,
                startTime: p.startTime,
                duration: p.duration,
                exploding: p.exploding,
                atTarget: p.atTarget,
                color: { r: p.color.r, g: p.color.g, b: p.color.b }
            }));
            
            const result = await this.sendMessage('UPDATE_PARTICLES', {
                particles: particleData,
                currentTime
            });
            
            if (result.type === 'PARTICLES_UPDATED') {
                // 워커에서 받은 데이터로 기존 파티클 객체들 업데이트
                const updatedData = result.data.particles;
                for (let i = 0; i < particles.length && i < updatedData.length; i++) {
                    const particle = particles[i];
                    const data = updatedData[i];
                    
                    particle.pos.x = data.pos.x;
                    particle.pos.y = data.pos.y;
                    particle.velocity.x = data.velocity.x;
                    particle.velocity.y = data.velocity.y;
                    particle.size = data.size;
                    particle.atTarget = data.atTarget;
                }
                return particles;
            } else {
                throw new Error('Unexpected response type');
            }
        } catch (error) {
            console.warn('Worker particle update failed, using fallback:', error);
            return this.fallbackUpdateParticles(particles, currentTime);
        }
    }
    
    /**
     * 폴백 모드: 메인 스레드에서 파티클 업데이트
     */
    fallbackUpdateParticles(particles, currentTime) {
        for (let i = 0; i < particles.length; i++) {
            particles[i].update(currentTime);
        }
        return particles;
    }
    
    /**
     * 폭발 계산
     * @param {Array} particles - 파티클 배열
     * @param {number} explosionDelay - 폭발 지연 시간
     * @returns {Promise<Array>} 폭발 데이터
     */
    async calculateExplosion(particles, explosionDelay = 4000) {
        if (this.fallbackMode || !this.isInitialized) {
            return this.fallbackCalculateExplosion(particles, explosionDelay);
        }
        
        try {
            const result = await this.sendMessage('CALCULATE_EXPLOSION', {
                particles: particles.map(p => ({ index: p.index || 0 })),
                explosionDelay
            });
            
            if (result.type === 'EXPLOSION_CALCULATED') {
                return result.data.explosionData;
            } else {
                throw new Error('Unexpected response type');
            }
        } catch (error) {
            console.warn('Worker explosion calculation failed, using fallback:', error);
            return this.fallbackCalculateExplosion(particles, explosionDelay);
        }
    }
    
    /**
     * 폴백 모드: 메인 스레드에서 폭발 계산
     */
    fallbackCalculateExplosion(particles, explosionDelay) {
        const explosionData = [];
        for (let i = 0; i < particles.length; i++) {
            const delay = Math.random() * explosionDelay;
            const velocity = {
                x: (Math.random() - 0.5) * 3,
                y: (Math.random() - 0.5) * 2
            };
            
            explosionData.push({
                index: i,
                delay,
                velocity,
                exploding: true
            });
        }
        return explosionData;
    }
    
    /**
     * 배치 파티클 업데이트 (대용량 처리)
     * @param {Array} particleBatches - 파티클 배치 배열
     * @param {number} currentTime - 현재 시간
     * @returns {Promise<Array>} 업데이트된 배치 결과
     */
    async batchUpdateParticles(particleBatches, currentTime) {
        if (this.fallbackMode || !this.isInitialized) {
            return this.fallbackBatchUpdate(particleBatches, currentTime);
        }
        
        try {
            const batchData = particleBatches.map(batch => 
                batch.map(p => ({
                    pos: { x: p.pos.x, y: p.pos.y },
                    target: { x: p.target.x, y: p.target.y },
                    velocity: { x: p.velocity.x, y: p.velocity.y },
                    size: p.size,
                    targetSize: p.targetSize,
                    startTime: p.startTime,
                    duration: p.duration,
                    exploding: p.exploding,
                    atTarget: p.atTarget
                }))
            );
            
            const result = await this.sendMessage('BATCH_UPDATE', {
                batches: batchData,
                currentTime
            });
            
            if (result.type === 'BATCH_UPDATED') {
                return result.data.results;
            } else {
                throw new Error('Unexpected response type');
            }
        } catch (error) {
            console.warn('Worker batch update failed, using fallback:', error);
            return this.fallbackBatchUpdate(particleBatches, currentTime);
        }
    }
    
    /**
     * 폴백 모드: 메인 스레드에서 배치 업데이트
     */
    fallbackBatchUpdate(particleBatches, currentTime) {
        return particleBatches.map((batch, batchIndex) => ({
            batchIndex,
            particles: batch.map(p => {
                p.update(currentTime);
                return p;
            })
        }));
    }
    
    /**
     * 워커 상태 정보
     */
    getStatus() {
        return {
            isSupported: this.isSupported,
            isInitialized: this.isInitialized,
            fallbackMode: this.fallbackMode,
            pendingTasks: this.taskQueue.size,
            workerType: 'ParticleCalculatorWorker'
        };
    }
    
    /**
     * 리소스 정리
     */
    cleanup() {
        if (this.worker) {
            this.worker.terminate();
            this.worker = null;
        }
        
        this.taskQueue.clear();
        this.isInitialized = false;
        console.log('ParticleCalculatorWorkerManager 정리 완료');
    }
}

// 싱글톤 인스턴스
const particleCalculatorWorkerManager = new ParticleCalculatorWorkerManager();

export default particleCalculatorWorkerManager;
</file>

<file path="peopleDataLoader.js">
/**
 * peopleDataLoader.js
 * Firestore people 컬렉션에서 데이터를 로드하고 관리하는 모듈
 */

// 캐시 변수
let cachedPeopleData = null;
let cacheTimestamp = null;
const CACHE_DURATION = 5 * 60 * 1000; // 5분 캐시

/**
 * Firestore에서 people 데이터를 로드합니다.
 * @returns {Promise<Array>} people 데이터 배열
 */
export async function loadPeopleData() {
    // 캐시가 유효하면 캐시된 데이터 반환
    if (cachedPeopleData && cacheTimestamp && (Date.now() - cacheTimestamp) < CACHE_DURATION) {
        console.log('캐시된 people 데이터 사용');
        return cachedPeopleData;
    }

    try {
        console.log('Firestore에서 people 데이터 로드 중...');
        
        // 서버 API를 통해 people 데이터 조회
        const response = await fetch('/api/people');
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const peopleData = await response.json();
        
        // 데이터 구조 검증
        const validatedData = validatePeopleData(peopleData);
        
        // 캐시 업데이트
        cachedPeopleData = validatedData;
        cacheTimestamp = Date.now();
        
        console.log(`${validatedData.length}개의 people 데이터 로드 완료`);
        return validatedData;
        
    } catch (error) {
        console.error('People 데이터 로드 실패:', error);
        
        // 캐시된 데이터가 있으면 fallback으로 사용
        if (cachedPeopleData) {
            console.log('캐시된 데이터를 fallback으로 사용');
            return cachedPeopleData;
        }
        
        throw new Error('People 데이터를 로드할 수 없습니다.');
    }
}

/**
 * people 데이터 구조를 검증합니다.
 * @param {Array} data - 검증할 데이터
 * @returns {Array} 검증된 데이터
 */
function validatePeopleData(data) {
    if (!Array.isArray(data)) {
        throw new Error('People 데이터는 배열이어야 합니다.');
    }
    
            return data.filter(person => {
            // 필수 필드 검증 (서버에서는 englishName 사용)
            const hasRequiredFields = person.englishName && person.koreanName && person.imageUrl;
            
            if (!hasRequiredFields) {
                console.warn('필수 필드가 누락된 데이터:', person);
                return false;
            }
            
            // 데이터 타입 검증
            const hasValidTypes = typeof person.englishName === 'string' && 
                                 typeof person.koreanName === 'string' && 
                                 typeof person.imageUrl === 'string';
            
            if (!hasValidTypes) {
                console.warn('잘못된 데이터 타입:', person);
                return false;
            }
            
            return true;
        });
}

/**
 * 캐시를 강제로 무효화합니다.
 */
export function invalidateCache() {
    cachedPeopleData = null;
    cacheTimestamp = null;
    console.log('People 데이터 캐시 무효화됨');
}

/**
 * 기존 words.js 호환성을 위한 데이터 변환 함수들
 */
export function getOriginWords(peopleData) {
    return peopleData.map(person => person.englishName);
}

export function getOriginTexts(peopleData) {
    return peopleData.map(person => person.koreanName);
}

/**
 * 특정 이름으로 people 데이터를 찾습니다.
 * @param {string} name - 찾을 이름
 * @returns {Object|null} 찾은 데이터 또는 null
 */
export function findPersonByName(name, peopleData) {
    return peopleData.find(person => person.englishName === name) || null;
}

/**
 * 이미지 URL이 유효한지 확인합니다.
 * @param {string} imageUrl - 확인할 이미지 URL
 * @returns {Promise<boolean>} 유효성 여부
 */
export function validateImageUrl(imageUrl) {
    return new Promise((resolve) => {
        if (!imageUrl) {
            resolve(false);
            return;
        }
        
        const img = new Image();
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false);
        img.src = imageUrl;
    });
} 

/**
 * people 데이터를 로드해서 반환하는 initializePeopleData 함수 (words.js 대체)
 * @returns {Promise<Array>} people 데이터 배열
 */
export async function initializePeopleData() {
    return await loadPeopleData();
}

export function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}
</file>

<file path="peopleDataLoader.test.js">
/**
 * peopleDataLoader.test.js
 * Firestore people 데이터 로딩 및 처리 테스트
 */

// Mock Firebase Admin SDK
const mockFirestore = {
  collection: jest.fn(() => ({
    get: jest.fn()
  }))
};

// Mock people 데이터
const mockPeopleData = [
  {
    name: "ShinHyokyeong",
    koreanName: "신효경",
    imageUrl: "https://storage.googleapis.com/hninepeople.appspot.com/people/ShinHyokyeong.png"
  },
  {
    name: "KimJieun", 
    koreanName: "김지은",
    imageUrl: "https://storage.googleapis.com/hninepeople.appspot.com/people/KimJieun.png"
  }
];

describe('PeopleDataLoader', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('loadPeopleData', () => {
    test('Firestore에서 people 데이터를 성공적으로 로드해야 함', async () => {
      // Given: Firestore에서 데이터 반환
      mockFirestore.collection().get.mockResolvedValue({
        docs: mockPeopleData.map(doc => ({
          data: () => doc,
          id: doc.name
        }))
      });

      // When: 데이터 로드 실행
      const result = await loadPeopleData();

      // Then: 올바른 구조로 반환되어야 함
      expect(result).toHaveLength(2);
      expect(result[0]).toHaveProperty('name', 'ShinHyokyeong');
      expect(result[0]).toHaveProperty('koreanName', '신효경');
      expect(result[0]).toHaveProperty('imageUrl');
    });

    test('Firestore 연결 실패 시 적절한 에러를 던져야 함', async () => {
      // Given: Firestore 에러
      mockFirestore.collection().get.mockRejectedValue(new Error('Firestore connection failed'));

      // When & Then: 에러 처리 확인
      await expect(loadPeopleData()).rejects.toThrow('Firestore connection failed');
    });

    test('빈 데이터셋에 대해 빈 배열을 반환해야 함', async () => {
      // Given: 빈 데이터
      mockFirestore.collection().get.mockResolvedValue({
        docs: []
      });

      // When: 데이터 로드 실행
      const result = await loadPeopleData();

      // Then: 빈 배열 반환
      expect(result).toEqual([]);
    });
  });

  describe('Data Structure Validation', () => {
    test('모든 필수 필드가 포함되어야 함', async () => {
      // Given: 완전한 데이터
      mockFirestore.collection().get.mockResolvedValue({
        docs: mockPeopleData.map(doc => ({
          data: () => doc,
          id: doc.name
        }))
      });

      // When: 데이터 로드
      const result = await loadPeopleData();

      // Then: 필수 필드 검증
      result.forEach(person => {
        expect(person).toHaveProperty('name');
        expect(person).toHaveProperty('koreanName');
        expect(person).toHaveProperty('imageUrl');
        expect(typeof person.name).toBe('string');
        expect(typeof person.koreanName).toBe('string');
        expect(typeof person.imageUrl).toBe('string');
      });
    });
  });

  describe('Caching Mechanism', () => {
    test('캐시된 데이터가 있으면 Firestore 호출하지 않아야 함', async () => {
      // Given: 첫 번째 호출 성공
      mockFirestore.collection().get.mockResolvedValue({
        docs: mockPeopleData.map(doc => ({
          data: () => doc,
          id: doc.name
        }))
      });

      // When: 첫 번째 호출
      const result1 = await loadPeopleData();
      
      // Then: 두 번째 호출 시 캐시 사용
      const result2 = await loadPeopleData();
      
      expect(result1).toEqual(result2);
      expect(mockFirestore.collection().get).toHaveBeenCalledTimes(1);
    });
  });
});

describe('Integration with Existing Code', () => {
  test('originWords와 originTexts가 올바르게 생성되어야 함', async () => {
    // Given: people 데이터
    const peopleData = [
      { name: "Test1", koreanName: "테스트1" },
      { name: "Test2", koreanName: "테스트2" }
    ];

    // When: 데이터 변환
    const originWords = peopleData.map(p => p.name);
    const originTexts = peopleData.map(p => p.koreanName);

    // Then: 올바른 배열 생성
    expect(originWords).toEqual(["Test1", "Test2"]);
    expect(originTexts).toEqual(["테스트1", "테스트2"]);
  });
});
</file>

<file path="PerformanceMonitor.js">
/**
 * PerformanceMonitor.js
 * 성능 개선 효과를 측정하고 모니터링하는 유틸리티 클래스
 */

class PerformanceMonitor {
    constructor() {
        this.metrics = {
            frameRates: [],
            memoryUsage: [],
            imageProcessingTimes: [],
            particleUpdateTimes: [],
            renderTimes: []
        };
        
        this.isMonitoring = false;
        this.startTime = 0;
        this.frameCount = 0;
        this.lastFrameTime = 0;
        
        // 개발 모드에서만 활성화
        this.enabledInProduction = false;
    }
    
    /**
     * 모니터링 시작
     */
    start() {
        if (!this.shouldMonitor()) return;
        
        this.isMonitoring = true;
        this.startTime = performance.now();
        this.frameCount = 0;
        this.lastFrameTime = 0;
        
        console.log('🚀 Performance monitoring started');
        
        // 주기적으로 메모리 사용량 측정
        this.memoryInterval = setInterval(() => {
            this.recordMemoryUsage();
        }, 1000);
        
        // 5분 후 자동으로 리포트 생성
        this.reportTimeout = setTimeout(() => {
            this.generateReport();
        }, 300000);
    }
    
    /**
     * 모니터링 중지
     */
    stop() {
        if (!this.isMonitoring) return;
        
        this.isMonitoring = false;
        
        if (this.memoryInterval) {
            clearInterval(this.memoryInterval);
        }
        
        if (this.reportTimeout) {
            clearTimeout(this.reportTimeout);
        }
        
        console.log('⏹️ Performance monitoring stopped');
    }
    
    /**
     * 프레임 렌더링 시간 기록
     * @param {number} startTime - 렌더링 시작 시간
     */
    recordFrame(startTime) {
        if (!this.shouldMonitor()) return;
        
        const endTime = performance.now();
        const frameTime = endTime - startTime;
        const currentTime = endTime;
        
        // FPS 계산
        if (this.lastFrameTime > 0) {
            const timeDiff = currentTime - this.lastFrameTime;
            const fps = 1000 / timeDiff;
            this.metrics.frameRates.push(fps);
        }
        
        this.metrics.renderTimes.push(frameTime);
        this.lastFrameTime = currentTime;
        this.frameCount++;
    }
    
    /**
     * 이미지 처리 시간 기록
     * @param {number} processingTime - 처리 시간 (ms)
     * @param {boolean} usedWorker - 웹 워커 사용 여부
     */
    recordImageProcessing(processingTime, usedWorker = false) {
        if (!this.shouldMonitor()) return;
        
        this.metrics.imageProcessingTimes.push({
            time: processingTime,
            worker: usedWorker,
            timestamp: performance.now()
        });
    }
    
    /**
     * 파티클 업데이트 시간 기록
     * @param {number} updateTime - 업데이트 시간 (ms)
     * @param {number} particleCount - 파티클 개수
     */
    recordParticleUpdate(updateTime, particleCount) {
        if (!this.shouldMonitor()) return;
        
        this.metrics.particleUpdateTimes.push({
            time: updateTime,
            count: particleCount,
            timestamp: performance.now()
        });
    }
    
    /**
     * 메모리 사용량 기록
     */
    recordMemoryUsage() {
        if (!this.shouldMonitor()) return;
        
        if (performance.memory) {
            this.metrics.memoryUsage.push({
                used: performance.memory.usedJSHeapSize,
                total: performance.memory.totalJSHeapSize,
                limit: performance.memory.jsHeapSizeLimit,
                timestamp: performance.now()
            });
        }
    }
    
    /**
     * 현재 FPS 반환
     * @returns {number} 현재 FPS
     */
    getCurrentFPS() {
        if (this.metrics.frameRates.length === 0) return 0;
        
        // 최근 10프레임의 평균 FPS
        const recent = this.metrics.frameRates.slice(-10);
        return recent.reduce((sum, fps) => sum + fps, 0) / recent.length;
    }
    
    /**
     * 성능 리포트 생성
     * @returns {Object} 성능 분석 결과
     */
    generateReport() {
        if (!this.shouldMonitor()) return null;
        
        const totalTime = performance.now() - this.startTime;
        
        const report = {
            duration: totalTime,
            frameCount: this.frameCount,
            
            // FPS 통계
            fps: this.calculateStats(this.metrics.frameRates),
            
            // 렌더링 시간 통계
            renderTime: this.calculateStats(this.metrics.renderTimes),
            
            // 이미지 처리 통계
            imageProcessing: this.analyzeImageProcessing(),
            
            // 파티클 업데이트 통계
            particleUpdate: this.analyzeParticleUpdates(),
            
            // 메모리 사용량 분석
            memory: this.analyzeMemoryUsage(),
            
            // 전체 성능 점수 (0-100)
            performanceScore: this.calculatePerformanceScore()
        };
        
        console.group('📊 Performance Report');
        console.log('Duration:', `${(totalTime / 1000).toFixed(2)}s`);
        console.log('Average FPS:', report.fps.average?.toFixed(1));
        console.log('Frame Time (avg):', `${report.renderTime.average?.toFixed(2)}ms`);
        console.log('Performance Score:', `${report.performanceScore}/100`);
        
        if (report.imageProcessing.workerUsage > 0) {
            console.log('Worker Usage:', `${(report.imageProcessing.workerUsage * 100).toFixed(1)}%`);
        }
        
        console.groupEnd();
        
        return report;
    }
    
    /**
     * 통계 계산
     * @param {Array} values - 값 배열
     * @returns {Object} 통계 결과
     */
    calculateStats(values) {
        if (values.length === 0) return null;
        
        const sorted = [...values].sort((a, b) => a - b);
        
        return {
            count: values.length,
            average: values.reduce((sum, val) => sum + val, 0) / values.length,
            median: sorted[Math.floor(sorted.length / 2)],
            min: sorted[0],
            max: sorted[sorted.length - 1],
            p95: sorted[Math.floor(sorted.length * 0.95)]
        };
    }
    
    /**
     * 이미지 처리 분석
     * @returns {Object} 분석 결과
     */
    analyzeImageProcessing() {
        const times = this.metrics.imageProcessingTimes;
        if (times.length === 0) return null;
        
        const workerTimes = times.filter(t => t.worker).map(t => t.time);
        const mainThreadTimes = times.filter(t => !t.worker).map(t => t.time);
        
        return {
            total: times.length,
            workerUsage: workerTimes.length / times.length,
            workerStats: this.calculateStats(workerTimes),
            mainThreadStats: this.calculateStats(mainThreadTimes),
            averageSpeedup: this.calculateSpeedup(workerTimes, mainThreadTimes)
        };
    }
    
    /**
     * 파티클 업데이트 분석
     * @returns {Object} 분석 결과
     */
    analyzeParticleUpdates() {
        const updates = this.metrics.particleUpdateTimes;
        if (updates.length === 0) return null;
        
        const times = updates.map(u => u.time);
        const counts = updates.map(u => u.count);
        
        return {
            updateStats: this.calculateStats(times),
            particleStats: this.calculateStats(counts),
            efficiency: this.calculateStats(updates.map(u => u.time / u.count))
        };
    }
    
    /**
     * 메모리 사용량 분석
     * @returns {Object} 분석 결과
     */
    analyzeMemoryUsage() {
        const memory = this.metrics.memoryUsage;
        if (memory.length === 0) return null;
        
        const usedMB = memory.map(m => m.used / 1024 / 1024);
        const totalMB = memory.map(m => m.total / 1024 / 1024);
        
        return {
            used: this.calculateStats(usedMB),
            total: this.calculateStats(totalMB),
            peak: Math.max(...usedMB),
            growth: usedMB[usedMB.length - 1] - usedMB[0]
        };
    }
    
    /**
     * 성능 개선 계산
     * @param {Array} workerTimes - 워커 처리 시간
     * @param {Array} mainThreadTimes - 메인 스레드 처리 시간
     * @returns {number} 개선 배수
     */
    calculateSpeedup(workerTimes, mainThreadTimes) {
        if (workerTimes.length === 0 || mainThreadTimes.length === 0) return 1;
        
        const workerAvg = workerTimes.reduce((sum, t) => sum + t, 0) / workerTimes.length;
        const mainAvg = mainThreadTimes.reduce((sum, t) => sum + t, 0) / mainThreadTimes.length;
        
        return mainAvg / workerAvg;
    }
    
    /**
     * 전체 성능 점수 계산
     * @returns {number} 성능 점수 (0-100)
     */
    calculatePerformanceScore() {
        let score = 100;
        
        // FPS 기반 점수 (30fps 이하 감점)
        const avgFPS = this.getCurrentFPS();
        if (avgFPS < 60) score -= (60 - avgFPS) * 2;
        if (avgFPS < 30) score -= 20;
        
        // 메모리 사용량 기반 감점
        const memory = this.analyzeMemoryUsage();
        if (memory && memory.peak > 100) { // 100MB 초과
            score -= Math.min(20, (memory.peak - 100) / 10);
        }
        
        // 렌더링 시간 기반 감점
        const renderStats = this.calculateStats(this.metrics.renderTimes);
        if (renderStats && renderStats.average > 16.67) { // 60fps 기준
            score -= Math.min(15, (renderStats.average - 16.67) / 2);
        }
        
        return Math.max(0, Math.min(100, Math.round(score)));
    }
    
    /**
     * 모니터링 실행 여부 확인
     * @returns {boolean} 모니터링 실행 여부
     */
    shouldMonitor() {
        return (
            typeof window !== 'undefined' &&
            (window.location.hostname === 'localhost' || 
             window.location.hostname === '127.0.0.1' ||
             this.enabledInProduction)
        );
    }
    
    /**
     * 실시간 성능 정보 반환
     * @returns {Object} 실시간 성능 정보
     */
    getRealTimeStats() {
        return {
            isMonitoring: this.isMonitoring,
            currentFPS: this.getCurrentFPS(),
            frameCount: this.frameCount,
            runtime: this.isMonitoring ? performance.now() - this.startTime : 0,
            memoryUsed: performance.memory ? 
                Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) : 'N/A'
        };
    }
}

// 싱글톤 인스턴스
const performanceMonitor = new PerformanceMonitor();

export default performanceMonitor;
</file>

<file path="Procfile">
web: npm start
</file>

<file path="render.yaml">
services:
  - type: web
    name: particle-photo-admin
    env: node
    plan: free
    buildCommand: npm install
    startCommand: npm start
    envVars:
      - key: NODE_ENV
        value: production
      - key: PORT
        value: 10000
    healthCheckPath: /
</file>

<file path="server.test.js">
// server.test.js
const request = require('supertest');
const fs = require('fs');
const path = require('path');
const app = require('./server'); // server.js에서 app 객체를 export해야 함

describe('API 테스트: people 추가/조회/삭제', () => {
  it('POST /api/people - 인물 추가', async () => {
    const res = await request(app)
      .post('/api/people')
      .field('koreanName', '테스트유저')
      .field('englishName', 'TestUser')
      .field('organization', '테스트조직')
      .field('role', '테스트역할')
      .field('position', '테스트직위')
      .field('email', 'test@example.com')
      .attach('image', path.join(__dirname, 'test-image.png'));

    expect(res.statusCode).toBe(200);
    expect(res.body.success).toBe(true);
  });

  it('GET /api/people - 인물 목록 조회', async () => {
    const res = await request(app).get('/api/people');
    expect(res.statusCode).toBe(200);
    expect(Array.isArray(res.body)).toBe(true);
    expect(res.body.find(p => p.englishName === 'TestUser')).toBeTruthy();
  });

  it('DELETE /api/people/:englishName - 인물 삭제', async () => {
    const res = await request(app).delete('/api/people/TestUser');
    expect(res.statusCode).toBe(200);
    expect(res.body.success).toBe(true);
  });
});
</file>

<file path="start_server.bat">
@echo off
REM Particle Photo 서버 실행 배치 파일 (Windows)

REM 현재 디렉토리로 이동 (필요시 수정)
cd /d %~dp0

REM 서버 실행
start "ParticlePhotoServer" cmd /k "node server.js"

REM 3초 대기 후 브라우저에서 관리자 페이지 열기
ping 127.0.0.1 -n 3 > nul
start http://localhost:3000/admin.html
</file>

<file path="styles.css">
@import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
@import url('https://fonts.cdnfonts.com/css/sofia-sans-condensed');
@import url('https://fonts.cdnfonts.com/css/fjalla-one-2');

body {
    margin: 0;
    overflow: hidden;
    padding: 0;
    font-family: 'Pretendard', sans-serif;
    /* font-family: 'Sofia Sans Condensed', sans-serif; */
    /* font-family: 'Fjalla One', sans-serif; */
    font-weight: 400;
    background-color: rgb(0, 0, 0);
}

.canvas-container {
    position: relative;
    width: 25%;
    /* 화면의 1/4 크기 */
    float: left;
    height: 100vh;
}

.canvas-text {
    position: absolute;
    color: rgb(255, 255, 255);
    font-size: 60px;
    opacity: 1;
    transition: opacity 1.5s ease-in-out;
    text-overflow: clip;
    word-break: break-word;
    white-space: normal;
    height: 500px;
    bottom: 0px;
    left: 0px;
    background: linear-gradient(0deg, rgb(0, 0, 0) 1.52%, rgba(0, 0, 0, 0) 100%);
    z-index: 1;
    padding: 50px;
    width: calc(100% - 100px);
    display: flex;
    align-items: flex-end;
    justify-content: flex-start;
    filter: blur(0px);
    transition: all 2s ease-in-out;
}

.canvas-text.hide {
    bottom: -500px;
    opacity: 0;
    filter: blur(100px);
}

/* .gradient {
    position: fixed;
    bottom: 0px;
    width: 100%;
    height: 300px;
    left: 0px;
    background: linear-gradient(0deg, #00000099 1.52%, rgba(0, 0, 0, 0) 100%);
    z-index: 0;
} */

canvas {
    width: 100%;
    height: 100%;
}
</file>

<file path="package.json">
{
  "name": "particle-photo-admin",
  "version": "1.0.0",
  "description": "Particle Photo 관리자 페이지 서버",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "csv-parse": "^5.5.2",
    "dotenv": "^16.6.1",
    "express": "^4.21.2",
    "firebase": "^11.10.0",
    "firebase-admin": "^13.4.0",
    "multer": "^1.4.5-lts.1",
    "yauzl": "^3.2.0"
  },
  "devDependencies": {
    "jest": "^30.0.3",
    "nodemon": "^3.0.1",
    "supertest": "^7.1.1"
  },
  "keywords": [
    "photo",
    "admin",
    "particle"
  ],
  "author": "",
  "license": "MIT"
}
</file>

<file path=".gitignore">
# macOS 시스템 파일
._*

# Firebase 보안 파일
firebase-service-account.json
firebase-config.js
firebase-credentials.json
*.firebase.json

# 환경 변수 파일
.env
.env.local
.env.development
.env.test
.env.production

# Node.js 관련
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json

# 로그 파일
*.log
logs/
*.log.*

# 임시 파일
*.tmp
*.temp
.DS_Store
Thumbs.db

# IDE 설정 파일
.vscode/
.idea/
*.swp
*.swo
*~

# 백업 파일
*.backup
*.bak
backup/
*.zip

# 테스트 관련
coverage/
.nyc_output/
test-results/

# 빌드 결과물
dist/
build/
out/

# CORS 설정 (보안상 민감할 수 있음)
cors.json

# 개인 정보가 포함된 데이터 파일
people.json
images.json

# 이미지 파일 (용량이 클 수 있음)
*.png
*.jpg
*.jpeg
*.gif
*.bmp
*.svg
images/

# 기타 보안 관련
*.pem
*.key
*.crt
*.p12
*.pfx
secrets/

# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/
jspm_packages/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Backup files
backup/
*.bak
*.backup

# Temporary files
*.tmp
*.temp
</file>

<file path="imageLoader.js">
import imageWorkerManager from './ImageWorkerManager.js';

// Use a Map for more flexible caching. Key is the person's absolute index.
export const imageDataCache = new Map();
let _shuffledPeople = [];
let _stepPixel = 20;

/**
 * Helper function to process a loaded image into pixel data.
 * 웹 워커를 사용하여 백그라운드에서 처리
 */
async function processImageToPixelData(img, stepPixel) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    canvas.width = window.innerWidth / 4;
    canvas.height = window.innerHeight;

    const imgAspectRatio = img.width / img.height;
    const canvasAspectRatio = canvas.width / canvas.height;

    let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

    if (imgAspectRatio > canvasAspectRatio) {
        drawHeight = canvas.height;
        drawWidth = drawHeight * imgAspectRatio;
        offsetX = (canvas.width - drawWidth) / 2;
    } else {
        drawWidth = canvas.width;
        drawHeight = drawWidth / imgAspectRatio;
        offsetY = (canvas.height - drawHeight) / 2;
    }

    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    try {
        // 웹 워커를 사용하여 이미지 처리
        const pixelData = await imageWorkerManager.processImageAsync(
            imageData, 
            stepPixel, 
            canvas.width, 
            canvas.height,
            { offsetX, offsetY, drawWidth, drawHeight }
        );
        
        // 투명하지 않은 픽셀만 필터링 (기존 로직 유지)
        return pixelData.filter(pixel => {
            const idx = (pixel.y * canvas.width + pixel.x) * 4;
            const a = imageData.data[idx + 3];
            return a > 128;
        });
        
    } catch (error) {
        console.warn('웹 워커 이미지 처리 실패, 메인 스레드로 폴백:', error);
        
        // 폴백: 메인 스레드에서 처리
        const pixelData = [];
        const data = imageData.data;

        for (let y = 0; y < canvas.height; y += stepPixel) {
            for (let x = 0; x < canvas.width; x += stepPixel) {
                const idx = (y * canvas.width + x) * 4;
                const a = data[idx + 3];

                if (a > 128) { // Only consider non-transparent pixels
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const invertedR = 255 - r;
                    const invertedG = 255 - g;
                    const invertedB = 255 - b;
                    pixelData.push({
                        x: x,
                        y: y,
                        color: { r: invertedR, g: invertedG, b: invertedB }
                    });
                }
            }
        }
        
        return pixelData;
    }
}

/**
 * Loads a single image and returns its pixel data along with its original index.
 * 이제 비동기 이미지 처리를 지원
 */
function loadImage(person, index, stepPixel) {
    return new Promise(async (resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = person.imageUrl;

        img.onload = async () => {
            try {
                const pixels = await processImageToPixelData(img, stepPixel);
                resolve({ index, pixels });
            } catch (error) {
                reject(error);
            }
        };

        img.onerror = () => {
            console.warn(`Failed to load from URL: ${person.imageUrl}. Falling back to local path.`);
            img.src = `images/${person.englishName}.png`;
            img.onload = async () => {
                try {
                    const pixels = await processImageToPixelData(img, stepPixel);
                    resolve({ index, pixels });
                } catch (error) {
                    reject(error);
                }
            };
            img.onerror = () => {
                console.error(`Failed to load image for ${person.englishName} from all sources.`);
                reject(new Error(`Failed to load image for ${person.englishName}`));
            };
        };
    });
}

/**
 * Loads a specific batch of images and adds them to the cache.
 * @param {number} startIndex The starting index in the shuffledPeople array.
 * @param {number} batchSize The number of images to load.
 */
export async function loadBatch(startIndex, batchSize) {
    const batchList = _shuffledPeople.slice(startIndex, startIndex + batchSize);
    if (batchList.length === 0) return;

    console.log(`Requesting to load batch from index ${startIndex}...`);
    const promises = batchList.map((person, i) => {
        const personIndex = startIndex + i;
        // Only load if not already in cache
        if (!imageDataCache.has(personIndex)) {
            return loadImage(person, personIndex, _stepPixel);
        }
        return Promise.resolve(null); // Return a resolved promise for already cached items
    });

    const results = await Promise.allSettled(promises);
    let successCount = 0;
    results.forEach(result => {
        if (result.status === 'fulfilled' && result.value) {
            imageDataCache.set(result.value.index, result.value.pixels);
            successCount++;
        }
    });
    if (successCount > 0) {
        console.log(`Successfully loaded and cached ${successCount} new images from batch starting at ${startIndex}.`);
    }
}

/**
 * Removes a specific batch of images from the cache to free up memory.
 * @param {number} startIndex The starting index of the batch to remove.
 * @param {number} batchSize The number of images to remove.
 */
export function cleanupBatch(startIndex, batchSize) {
    console.log(`Cleaning up image batch from index ${startIndex} to ${startIndex + batchSize - 1}.`);
    for (let i = 0; i < batchSize; i++) {
        imageDataCache.delete(startIndex + i);
    }
}

/**
 * Initializes the image loader with data and pre-loads the first two batches.
 * @param {Array} people The shuffled list of people data.
 * @param {number} stepPixel The stepping interval for pixel sampling.
 * @param {number} batchSize The size of one batch.
 */
export async function initializeImageLoader(people, stepPixel, batchSize) {
    _shuffledPeople = people;
    _stepPixel = stepPixel;
    console.log("Loading initial image batches (for indices 0 and 1)...");
    // Load batch 0 and 1 in parallel to have a buffer
    await Promise.all([
        loadBatch(0, batchSize),
        loadBatch(batchSize, batchSize)
    ]);
    console.log("Initial image batches are loaded and cached.");
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Photo</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div style="display: none;">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/AhnHyeonseo.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=Eehy7Y0%2FoA3sfzlPVvPlYoEgjxpW9WnOAyO8HUOOexdHdphjGV%2FBetZ9PzO%2FXAMAWYPlHhIVydRsiNK6qpyrKB81%2F0ZeLtrNeCPwazaM%2BmmWP7405LeqpY0vpLD4JFY%2F0dwEwZMQcIt3wOpIlIOtLcj7oJgrHbPfLSjslBgutxjfzuT9WPMk4WGwoCGK2%2Fa%2FbkvNom7lkH023gFLDO%2BIaCXGSg9kWG%2FblBBxA4SiLbXgHDJGcu0EHI1afbzaWQmQaMu32BZrX%2B14xEaaxGOIYOWRt4abNMtgphnf3fXGrG7FI4uptDzqKoD4KZ8W0bYIHhrGabWsTvjSCRRksrwpPg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/BaeJisu.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=mE5Ipdv7Q4G7muLPlYgO4DpOwqvTGRz6vwwaIUMW%2FfQk1uejfgAkp3PgOQfYrxK1C2AD0VNgjd97lG9oiyaHmeZHJf%2BCXFrWQCCIxzFstJJVRe36ftdQCXEhiOdcUWTwicAoCtXqa7hf%2FB6t31TRIgDrD%2BmOIH5yU7UHAOMfVoiFXo%2FP%2Bn5sDLFBX2HEngjFrv8t97LHCLM%2FKqiZpvUQNbRPaHV9flusQIcy8157394UnEcKxKGPJKS2YVzRUNXUQjYNzgL1ANBDm0VHsmn%2BUU2kbvQ6JJuV5Yr3W%2BnmNXgTaq%2B7qbLygtsSQpfIY03iIF725T85DTSIaj8TEwnpTw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/BaeSeongmin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=I0kvJZmXSPURu%2FfRbSaBM6KO3TDasoVUG1cRwTMY2AuW26XJ9v6JoY2QpbiAun5QE2gLt8gg36Lc%2FPkmCaDMVk2b88AIVoRvQGlcq7MyrZT7uOafRvxed%2Bn6f0VyBX2xpvZ71yGBD%2BdQ5aAc0VJUL29QIMYAPxySQDJ5eW%2F0deOZmKRUQikLsDFKRPDHNRrY5%2FRi5DPPQXD9WKIVmfkFsQA3EEr2VUKbX%2BoL5BCMm7Z8iLZIbdWggJrWznWLKrDYznbH4rUfmfbI6vI5CM0ZvsU69J5uwHjDmZ6FFCyHzpLogysM93lYF9J1Ijl16xWVhNgzrYFHar0Kr6emsMJMjQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/BaeYounchan.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=PvlvXWFHu0EdxDqAMU8ebK73laMpginPe9JbkD7ZBImP1QJyRnQ8pUZLvcM02YG%2Fg0MsyH6PYRnFjUSV0ZjDl5ayqvLEK0nbv5b5OKdc77AkH6h6cHsGmPayUCe5GNv0v6cqcVBPuqj3PU5l%2FIqWiF2moJfMoiaa31q7n42AG5mIWybE6bTHB4PY0kFhlg2WixwurIsamWZM%2FXthKF6h5WFCTW9BwlfoPTXEPM8b5LKCOGkNNSiU9eCuO24QNVhWELXMr8%2BgLm9HbFahaLf0sUSs7SxYlyqyrxOObh4%2B5tTGNaoX2UWYzxHd%2FCPN9Tr5ZOhNs599PnA75AJyfu%2B8%2Bw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChaeSeoungpyo.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=bq5s3U21YAe34JH%2FVk3N3WriDhqCxcS84CINA%2FBNRwIgm3q1sUcmEiOhldHnegL7rEGw9l51EhEmfbC9jMMlObThQDasFvziltlcb6XDoPTxaDQ6XgfQ4TjiNXgr8w5edtA4JuPQPrRUO8JsS4UbaCKRG1CtCk%2Fj5%2Brh2WUcTWtPOnacn83YMM9Ubx1aS3UP6E9uWEK57OdnAKeltmwNLBW3GkIWVl4I1jxrXq2G2DAe31j7E3mVgEO5W9gZLcmLAek6ScxyEytIsiRDFQIq6emGPSmoB0ZbLJk72Zv0x%2B3m%2FOnlzom7X%2BvTOVvYrUb%2BsjTTpOqOoSOHy%2FJuVdBfsg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChoWonjun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=A6fIa1O3cfHcTW6R37ld3VrIxdyCl73L3gbpVMxbTojb2N%2BUmqw9%2BkdtGPwtBxfIpCUtZYNvPsGSo8CA16dtbijc3ipZDnBpRxneTCH8cHsPoXFN1ZyeSNuZ6pwcLbkelpkn7hTLmIC0EkpQESnPmZsnrSA04X6uNm8qZ7WhsgITFTPytdt2pVW6RNtGNcGkIAG%2F1liD7R%2FTT867BTHpwPOQ0oGnHkYs7ad1izXq%2Fd68GgO5lmCZpWDVM9ts9Edy92uldIEOcw6pjbnoNh3K0roDd3vwObUMKewp7YDJStjrkSAU86DceMdaxkefwZkYMgB2c14VfEGjx0%2FT9OemrA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChoYounjin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=E%2F9xe3G2L1QxFz3LqUl4Y%2FWF2nwasIf7iKLbgF5eYoPh9%2BQdMGL0ObTA2cZeDGrZKE5%2B93oghlJt1QxpDA8jaDg6eH%2FT4pYhuZ2WWds560sPq7CvJIrECN5t%2F%2FIgh4WARLo%2BXRC7oGhcEZiwZGkXzTVCoDNFQEs%2B1vdBH%2Fs3SpbtFrJ%2FkoI0uFsRaufBUl%2FGWI4rpRUqgxS%2B%2FlFxER8nTS1aC4OxJWWt3HgrGRqcStrwQtVDPHbYt4B71hFLXHXI7YCxVH2Rbw8%2FLMCbdIFtJ%2F%2BOt0CpYTTli1M001cBabNt0F%2Bl1K8sJ3lc1M5oo2ND1a5ekkfAgyiz83L7hblueA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChoYuhjung.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=uIfE29ifrlm4YAmVTv11xg2NvnGC0sLbU9llIC%2BU46GUB%2F55UAoxi8R9v8qoaaS2%2FV%2B3yizg5wiwDApNtkosFrMxuodIC9zBiUFYvrr2vf9L4oMUKTUbbEWvonurJwBer7qePtKWmODg0W2JagY4%2FSOxVkPlAEWfvSokimT9SlyaydGHO2PJxfAPSiu8%2FnrVTLKaX1E%2FIqd0zloaduqj%2F%2BJYmWuhCovSXqfy6%2BZYUyBn%2BgQuPkani2O2xEHg8ZJhhmCimSM6JqfJYNgSxTLpM73np3DgQyNQhRro3ShPN9JW80rU5JRWB9yEyuoemB49qhcQmc9sm0GmrhKGRoisfA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChoiJunyong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=CR1MtBfWmkqZvNT%2BBJD8EpNDNbYx8slPH17fx0FKHze2ytaY1ImNaJPY14Ki1KpZI%2FYYhbQ8kfRmbqYTGh%2FVhPWH%2Fz2zGbi4cp%2F%2BSPv%2F0gX8bTdWxXgYJWV5%2F5aNXrp6Q1jC12qUnuH36C9njbTmkkfOI7fCdUJyaR1570jJvW%2BGi9El7XFeUjUn8EEBB1F4sXIQcEpNPe8m%2FKnCrAzICooIqPEDXGKGCe6nxX76uegkCjRI0R%2FR6hhiryxMoK%2Bvn8Wg4pMriDbrZIYZ5VqyAUUhDnSiln%2FCoBPe1SNoAyPsmAbeafZnupA1kQrQCrIPrBSuAUrRPVPfBMZfcJNj2g%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChoiMinki.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=Diogl3q%2BqtyuCCQXV%2B0ga3AoXwvdDIfDcL4hC907E4o1szZxh35Rd2ET08WL03zVs6Nm%2BWYacDsT00E6VEVX3XS8FdiltRFr7PRG5EBWhipC9WrJMx3QWWOm9YPFeUEogJ9VRDTQjWvfkbqNtERgceDWr%2F4I5ALu0eOHMQghXORUaxCoZFtuKcS2JnpLxIeZKCfVH3F1o3jRJGorOR5UmdFh6iQNhqmJqOGWkclxURUK%2Bfvb2mtdaK226DmTqdNuWVVz7BIzlS0omKXoZSp74Zi5zIKCI4bo2tRGcUWLj5ZWWpl%2FHpHq3Nfnj7CnYPhYJKNfZRR%2BSn0Z%2F53rhY33Rg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChoiSeungjin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=Faf4gi9sG74nsEu9oFJj5Wlk2rmcrlIP2w%2BrHJoEKBcUtdx5i6pSKRP0BDswgyyXyaSIk3bdBcsFq%2FaZtYevO4Ue516QL0FVIK85P2zz7a8wPswr%2FJW1PaQWJmXrEudzW5MA9FzVxNO82Tr9VhirZQ5S6%2F%2BG7mP7DqqTOsCfuTvFq9oX3%2Fu4fsztqgUgP2sCTySAWAbMxeDRNqjR8TF3Zg9WXud%2BEKfQytY9N0cKikVNXZ7GJiWkVUC4%2BaVGw23QH1oHACxOWRwH2ytmtd3iWyteVjGL%2Bked3Zp%2Bq%2BjT51RpaRJfrYOAkBoCKHtEuZ%2FKzEH0QkIggoPjLjyLI3SAVA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChoiSoowan.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=rdvvyr4MhITQRIXWb8KusprRsDlKAKh66ym%2F%2FHuxnW%2BtN40VligN7NfWc30XbVYyV12Bq9mQ0bzxwA%2FFa503gbhYLrNBr4J4mtjnAH%2F5eJtyUEmIsD5qce9Ec6aLlUurjfyUa6xbBL%2FLrXhNBp5ZTKfEfrFSpyT4NBGXguxrZ91IhvgUu0UpCONcFjvX4g2QDM1s7ZfKwWGz%2FmFKchxe%2BbOFL5d3EPGoDkGF2t8u8G3vk%2FGkRbK%2FSK52DreGLvG13JNxKsRhmNSWfz8W7ZN673C6CttAfY%2FfhQ712kLdUZCgGHbhW9oCCKb6Amtlu0aJWlowmAVeXejv3%2BroZl%2FBfg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChoiWoosik.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=OC2CJZOm5DGl4EHhLqbSIeE4RI4Thzf2gRQ01DizaHzEES0xrPhk2cgBeoxTdaaRQsDLGhAD2yXXMrYRs0stZmzphk8fy0vpg7FjxAI5nW3gdaOEb%2BFIsLzI2Ptq4ZQjsLWySKTG5yKCv8QlpY0IuIepw6ahzZ9Uejyxd53HdvGljdlMCgg8sq6aVGYLwHXbVOe%2BoJUEW0fuavHoQKdbqxvorZyFSio6%2FHXE6wTYvHZmTfa19YfvAc1PN1Ab2vyXPaOB%2BAbnLAXiBTYyiKQdTaJn0z5IFAFaAk9A2cf2xKQItvTnQal%2B84C6eV5y30DMo%2FTTWX7%2BO%2B%2FGALxPEY8ruA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChungAyun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=LertOwoMigt4%2BbEyuPfEznnoxoaOQGQ%2F4ONTXVWCSaMBX44yBkUsOkn2%2BPN0yofqwI3lYquK5zSO87RvaPRSlcUZTqWKWopBrViszppSlynRP8m1fRQlu3SdP5bHVQGEOHz0wtEzzBgLYmsYbOW0ws4tv%2FLtcEyKbwGamIfnA%2B%2Bh34NFah2hc5fH7LsU1iFdpu5%2Bsm03Ys%2F45Llj3J371Sv8ZoMKqYJGJi%2B8uJC%2B%2F%2FP3CmwK3tU1h8O15QSAmAoEFCa%2FXweD%2FQrTqDbMhWB257zAYKJHzisWWgm%2BTJVs%2FLjuTfQcvSNNmd9XzKQPxT%2BMzsotnPZyCmLHY%2FgbwzfLww%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ChungSewook.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=RYnCrLeVgp7AqcXD4wlsHbOCrlXwVJq4bjH0kJ01hJp%2BnyuZxXIEGE2F2hkIgTb0dUFV1HxO6HQ273YHlmWcExp9CQb%2B9qZQX7OR9%2BXVnoqm2kYZ0o8ck00uY8pGkbTJwp%2FgWrIE2HD69CKlcVpmcnaWx%2BMo6wc20PKmNYPOobwpk26yW13guvuzkKy6AMZhVc7mUl7z3sq8fcV0wg6US%2BI531B8s4mOQjfj%2Fgjvlrt07F2YFbVN%2FswXKDzHVz52EJna1VXVZD1tKH2zdq1%2FLWHtCSCgl%2Fyfza1fJMZKD4prSQux0GZ6zaFz9ZL%2FTzkHpS1w7oRfgOQPfz1qqjxufw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/GuHeesub.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=aOJGW3UoxEK27nuSaMRFnuI2Kwkex813Q7vwkRDOvWDWSYMLxZYGa%2FO4%2BCvF6izZYDZv%2FIVgOSyEBED2MhOS86itWroBq3endblNDL76F%2BiVQfWuVJL0qRnsATN%2FL4dSUsJMh851Xinegjm7j2avy21IC5UFyThD76MJ4quVpvVE4byuE4494fk1D%2BI0v7Hu4wsDC30FLkZt7md1TyppsY9oi6oQca5ekwYEo3gebSRviiZYYxdgKRzhRfVjGO3ypb2DlcYL7dkqtYidY0NLHxM5fnjozYC4V4x%2FFjySZmm58pHMdsSQVwjDmMM8cH3lzjjPxXauV%2Fm7mh4u7bTz5w%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/HaMinu.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=X6Cx1Q7lI0e74CrDKOLeA9I%2B8HLDm70iC79n%2FCisHC6YycqbFH6SGQCtmxxn6Z1O3M16Jjr%2BmngqkIV0ayU0gPnY7nlezJg%2BqJdyODjPhTHiqY549%2FoIZNUMFP0Owh%2BkQrCfRQkW4sYVqrSv4dW%2F68MIWsDvNtGOyuR0DaGZ5w0FtEUAduxKXkvMSFwZu9DZhsov83boUDe5uB14kyh0KJZk8tQyYkbQoVcvA3EOdND36a3DJfdIfFiLLmH72wpXccmgxi4T9KgOBXIpqEshnsG8jZT81yEbNeR4%2BHoyZrlKa60w3HRcMsohmQOv7tk8RBpJPZtoxQ%2BkAyytmUwOlA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/HanHyangryeon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=o%2FPhk740gDY2NiK5zicA8%2B%2FUTRkgofnFhoQ55SDo84FMrHb5iza61mtseT93NsH%2FAHFDXkXSzBIrHOv52pwosQqecXn2ClifHh01hGWKBOXaSup9GGSG1Wte%2F2nlB0XSs9365cCjdzjCtwvOYqUMcy2C%2FuEmcWPc4EDBd%2Bpv0%2BQOZYVKw0ocueuQdSYAW09ev3%2FZzzIyDNQr%2FshrbUU%2FwfKATxhntHLNfqonxLeeBbxQHt%2Fu5Fn26AnB9WwF8MNy2kaZGQ%2BaxFkCNB%2BYHiqnvPYlAmhTRG%2FO%2BfmZlGhb7YUfjL9mGKGOFBfaU4INvWqQTfeAuj1aXaAUnkarx2BJBw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/HanSejin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=ibeJ%2Betpek7AhYB5bnJKI7Ys2dIUj2bqkHSEl0XoTYtzqs55MC%2BOXwcsWv9Uh4kmcs%2BLw10GCMQRp9yU0JSdp8Ohwaw4sEUnuhKMg%2BxyFYqfKyLiIjzhg14h%2B0nWg78jHsoEEHj%2BFAhre%2Bu9qOlBFoQwcKuliitQajnjqmR1jwrEeSIuNn5TBMFjn8BHdaj7wDjnNf2aQ6Q2BeVDxLFDuzqTFdE0QuBYTDLsBHGDlqm8Hjlwlw0AvvjSQps3Bh6zFTbe0zdiHgcRJ0FQgEVSc%2BpQydX15BXJFYwc%2FAM6qF575mgAnLCJkPN7DaFCQooUjq8JWphkyydFakRazaOthg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/HanSol.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=okvRnTsa%2B2Vnl9S8bIr11hhZKUSAoUJt%2FPKBnDMVEqUpnQZj%2BZCGVd3j0lfVQ9FLmNj%2FzBn32HtDhH9jIRfIZg2umRpkAEEu7fU4GA%2Bx01J%2BvX3K4WqwOVZg2JtKI5bIYSCNbgbKgYaXxgBNV%2BpiJINS2cn%2B%2FqwC6ynLK3qxesjn66X95dTcyY%2FqhgVQhUTlJ5X5p5ZYDirEeu3Rb%2FxfBZBcUKD%2BqoEYs%2FNG%2FZkhBrMFYWDJNh%2FarLOATSBLbmOmtrVHpN87p7iQQ%2FWUEA%2BJb71WbmJ95XM6Wkh9%2FX5GI41IMXuO%2BGRvNfvVq8RY%2BvhUZpb9eRKzv9QWaQ8shd9%2Fsg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/HongHyebin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=p8jHbkqeM7FOeRkq2caIGIPBhiqs%2BlmEMPefbsrflAz1zq2pTjPeg0A%2B7TxGVMyBie9gm9qaD8931uzc0kdFyCXobP3i1OTCnB2FAR758lQ6icGTaGDtgBEziAfM1dPlUGa1cutDlCOatJKiJY3QXkTX7AEqEzjuNCCmsJmBdQk%2F9tQz%2FaiQbrrplaleI%2FWjrb%2FO6tnSffIZYRYmNonQOq8AWumu44q6Ro2bSMSt6FZw%2Bj3NDJes96UhmtXpfB6pq3ti5DWq4swUXARbsekmabWCxioBfm%2BmvcuVVUtYyvDgzOe8376pRs8R4inPS6Rxyet51L4kJ3zro6%2F%2FD%2F1ytQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/HwangHeetae.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=WjnhQ%2F7p6SSRTICC5DLhx7vVsEvNLwut3oEd5Gp2PgJdvruNH6CcIKghmISX8SdEN3eL8NuF94UZ0N2g6uSJW1PWd3ySPOSIO%2BmGV1LbX4lcIFiELHedfIElQ7s0uXqwcqZIwSvOy2URzK6%2FYYOuZHJ0%2BiPjzMTDLin2JY058fTssRzp03b9pClDOWEZIqt%2BRixl1fqKPQMk4Nv5Bj1ogCW3FZLaT0qPCsCg0us91GjVeNMOSfNufp3kq42kMYZbJA6rzXXPR3O7P3SvK5kFjIzhOCBBgGAjYOe%2FtA0THBlvCBhRGkYMT8WVMZinwe3oRI6pNrUJae%2FVBwZKuHydBw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/HwangInsun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=loTWoNme6GdcU7cLBDr4jb%2FTRkPH5xM%2FrcrzBZfJfND9F0LTxS64Y98fvNeaYcBL%2FHHF8z5GEkIoOBT9TXbvHEet1zBDQRu1T%2FsgGOiyGvpy1%2BeW0SaUuD7Mzy%2BvlLxUmKUgcmbdEFi5EJctb1NBgs75yxT67hoCuTG1bBHa6kegcsTVjzkwW7v%2B6DWYnU3VOgLTleo5dx5y%2B%2Bwtjqb7f0WYYVLLKZDm5Ynezbx3EKX3XKmgPUqM2EBLW2vbW%2Fyg02ktYlwiTiReSDvtfiSnFsonWDFCIOW%2FOBQ5g32uNL9Yqh8aBz9Um5JnQyk341OQVZQ%2Fgx8k%2B9fqTWkZzujDHQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/HwangJina.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=CHeARPm2m2JNgYf%2BA6q2rGALZSzf2Slqas5OK3C%2FEubrm98h0CVujS%2FXg%2Fl8GphaUwhVOT5D%2FsqD49AFNp0zY0%2BTph%2Fxhs65MnUeuYTOzS%2B5rKNwghZdaRrB9OmsV7c0noQ%2BXKJZORWVpZOyCqwCJ%2F1pm1dwo1NPC8%2FqCIvOfTb4v7wKvFl9ASA32MoQs3FQklauAxi7EtXgyyNPk5rl7jpKPkyLTYQRqScpK8m8eI10drpSQmfSjY1B2yClvh2g%2BKdhZ0g6mLtbVXnvqMMQoYKw5zqg0fzNpYxMPA9%2FtVbGMjIK3RR1Tko%2FtmyrSATiGGbf4eSkTEKXLLGRmYMtaQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/InSubin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=VOHO7hK3dEMNeJQO1%2BjO5wD6%2BaoF0UAloS%2F5SMasb1p301W8sKkDoAzHknHhAt5UYsyAIvpOt3Gwr8JSzDXX2dECJiV5dz0e1x2NaBl4Ojxr%2BSP%2FoP4VQ9UKrGXvLl%2FmBOBWyrWly3t6ayFE7G1SEEZ41G90HVha52DBeTRPgm49kNLWHfX9xphxEVaqpbKRfJhE1UX4PP02CgFOjQpB72xIiWzd1G2viJMCSRq3UFIz2PPs%2F2X1W55geERKMd9pgKrMecSJfIGdaLDqDy%2B8lNTbXUcGsTB6xa8s%2BMXnNNIpNNpUJ9fA88ddLWFq5Geui7I03XdNrKw27TzQH2xgOg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JangBeomseok.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16447017600&Signature=ScT6OJMHdVj45wZkiAR0qUFVJ7piwz%2Bk7zl0T%2B1%2F85UmEs0gHEnN0%2BSRfpYTH6YiHa4WPh%2BasXyhkSn6Y5VqdVM8sQAv3OIA0SxEr9e1QmCBBKM8BJ1O13Vuc1thVNxwN2LdkP76uf4Q99XJzXfVeDUO9fi8D8pVrZ2Y%2FLlnkcf70roy%2Bb%2Bxi02BC2XMO0jPBcjScSwwbRfe8Vfg%2FgjIy1MM%2FmDMSsv%2BNXbkSBsqGasJrrOyqsyg35CngaUrNqMOOf39q%2FejF%2B5AyI67b47yaqnIPl5ANccRQvZWSxmOfDHv%2BIKOjTAAIcwEaZRLbLTt9t2G0hzUB0ezX2QTZUVcFA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JangEunJung.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=AUgwcxbQp6dNaszTzL6zoTnAm%2FE2YACEKWEa7qYPt76hoiWHtMzjYNDvIMp6c1O%2FkKzoFXRZ17mFiz14ywNd8tT0KpYqzID9Al14v5h%2B842Uy%2B6Ptr2dzqrA8yhtU7T4kKj37V0ciTRv%2FUDp3xEErYGlbxAMyzXLtHFZmBS9KHQNRXVJ5i6PDbwcPxrPsdEhrQMlsTXoN36sRUh2e5pdOqcq10xgMfFHLA8%2FpvH5aMOI0pPL3uHedch%2BL6PPtfDrP4CV8VHMdIrtTgw%2BcGtX44LFIhqv1BfrQleelaYtqZWZSnU%2FvtPsOHcnqBWz3p%2FMK9dLLH9EqEirQw%2BqNACY%2FQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JangHayoung.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=ZARqQ5mkMmtpfplCMKs7kIdwx6EfpjGWaDtQKW3HS8ZiPiSfvzEEzKY%2FaGapa7hs2ePVVQFW2ep4sFVplgln8XLH99ORWC1RRpUdsN9c3h37wikcfMwP48guviPGT%2BnRTCJbaEXL4vTOB99y0K0ymjejvNRvwRBJ5pTN%2BQ66INAIXLDy4uleVY6eKZ6Ugl2nc0tDrC8bgusYKb4Gsp5i63GORyJg%2BhNvstF2ztuM%2Bp0wXlHW%2Be9XviSshMAduvDFutzMcjOrEdDU2BbByWTAvXUJgIy3hWS7qTwY5Lfm6JhIldpZFRis3RFBUB0T2Bj%2F7yocr3KIoM87IKcNCRINWg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JangIlgoo.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=gjILFZ66LlNXm3F3oB%2BfEe57CbVzd2NbZlyXhp8s%2B0q%2Fr3IdRqmlvj7fsErgUCcRieo3JXpxyQK9R1EA8R7oFP%2B2ENm1GfIrDaoAnkByxNvfNv0L%2B4dwAqtmSCR6jqvLJmblABb2G%2F%2Bb5GGx8FvZvkiEvTamlUFb0I6epWmwddDxiMPtlUtjJJ49I6o60yKzu%2FlMzoAGjSAJ3lBtSih7Yszz3J09hUOxcsMnQ9jK6gGzT9WV1n%2BohhQn0DUxFyQaFzWYx1NVJZMP56W8Myt%2BeB625oZFOabHM9MhTCAsfuGYwAAUg9C2lL13xfraI41Moo7pwWQINkwbusD8xGEC4w%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JangSeonhui.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=c3vAKVczy%2FO3LlsLngyq69WXpZYj%2BOfzYQvaiADgmovrYR3WCdgH2V5wkl1jVO%2Bgp09scUSyWROAsgEkQOzDpepZLSuTiPqw%2FUWfuNuv25Q3XLj33gXFn0%2B2wYMTuAeFBtCO%2ByzVcbnhzUGmBio1%2FlwsSOGMrjndu7KonyofqrrWPlqEbFk0Q3FbcHwOO%2BxzGFPE6T7V68E%2BIIWwHhvprtUUJdQ5ApdrAdSYXawJrCHj0C0XiW9FpFuzIVjEy%2F04M3M0v9ZjxB5TrpeMzaxu7kr%2FYodXQSsAWysUvHro96XXQVZ%2F0NuVhVPvNMLqoKLK5RQ0PgiAF3hwg0zyKp7yiA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JangSojin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=daa2nEFye9rUGY9puOLq6Y08kJ0L33LeU%2FdDz%2Bbx75TAyaaDMk4JAk7nb1ETQEkg0jqBYzGctd38qa64Sv6JzaYoW1SlOISzmox07gwBG6sPD%2FRGVs3iOhztB6rEu%2BBbYC5D8uguStmNC8ST2DRS8x6UdrWsJs1HHapyO%2FUgHkFWNYLtBoEliYChFuQS2et56cUzAZJDlBunMfDkRw4HjsaC4BHjwcZWmfuKJpKf%2BydSllFRaDyJEKIRCx2248%2BvmTWmePImUP5ibWvydbrU0%2B9SPUxZ65z4QU2v1tFGLwBjqBc%2Bw6iGqTPOB0WELCdyTrMNSqMnAgxU3oov9dtFsQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JeonAreum.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=NrBsxOx9ei5ULD55sj5nTsxd9DES361JfEKBhjBhoQ%2BpQRrFr40yPlBhOo92C1BjpXtiQOkygN32I8b6bCzYsiziY4yrZsOAYx8Cazh45uvyFyPUjn%2FFLHt%2BwOPBqKxa2KAKENV1ONgq%2Ba3cugfkNup%2FUYOkP%2BfqF7%2FHCfM27ugQVjc7JXh6s0g2ew%2F5X%2B9bwtgBs8ocl71l7GBYf2xcvVay7p1GZnbL6hr9xsKHONKUEJx9KABJWSqLk5EHSFUcCbhJwH26q%2BI61jGYdEXHsgPEVfml9CNXkv3OuAMqrsZbP2PlKGX7tm1iPbY6HemgqgpmIcu4QPXUtrAO7e9fuQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JeonJinhee.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=dkBZr6tOUAgD76J7JmHQVhyVXRqlAHRpmj9bilvSBTGefzRaCB4Eb1j95fjnYfwiR8DUuVFVp%2B9hsJXqq8afxESXvVVBnoixfmkr2L9Ffz0Y2fJwybFOsZEsidf26WcGNmu%2BgAV3hdy5yo91JANA07QYGpguY%2BQSQsURi7LOSWnecF%2F%2BYSIbj%2FTv36Vn0HodH2sytZaG5aelkAdPkwCbUyFAp9W7%2FN3MDCm2UUgt2z%2BfgsiyRECfw5n7Kamkc6Afrp30nCf3%2BBh5QhKqMGFvxwfqk2m%2Bed70is45%2Ful6X3%2Fw6AlPcO9VZcMrKPW9RL02CcynRIko85M0h8s6Oh%2Bl1A%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JeonSeoyoung.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=k4pbV%2FL%2Brf3Qb16RjwQHutK%2FARyqTk9gFwjR%2BZk5G0%2B5UhW%2FKMn%2B3hoN7gtc9BPdX9S2LL8Rsslwc5TNmif%2FDOjQ23h6BKZK%2BS%2Fgepak8ChN0XYH1veqgE5Ib74GZbZgnqBF6iqjQz%2FZ9uMlioGt4qmXb0HEdAuKjhRi96ITWpI6g%2FMIaJH5xEo3AokSZFRsZLPJDGM2HQ1Zjbt%2BbD3ISie8YuO%2BjPmiw9vJwFYHVPRQuB8%2B5KCgMvh8yVq8%2F82xJ0MEFFioMzOMw0KTgJKLcWnBdZ0Azwv95eunuPO%2FcwRGJ8dIXsvGr9ZWwNrXvd52whh1hpNQvTgILQ1cwgbx8g%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JeonSuhong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=sMD35FMKFLttfjGRoBFU8cjV5qQ9CCnG3URDRJ22nPg2VBETg2mab0Y0O%2F2osPN2Ict1aDZegzVAmgY2jrDJThvvppGJEK2Py7ddQ9nURVX5E3LRXxb1ltz3MDaUSkTAh9Vj5JS22gBpSe7%2FM%2FeC%2F74R8tQSRXM%2BjAdPnfnfyO8Gp7gOS7h3fGJs7mASqb19%2BV3kayIYVRQ5v4RZX8Sv%2FXAl9lY84qzEpVzVj%2FMs2NC1mSC4vVYndxhWzNBb%2B2YQV5TXB5MroVs73N9gz90d%2FA%2FvogGit4TuLcMUoAl2lDRtjWrBgqtmM7lsDRklCv5S7X3W0TcpGpOF3Q%2B9qydaPA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JeongDaekyo.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=HV4ZW5MIWBzgWIlPb2%2F74W1uyya1scHhOnIp1GIeDyjF3mcUypiR6feaPSrt7ti5DFgjUSj6qImHAOx3%2F7ap%2FLEHv5w1EUF%2FnMv6THi%2BUW0CqCUj15Zj%2FwpeP9nitaL2ILRENZQcNvvRgVA78Lqw0m%2BoQ3IYJPzj1JtzFzigm%2B8yuVx1SdCLUzSFNxRvPqZD3G5BPdN%2F1CmkMdv3Je7eAx4F1GXaAmKyrBUnCELKyFE1BvzIuoEe9xn83G7w80biaQfhfmCRC1rslGptwO3uxAZkhlZ1jG6Dg0gqZox4ZMXjRKzgIKx3HjbVdsL3bYQj0o%2FEne6HP0ZxJSWqXG8WUg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JeongHyeonjeong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=qPKL5PB3%2B0OFNfTrATPNDULH0d45Alrk19e9lfUP%2F4spKZEcCAkR21xFQ4dcPSl1GrajOEvxvCCBRlG8vlnD%2BUMPTJBiHR4efxjrQqkHNUPcTgdHf5Z8U6R4lyjZUqeQoWLt6kBg84AbMjHMDttNWG5TYaeYD2DQ6%2FOimbIC2VzmJufrDuMBpq86ASFVwdOlAJnWo9Hl9H3eU9shrcB82fkAvQB%2FJuo7p2ycGMqao5PjYZKCZeO%2FVOYhKBUvaapivxF2Z0scuCfvdbDueusZ%2BEs0V3yiBhfdJXYnpKRLZ1MmIggYf1N1Boc5qBTOMZEaPFPif3cilb1G8soI9xAz2w%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JisueKim.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=XCrQmmYj57lzni5KD17NPBXpQJbplnwJ%2BdHmadGAYsRefSNvPpqGqJi4alVnYaEpSRBPt%2F17x3USwnGJV6NqHnyFSav1kW%2FPjbW9qbqw%2BHvhvS0F6NNFfPAsYpJBoL%2BDnMHBywoMYsTK6W6pWJHkqNnxrKq9yvZAN7VDDO2piBkC51%2F3B1zSH7IOlOxDa%2F06pn5%2FEWzt0fnPKKW211eJyQLFlhjZrxYF%2FDChnDyZZWySIzSV9HI2MGpaQ1tE0jbGO01auybUB4WxIqsvFIkjElvI8iXT1xYZVDNWA2R3dk8umE7MHkQSxF74Hwopp%2BHS%2FbKy48Rp1%2Fqv5To58bO8LQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JungHajin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=AdZ3htVkHXJ%2BGISONTt0WIBbV1hMvnsvcTx4UYABXUs3FW7dVhfm%2FEYCL420KmHt55BXFDJRZPhRyVhPdAO8HC1fIsQabekxPnrg3sIuCs2Vpf%2FUxIExeyeVx83ETPmW31FG97qMYGyj6FUS0WoMnrsvHO02kGAvFyJCQQiICG4sk4Xowlcwk%2BranHzjmzmVEHITuGy2q4%2FWFhHsrNwwgz39vwXhhAHBhP8yb8rMu%2Bb12tGZ%2Bx4XXoQZmv3S3ba9Vr9pc2o%2FRNRjVdpSH97Mu%2B9MtS8tZLVJ%2BuWSb8WsttlNzUMfftPIOqRmhxx%2BPao4HQ%2BYmntk81XbG3Ohsk1JpA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JungMinji.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=H%2FPlwP1bnyw0vf%2Fhhu%2FfRuQT9ZOWPWLDM4Exl%2BIYyfmU%2BynXZssDCHbt5cuZmRhTeZ7Z6gB8rpXbzC7o0tkqFNrxy7jtoKjANc8%2BA7vwctiB3Zy78LRUvxwoT%2B0TQ7CqPRR3dNlsHnI4UAWxzOs1W58xaOX10W9%2FmWHHkViURXvRxC2xe1t%2FmgLu6XCSL4A67QARYVduUj4sefbK8Lb8ua1BOGPEfLCGvVOG1wjV0%2Bd51HuFKOVqB%2FSjxWMXko9jc0E6dmFKMR4ScJSuMRNM5aWYIG4A%2Fy6FdVeiZ0%2FOmzWce5tpdBrnP86%2Bw3egrGaVxG6jEOlsAMYrjMWlDwlF3Q%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JungMinjung.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=C5uC%2F8s%2BQQq%2B2mutwepb0d0IL5L0X%2FK%2Fpt3PE0kn7KRV4d8evlRsFuW9mmUV%2FdPqlO3v%2FNLWWyJqhwQTYfpPOS1NqfVzAyj7HAA3wvNGu63kOrD4ttqnbu6eggI8YzJlXZhp%2FT1fPH4aolt%2Fqavyzs3R6pqpNDiS12hCXKR25Gh6XpVGtKJ4qJMqUOCH%2FLSYphAtIg5bdWA9YHfaTFbNKZnhz0p%2F32UxkNKJvK1ewuIXNY0dVv%2BEeZxaZ%2FFIzvJWN9EG2bO4m0fF7ptE3fqlbpLNQ%2B%2BgnJvhJszwyKHPx6s1XlvolN5%2BlqeUOy58D09k1yKo10WPrwmKsMDWvCMNMA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JungSujin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=b%2FN%2FWcMWPesXAU%2BOAWLUEfxN2HFa1RyEJ%2B0VJUnu2jQLBlgTrAmzwhnqQn7c9J835r5ApzxgDvA0YUrYRHLPsRi0QSGUMLPbrILov1pnnt9xvxVlKB%2BYAtzAhB9HBFffoHLy9qY%2FqJfmK0urWbGg0Kl6C5enXA%2BoJMbhSPpGokbBqEEFhex73ctv3WZtwoaqmFZjPJfKfA2IYTRdYvLWfH9jnA31NPJU03c7bwvY7Rrd8Mp4SM53k1wGKwfjjgXsqjUwFECUNJUKSddbn9VShZz9VTs6MsM%2FTq3dCqjXrX9nd9ZfuhsnvvUd9DZAnz7TLxwreSR1YbtJUHDffnvI7Q%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/JungSunghwa.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=W7wof%2BHwtozr1bw2FDVcnQ9Rnpmn6wjjOpLAeJ73lCJo5yh3wHYVypoepBHKKuvOvqd%2Fjpqg021%2F0WKlX4ewcVxiPrSz9SFHtec%2BbTP2nh8gkZ3z9EttmvvDGp3aTqR6GHdok5Sne8GZlfOW2tY%2Ffe1N2Ar1Y1ceVL20FBGJteb3TOwRYJeQzREBHD4xL8K%2BCLVnS8FPhvuAArKF52vG00Dw%2Bj2I5WD2UCcEmhamF%2Fdf9PzeLH9r8CASSOXjAAl%2FVj2PAedxSS%2B2KOQlH7v%2BupUrK4IqPL4PYOumFmDePtpTS2qZCj9m3MQC0tvNc8k8jUIEUIT%2BQXXZNgIuaySSew%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KangBumin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=p%2Fy5RubT5CKxJ6eSJLTbBL%2FlRjXjxkIgWDGW31XxWmimgcmEg9NXBgEleYJtNGbtdgZSa2Ty7ASvvc5OpeNeNQIIH7vz9vzGOFbxIN8%2FL3q0KwkKZhfLxQTKi4e8t%2BXDkWI03IJ%2B1VlHo6ondfZlCga%2BaaGNvKSaKAHPcHw4%2FDXpu8KlaHgC3aV%2BHXUSAYO7S%2FcWqEo9ywgsQ7EMq9hxauyZmUaDKLFDFZPo3%2F46i5tZHudXGQgHcmfGvp8puTbEMWuNP9H8uUxcuBGU%2BYE63%2FmkJS1e6wSvtsKrO8uAEhPqQ6UMxvLBt9ye7CHvXCzt4T9%2BMxG2OSSEVyTcxVrABw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KangDongho.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=h4CJSUKMqandMVkmTQQPqKHiQqb7XVMNR9RSDmMZA7CEXk9l0qPvgXbMf2TEC3VApTMzdcY5Jkyg6Jt%2BfeUfVNwlcmgrpk1iNmSDEcfFbkXJAvGGnITK6P1yhK1L5kgW3jg9UnO%2Bh7g2Pze7EHZAM4Tk7XBzY%2BRNDe1CUotKrDh%2FLXZSiaV5%2BuG0Qn4wlgaTdGXRiI9lNHU%2B%2FV0TGKI5R8BO%2BdW2XfKpfi%2FVsDsZ%2Buc4ec9Bs2fZ7utZUVy1CEOaC%2Fh6fj7BWRl98ll1kZXhNvpQjOZ9DLLI%2F%2BssM10HRh6izX%2BOog00TzCm3x5ZuNDPHuDZXgNOkoqQI2v%2FXAxgjQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimDeokHyeon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=tCpPKAIPZceR%2BA7EXzg%2F9OZ%2F6Dvd3QXWfo0DxFJLSVVN66dT5qsm0luxi2j2UyH1oJf4LCFM27yQ83DL3hDvs1P68PKPI7oNFpp78jrSU9hVl18fRoI8Y5KHzUxVH%2Bqlo91PFop2P16ceqF9Nwl84cNnEH1Kv3LfxOgTGWu6LAA7V1zBjINKuCU7%2Bdb%2FXKppSCZHM9IZsnSZUSKNH1dHzPPOlJ%2BVW%2FW551OuoccozYpcySJOIxMLJ9zVQZsCsJ0HrLn6y5YpySC3WCDWmqQqPDAoWeFDeCanILy0tUkep6CtRHd6bLTAEcJZsDRXtSwJGS5C67CD0eqH66AkJypCww%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimDongwook.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=ODQzPDenzOlFpUy60%2Ba0i6ENswYG8%2FkiBV%2FZgQUJQa7OfHqi8z4Mxu35ZTWXD%2BbW69%2FaW%2Bk9Br1aNShLd5qmNeYpij9%2Bxr4GvI%2FALadAjgdS7d3GowphJ84KuV9CBomXVnfB4WajCz4o%2FyQhQNESyp%2F%2BZydcM37q%2BKFkW9AmjAF9Epu5NHzq81WYdoQiyOVTQBzMhK%2BoRT%2Fx8GAaVNJ%2Fzf6jvJ9jNDVu3XgEXir0yginYd3opNa1VVUvjqnGoTs5LNe%2B4CdeVMtLg81t8TCZ5ymJpocIrOGOnd880EGl0fcwnbyJC%2Bm3EbnOL4omYmJ6N8LiakjJaCwOW8uinoDFRw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimEeseul.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=AD0UlcCMelE1cqfhadV72ahlpR7K8lIseK2BuuDhcxDBDzm9WRDVI5DgzAf2mnEK3ot6IeKTFbrkFFW%2BPthDKSyRiiSH%2FPObCrK2b%2BTi%2BsIk38eil%2BzgWI458UmsgcjdhCYOEZbIYIXHoZEiYHvmhPAPzsBM1Be5%2FzKEAOv2PiYwAG20LJWEBQKHX1m72df8s1f3zC10VHLBannGJOzWw%2FLcl2RbV4BXlsPSxlgumd%2BS6yNaN39bhfTJQGtsURLZRXPPiOXleqeCMv0c5cxAULf11%2BeVa3nzzfiapj%2FNkcNTXfjYrzSYztj2Fbm7nWmMxO4Lh%2F5pQIBZuiUDwXvZ1A%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimEunwoo.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=NnzRWEoQCH9XmtnrW8aG9lg%2FHcwGc1TEQzTfGJtNRhMfi3S3t%2BdgEkI2oP39dAhufv9qLMmjZeAtzG6WDwmFqnB8EosETX5d2gIZw9hSKddLz2C%2F82EhG%2BAPBJrY%2FaK%2FPbiqKfeAnpxKb31WA1p1HNn%2BE%2B9XrzA2Jt1HdxbA8IQifqhP4Kl%2BxB58sKBE74oZn9JxuERiDcoKP9q5teU0TQQ7M5dPLlXbPiWkBOmwyWWBhrtWlOxYMiDdrlEMmnitnutnx538uRUKtHuu%2B45FewG6LMuDOunbO3V9%2FNSHL1lLJvXffwNVDoKKhCm9YTcplZxwr2lWS%2BtAS4RuWxy8YQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimHajung.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=WW2aPfk2W53WEKEFnkZ5xBbECHqeDFPLBrpXw%2Bbcuv7jHQVKYwQ3aFtiHfNZKMCsC9qPpntu2rgjbQHmwDuV62nd28TY1W%2FVgLMwzuWOi8sWj3L8AfW3QknzPxjYjj9V5vkashpPsqYwAh7MDbv5D0XqXF922cji%2F2cDE5xxVyuA0WCi1Nr95FJaxUOq3G2XgVJCd9wTJf9ra9Lb3FGtyQ51Wd1%2B%2B90LGy2k4x19lc8qQxT0dvNQr3NErg5Vk9IfrmY6IiRV6T5Y1z4p77oFvM7kVw9rxcDkcZj1jV5cdeLTBhqmVS3InaGG8BOXIIZp%2BnknU%2Bv7F9Sy2u0uKLXfzg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimHanna.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=fFPkOq86S5y%2FdoJPCXoo%2BLizHC%2FFm%2FGVhNZXpolJh8F4JR6Wn6ioobcnPFOeW6To4B8OM8W74BA1kminICl%2Bg5gox7rUlhpiSR4GDotNsW8nNCk7mEG3Lk%2F9e%2BbhymSoS4H2IrK8NWU5VVkJfpaw42L5lnduIb7jbxz%2BNOFOlDJPMtWwN1QXIg%2FQzTb%2FqAu7cWUkqrtxKNY7%2F3EYf0jHFOPydWbN9T9a%2BtHVtrHmWu7rW9uDfvJwD0fqyf2ilEO7%2BV6z6jku7DY1gZMBIOYDkoLqYfuamlSSDqJn42QDlGyXzRbuaJbpJWkTK8WAUpGrRkLj4z%2B1hWzCYar%2BNLSGhw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimHyogyeong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=X7bJX9UjlMR8EAfxW9ysNKlEpoUeGt%2BWUUl2olR0Bnto8mmnuFusgIGERPwGQpUSo%2FftL1c6aIznqIxO%2B2zfrnVLVrXf22S9zeg86flTmuunApgyfXBO%2FTgy5Vy8a5FUdjUQMNWDttCPYDeOsDEOmbzHzmEBxn0Q3vODZkJyp2ufeBZ3F5s2zu2rOYD8PIHfmc1tkYgcQSMMMae3oZ6U0bulfiz6OptwXLr43xnCJsgSNsM%2FrWB6n2UiNaPv8kWe8tu9zREfHB6KoXoXJWkfa0o%2BPwqzyq0M%2FJXOjUTIMh%2BgnKBA9h1gjhSsoZfnaDgQNvqBF1OkZidur13fcfVLSw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimInhwan.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=QfR0Kfu68vXfu7hSDtPD5scdDV1cQj8j%2Bsc32fePOJ7wQXgM%2BckU6mKfsW0rhclTxhVkjzYAHAlLhvYLraTKNJag2Ys%2FepYEooPB9ylfMmoND0S0zIF0axtFCXRfmx%2FCbwMSbxJSMFEQPqo%2F%2Fg9TBrCKPf9H1pN4eNvUEdKuHIJ0W4ablfvdbqt3rmSMdmiu31gbK1KL2sO%2FtI60Hzlmy0u8keqHDnqSJrfA3A2yI8LTgpQ8Wk8JZA%2FoL3HyVTuUXSJEAHiGwv2x7KjLJSh5C2kyX4QpMG9es7mrqiP7%2Bh8ETHMn568oMUSnuq0b1B1zKDT11hA3b%2BbSH4zIRQdREg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimJieun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=QzDU%2B%2BCIwZfZ7W0uJl17rd9EWano%2Bb4rB3ztVxtGic8QmWQMnBHHmlUhB8WFAMkFqMcrfLPzl4%2FwefJwS6e9SX20I%2BcvjFTy0Be%2BZXzXNC5n5T5swJ06k1pYTYHgp7lGWzBifc91V3CqUWbOyuGgsFz3vQ6pEEfIcJVYI5u8ANvzI%2B1KLVPPMZ4CFwCk9w69K2YPlpK5E9JV957XV3V0aSZhdARricogN2faWLZtPHBJypMIf6bk%2FttYDp6S9vlzVxxwyYlSzQEEnxcbqsDoxYZLMSmEKGRi62Gp1I0m3gavGnZLkgAXwnF%2BGcEhhFKZS%2BHDD1T5fjMqrJiBY7d5nA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimJihyeon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=n2Kr42W4DSpdQdt%2BqddzJMVFFZJ9D%2BjzsjGxfC%2Fdgz3tCF6uAB79lIs%2BQfLmxtsCpSnKwrn4lmF80ghYozIE2PO4RQus8Ns%2Bh3isa%2BfwIo50LPGwH3U9xs6y%2FYlfLpmeBMb2YJTbzKb0NAk6TnBZv03w7vLF2bH3pjTI32KXQckSNxV9bS3F3kCYldXQsuYi4rPLXcYoVkRrfrcJ0FM8iaIyzPtrlgHDPi4Hk0U5UcDJCDSemoPNMGMNI3HVXr24OvdXGo2f%2BdAk8jCEt2LuNuSogMmOj1jj3eysuOcxMMvOz9Rkkt%2B1iB%2FxmorcFXLK74VoXWB7HfOxsf8E6plX3Q%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimJungsun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=fhcScCji2CijDpHbzxRz%2FdQrTQ4CBiH9SA9WP%2FzcbV58i%2Fv1ewESGhQzBoE%2BH%2BBvaPqrrZyak%2BGTs24KLHE5%2Ff0n1C%2F16hjZ%2BGI1iB8V6z44cGQDEqObF%2FpTgHv0A4KGe0ZrmAyTFx%2FSH%2BIGQdQxn%2FWiNmDpSpGFDYmMIU%2FGGXLWgVlYxAqWUUHBqRA%2FmXWBlds1dTAcHpVPTRL0F%2FmKKnWf9L7wVA%2F3%2BAmLMCIn%2BbVraHkFvOXpTDYr8I1ctu9AiLJMnWj0sonC60ItXz32A7XxV3wXy4xugR4QZsPssiK3i7wDAvDoZMNMcBEIm3xlOd6XbkQbvWh8XD7VeAJPGQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimJungyu.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=GqZQwzajV5dVcVHskv%2FFkce%2BRMIk6bo%2FRf3Tl%2BLmGgdA01uXNONF8BWN37uFiYObBwQIpjuZkBtlEaJjo7nqOBfh3WBCiXixruozsBhytitObO5v2aIrRmPIbbZgCT76anjU4LqxXyVxd6hcNeotAOGf0ep7UtqEqHB1xDuNUF8Crq1asdCjdsqyQPiwL4CIENolBEe5K71HniGYHgkO0hiZj03iANzaXoCDe5rrfGOOaF9ysD0ZJNotmsG52naIIJfyqwiEko10PlShH9VUjZReyummBxFhNjz11Bs7iwdodFvtLlDk26cJOu9EX1C5O%2Fqn%2FN577BzcXhvG3AJG%2BA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimMina.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=KY74%2B%2FhjusFiybnEiFkHEQqua2QMM%2FtNG%2FfduiojfL43GYlPWrCsvbbeSK95iji1p%2Bw1zW2JGmr8dG3ylaKPCzVsT0o6N91xGyMpF5K7HvAG0P0Q0zwUSFa%2FsHtIEjg4KxiAeYf5aPdxq9p1fKkRTykwOczWyzNLhUTPNmsk8Yh%2FhE3cnHoG9FQQdUQTohxRjtGkz0BPiTJae7X7ndD8uiZa5Ob48iv6TBc480l0TA1LUH%2F8F7roHz12AF7M3Bsgw8oKaN8m%2BDyfkRl9kqP3OTZYlbzrHlK32jaAvSAz3Tnr%2BcJ%2B27C%2B6s99DQtJ5xwZKIB41Ju4Ud%2F8emYx13vg%2Fw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimMinjoong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=YZhb6csf%2B1QV7NOFC8R761ckAVpOjv4M%2BzDO5XogcPKDpKAW%2BPyw%2BtYeaiDGGMX5biZdN0db6XswkivoTIfCOFJ4jEtb3Ye0mhWr5IZTJcHTnaQqur%2FGyQLWt2wWasTTFu%2BXKZokXQENev%2BD%2Bl0xhXZozynixYPaar87VCBmcJmFy6yZyZA9fKed4zjQrKXO%2B04Q5WNQQkD8CAv3IuqMRLcsXHzW647PSm%2Bgk77xZt%2BEnxnFbP24jqRPNYS2UB9lneDITa22TlNHycxl6eGo7xapUnfbDCZmI2r%2FajAfp3S5nTUjTYheTeqkFI%2FTH%2Fr0QD4NK8kflUvtUWEROdQAIg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimNamkyun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=lUmvodpyPmh019rCNO2sLCRKO3VDmuqjY4xEUXux%2BV9qfTjYKodjKjgneTud85CMzgIamX4N9hqq%2F2p3VAYtL42zpF%2FAB30ZnPayxfzhra0mqujNxNhQrhec84n2fvUr86YNeH5VWaQfH%2Fk0qkVtnwBmYglDfx96Muhncg9T0d0Xmb7zsjjGTa7m2slcp2ihUQ0%2FIHDZ6FEz05nltzIji2PwF1y4cZGBVhUrUWLb55hsc1G%2FIWoMnVw%2ByM4dp1H9pU8CA8v4Xn5KhAh40Eb9LXbj0AIjK%2BkEy9sIXhgJea6%2BYcJ7Cz0pEirISDWDV22R7KWqux40advxxppUpMnUqg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimNuri.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=NDzC2O9TOJ%2BsRipbLwPEp3US4UGKHe%2BDYqgLOtXPYUnIPiQ%2B%2B3c8pWlvum5DYJylIbXWjb5KH3ZfXrTLkYNubw3KSESfmYBQifY3j8lCjtyfCqXObHe3wVUTZq373IuKHxE9rjg1mdggWdxI6EquQ13ee5kbQDuhNUaJMvaORjC%2FT37SBNJUcQymyWb07LQs6Hv1r88%2FpYPcNq9zocxsHc5f7D4RaJQz%2BrHc64kwV3is3SMnTkAjrdRDe6BumucHyGBgVYf%2B%2FajO%2BrYQcRaAfdCEb5vsLvQ5bG5aE%2BDQDbAch69q%2BYLyKaz%2Bnv3fb7YN4AW5PtmECmrFE5ZzvmzG1w%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimSohie.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=HLqJ8RQMnpyz2po3dpM4RymvsmXjT5Pww3M00gNVexzIhSqYvADOknVscMQtTDcrOhcUAJAUMgeoZHB8ERoL4CWwCr6tzVk3C74RelURvrOPAGmEfpghEXDACx%2BB3B6XlznWBkjV8x7wuaAz3EvUu1Llq57VmAsAaNIda67OqUNYseBRP0hKlK36kKfuf0d%2F4cDVsNYCzwkEgYzxgzgCXmhA3a0Lmq4tYXkccwdFLuIJ7%2B3veRoExm8jCHo%2FKR%2BJsEXjwAHrVsNqWqem7StBKDHoBp2ysZlh%2FosYOVdk7GBX9H5r6NLjhE96sqYrqd7KTlHQqeY6rRrhoGIJFi73Yg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimSuhyun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=UjQeEfHIDxZymHxXC4tt7ZodKRBx0rZEopFMRouovWrwCymexuZXKCbBt4d64LN2LygaGV6TtPhaYNeL9riLQ19bFjOPsZwM%2FfMWGutPFYP8AOlA2XwH6zEZ8qFBYB7Y7YnMSycyMgi9KhkcIZ3ybB8O1Sg6jNWlaN3IARjh3eN1M4nhNnwLMXAYTcKH7rRj%2F0jHEx4gmEKIC0Tbv%2BazngS8wuO8BwravDgbMWml4FO3FvN4XJMG%2B9dxk6N2RhWKo9j7fY0nEs60TB8yIIahD2JW0bvs0eBMvpsYjXZ5v91S63RcJCJlYwH6fx18ad76HBn9Osu9HTgbJRJeUqRkBQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimSuyeon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=PNXzXf8FVZXwWyAXz7YZbW1CBGQCUZStEtiljK0Pd%2FZ7nJF%2FWQ2GW4gT3qgw2xh5bn1i0F53yW3Pk%2Fpbmrzb3uDrCA6j4oBEbLvBLwoPaE8BpwLlwUqxlpEo9cdm4QKePBUAWhqZ1MG3TDW9Bc7JJsGKwX9hZXtePCWkqTSo9kdmjBzTLPi3%2BiWEt%2FU2QJ1txwmI8HR26isETYUKLfXYQJYZ2EOOOLt4ZzBHAPt6cSe8235%2BWJ3qpi%2F48EG2YmhTJw4rKAaKgQ0EOFvaiojxha%2BcnU5i2TCpXcZZ9iFciviAZ4N5PnnSet6yb9rX8Z4ATWP6LEHMWWwk8NfWDKCbZQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KimWoosuk.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=edH4IPdGpMdPuj0ld5jhctddOrGf0ZBtEUNt5hcwAOPShbyuOImXr237jm070upOZOr%2Fx8Nu0O1NjDTrpJyTmFY3QQE0qE8HVu%2Fq6E92gt3zkSxnAITBXK1YigC4UKSxygbYz6zbDHvmMoiGrUSB%2BLPnGZ2%2Fd%2FqNt2GyMC2TBkUFGw54qxnMDR8uGDvXBqF4MvvU6L9CotYH%2BmlOFP89eORU99rroBJT7d9NIm6Y7K1kaNeOMbMwJR61YB2yyquUMvWujUmn7EjuXWNo5%2FJSZ%2BV13KQZmU%2Fttdwg5Qdfh2b2GxDarb9U8sMrsEhFHnvxZaRwsUq3sPSTLwVf9qsOPA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/KwonSoyeon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=mw01aAA%2FIVdjYKG2srWMT9qHQogL7ICh%2BaALDKwH%2FxfKFYnWUlGBp66JnyfSlsde1mVkzduu4Ib2MINe8TESGNSAQxcV4XkumuP9%2BaO14ibAzZYeoUfmRFfCvKOx3ph9cSsVfsP2iA3FzSmvlRfKUuh6KCsMTK3hIUKZJC0qJPaTsvjUkWBsarDW62wWwZ64ew93g62%2BauHcqYazP7h6d3Pc1wJmqT8jgOigOVYvxGW4gNzGOeCmg889sJWJze2RUWOjeRi2%2FRIegUyQrYFnkFdsqiqUhsIfMCQ032If37HFTuEbw93tw9Etei7lVipWxPCQvJ40TCax7QnRHz%2BKiA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeAeri.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=XkgjD1m0B5nGip73BE4%2F2wuKdhg%2FtumUSYJImpaZLl3iXkon2cJ8FPCpfZOBN3AewUa6gCQJUClVPOmzbt%2F%2FfHvcLobukU54L1lfddOmh2l5nlXa2dvcgBz%2BAduMvliQCGtGcM%2FI7yebtxY1vtVCSd3rxKzoMAktbUjVlTCoIm2T7DjV7y599lfUpgA5N5ivhmullf6dUitriGNxyLCUdybpQ0uTikPOM53uPKjCgOgXKdhsk0Y6LR37ZaudkinIJvqT3wqDBXnzp77szRBqZsRSwKQbX%2BHegZwneIPu3ctqlsIO12isstEOhexNI6mE0p%2Fzcn7Sz7pxxXaU%2F4kAzQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeDahye.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=rRNh94TYoHHpjArv3CR%2BZH3X43%2B%2FjBITkV1PmIl2sEmUNlL846xP4xSWh1ciAVuQr%2FpJKhYoHlsfSBD%2Bq6T%2FEpcnHnLST3quuxJ83TeQPB%2Bh54HWMiAJ574VVbshTnxH%2FT9OFSgLv%2BKLpxL3hGxIfiGFsozLiwkJhEMLboJq%2BFFXpEkwFOBGefz1SN2QqPFChtAQIvMjAC61T%2FJRu4B%2BU7cPH1GY98CnJOq3PJ%2BW%2BnmYSAEAkxIllNXng0VcWtQqDVAuIza7kS0CcO0q2%2BNuCtG%2Fqf05uNeO%2BFXlK34Vzqu3MVkoFSNBkKaPYwXWBr1Nv2Elyez3cqXS56pMhgt91g%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeEuntaeg.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=craRPoE28YPue%2BIH52SRSVGGqeyXH4lsP3j1sH1vSeFRSVFR9FFNROOTNj1vW9afuXGG9nC0GNNo52vwrI51JpOiPwgmUKmvDdIOyVCtU07YUZIFPDb5P7V89IwWqeswRaIaI8E4u%2BOkuuk9b%2BhHePWbT%2B3z3pkbzecXBAZnZ7lxWdy0HP6Imnl7r6GllSsW9LDWjQFAxMskLwEscxRi91XDPlRn4ctOPX8C0UInujFVKohsXcgLSa7E74FYXPdl0K6FWxaIMN12AlqyPVnXtRto0p%2BbbN4D1ru1LPf%2B%2BAkyrhOvQueDhgZByEQHGRnXrQwena3XTxJ3dNrzX8ns3A%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeJinho.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=EOeg0VJXT81e0YwpcpULpPgfo0nQU6t2RhF24ZGe67UglOZIS32qOo0LV2A1UHxuupYhCDMXQuj7%2FEKEq7iJRdL23mIKV3K0Cvo6kyiFHUj4C2SnmK90PiH1o0wxYdKjB62MXZLMiacexYwunbPiBA1YSE9ujAPWPg9iGz8uH2ZUEThQ5344tDduRZUiLuMI8ScOpx%2BaEI26tiRlYJmylucbwfuKLAxsdjnofqSqZVLuNkwTbjN942JGNnbiqUJtue5AJvJWqi1Kb7M4AZqTVCT90t4oWXRTxAeMCDksxuGVMgdv3xWXSyK%2Bq1dCvTD8iyHvmkOSKjEdWx8GkrG4Fw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeJongmin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=WbFr7HslPL4%2FHYATN%2Fz11%2Fvk4lbTo8G3eoqmR5xsj2WKEyCTo2m1CRt3sd4zIFfkT2ikzINKC52e84otxzoyS%2FPpbLjLSj2u9t%2FQki3CTKztA20HlAdW41HxUCWTa17f7UngR2VLomtKeTRlJq8EaAlXddkUfrGPKj48O6TN%2FBs%2Fc%2BnXN4HhOQmcDjT8hVl%2BjxKZzwd01ztHa9Hd7GAln6z0hi8uPCA9HbbHnE4hv14W1eYvCJxIxkFHEq0ABRsu94RTYA07xE3EIjJU%2BcO6%2B4viLv1t775z9e2FO2hRvSB7m0peiBBhDUhq%2B4xCHUGlEOjSxti4D%2FbqzVNrbm1iKA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeJungki.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=VOK9b%2FTP5flwPGEZSwjrCnuJ3LAI7LHN65FZwUaUsEg%2Fwj%2F2qPZX%2FIp%2BYuPW9nX8f9Jfp9xLZ52LpQhURSOkYurPfY72DWMIkPQcIuhgqm%2FPTpHc%2B%2BdWbu3Yr6Cy1zjA6e0wYdse0t0fHt23ZI6KVk3cqUYOLMBXPUOP7n%2BDf417pe8WOu7sNGPBsw7OAoM5pwgIeccuHWKQnwNYq3IT6sJW0e6G0MinfYTyex7U3dj89i5Mt58oHZlT525%2BUW5w%2FwtoLXc9DID%2FG5Y%2FsvRnQrTdMI7moVPe3GiNiZxDvZfMXYwxcC8h%2FDUkWzVTJ2KHpGBs4qSKr19DOyZk22mx0Q%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeKihoon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=BbBTf2lx3KTxHIUIlUXsBPFC36DXyAb5hHbC6yb1Ugzf1AWOwnMzUKmGF9tlQiwFSfzQWAkBgg%2BDceKYSsFTERhMYZLlwxQyIPnH9tdvecB%2BwExCuNlUky4Ss%2F9Tqe0KKI28Q8D9IX%2FsRCWyRpUAhj9uPgROPusm3bfMoFdaVdcLFZbG7N0GieQ7gEHRqHcbSck5WVGSQVyquje9rMxBQl%2Fr5QVtEFTZMWZIjwb4zpetrlmnAIzOb2%2BXYAZ2Gzh%2FrWeEYBFGP%2BDSE2bog1izHELOn2lkMJSN968WAi8C%2Fn%2F5RqTfcWnTlD9B4TGDZ28etpxvCFWr46CQDxt4ooY3xw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeMinuk.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=cNOe41Eno9XvvOCYamyABH%2F%2FC8LxsUAf32f8mEuuR%2BcsCpNerjERhNFZietFwKhsiO07VDGDOlVn%2Fa2SUgHcivZE%2BrWllATLmJtgM%2FGIbwPMuNgFDigd9wlX3lNUl5Fz3Y9mQeLuZsC2waLnOQyoxSjon3aJ1jjVIJNDhhOli16wPEsDvpGotrmmI7TK7vcikrg%2F8jXnZlCVQnCggH1j8%2FPofITZwIEOzM1r8Wvsa6%2FQVygvywFinASt9OASHjxmaU0jdsJBOthqOwaarmLnGEPJFy7EQBNlqH4Ge2YtLx25u8uECi3doFbcHYdFMtS2FqpYaDxScHZdDrVUreWiQg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeMyeonggyu.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=Lp%2F5Pf%2BYBI3R4RSUJhvIgcYD51Ya0GfXe%2FMKZkIfOBywUNDvds6ZKcW1hqccJjZxFukq2ynWXmi2jVYID%2B9oCgBHiqCIhsBiZAfVSUSVxKj96a%2F5iW2lnh%2B3xNTB%2BNoZ6mRewr2hJm8zXF1yE82L3sQ1%2BqJ00tBGDnnquGaiE5N1LIZDON%2BWdcbltZ8KTuTqg5TI%2F27zeZ6PqIUyrAVwoWRnF02MfVxXZ%2FRFB6DCcIhwq%2B8kJrlGz9xZm2ghaSxn8Wl%2FAZ4mwByuiKsKL0PWOaF5YxbNbz6c4W7nOo04DdJFIP07YCNLZgEiGrDm7dtwV0HPk%2FwSqRDnxPmsvhe6%2FA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeMyungeun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=eSBoX1NGAus2V1bd%2BDUKzIkRZ6B8kf7PolrkB5ztbarumQvasnEsEET3KiEOJ9qk4V22go3ppdVbNSo6ueKvPtn%2BmIS%2F2dWu9fQp6rqWShJpfFSAP4OZxq5cYB3HDJjX%2FOx17scPPVcsc37Ec%2FVF%2FsIbqEvoK9SwmejAguBqBulPQy4Mt%2F2dgP8gT3dx1XIocfWIYKFDP7aCvHfgaAb7D1RxHNLh34Mql6R4uAeFnvmXRnJoF6BuBetEz2rfrzKos1hi3bSaVvBcM48FiAsATvmefU%2B8cNQ%2FrE3wuJzoaGj32ylGRuW1Y5fkofv4NIcJJjkqkwBdr2E%2FQp4hfKcv2A%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeSeungmin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=eW3Ruq%2BjVmQP8Z4AUDZWB9OJMTcKutsZsb24v8eRLuPoLlGaJ7Tob3LFg4MwmIRNKsx504dEFt2pzTelyvK%2BdSVNsLyRbewWTq2D%2FuxZJzzY6BDerrBXuMzC1RcVbGVjLhgfH%2FqbgwhmDWeFy1mXOWTzMeMH6EsqvzI9X06NNl4nIvoj287rDbGWiLMpaAvyhemRrtBzbkpTf4BOV2Qb4N024Vf6JwwaTCpw1cr3V7YVYn1SkZzV7Uu6HBO1%2BKBxvdiouivfnhoRp%2F7NxnNilgJ3BYUWdoi1EMwUT5B4oF%2B2u%2BG3aj9I%2FDwLEmN%2FIfjkqVlULZfoyziblg8zzsNhCA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeWoojeong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=AYQzcsVd3iU1oEXOncpSCAK65M7PVKqNJw%2FhfS3LaFJWjYji7MoySETr%2Bndr5uQyjHTN%2Bho2QGq5mtdEMkTUmIda7NBNF%2FSgd37E6t0bYQyP4i%2FK6t8tNJGksU%2FL%2FGnhhRbhs%2BSdLu7VpcKtns5UJvysQBDv7W90pmrYr8hJYN1myQvl9StOpPwUev2Sk1YuOKV0%2Fg0Ry0w5jb0r%2FhubhZ4aoavnLUxspUxNa4xlN4hItULSW415ILEqhTx8VPi%2FP6ln5nhv5QpDwJYawcru%2FoBBUiZxt0lY3BCsTeT8TaAy8p6Xni2TPi0Eud7GiAh%2B5m6UBHDstc8JcQajz%2FBmVA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeYejin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=huTmaz4EIjate7Wk%2FyFziMTdj9KGsTrzqzW5tsLrCROtLLW58ufWu9Y8Hp4gl4Px3QJ6P4GsKNGEzYVpj4ZOXG7n9%2FWZMkUlcrEkrIvSWo5FmlgzrJ29jZ6wenC%2Fdh1uG18gcBYcyZu3dRmRW9%2BONrefZvmQXZKR2UmWT2GNNSkmeaK6RiEXIISwVO18H47hR65f8lDu8kxsReBBoPBJCiISADOoQiEQWZCgKpazsyqvQwVds50bJ53e0zkX5WCnmJD7Am%2BtmS8lEROMHcOsR4SFragDmu77UEu0Nd%2BtGVyeNDTF5I7hx%2FHczgi9jpkDPXwIxCvaq1H1rM2xbEhXGg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LeeYujeong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=TmcB9sUjMRgqFy%2FgFEdZ9a1Eqv1Xi%2F0rKw6ZxuKfY4x7vZj%2BmDYU6epy5bWcTIj8%2B1i58uxOd8R3wZwG%2BLxcDEBMVZdSOomURFUlgjtE5YyiHsk5TzD1ML41JwQbAJHa5umQeOzUSwge815WqhFXMtYLveyL%2Fh%2F430px8ykQilxR3biJRgYvHTXlDxcdaFEssw58KRgCmWAbJtPKmRTzSiplv8UyrCwKCRufLIxBCF%2BCLV4LH6OXI4vqgwh7cIKbJ6HWcXWogWiexr%2FrE3UPTIfCn03wQIiTuYR2WW4Xlp%2FTZG6nd50hwKr8Z%2BPNZu1eQvF%2BceiR%2FyiooBHcHgQa%2FA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/LimYongdae.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=FfYl3vDBbtvWjDIaMdJy4u%2BhsTGt09ryx8YUHONHKamGmb7P2%2BKY6MUoKgGLP612bN0PUw2yGWFFSfHb0QWfPwQsKy4McDk9N7sJtNATu%2BvpNl7enuRQttV4kaSnpgxgQmeLzlQObuBmM5WCASHxOotcaKFS%2FYtvGH%2FT7fSBL3ORqTz8gYXxJUXmZA3tC7rk9d5CEM4gQ9CjwWKig%2BQvvuvR33pxwSr7buNuUSiXgl8CVvDK4Ctyksu3ELTZIoUQBF51LEM%2Bk5HTmjhhP5SL5%2FWgKc5q7Y4G%2BWJ9ZdlMCjjvJTOjZbQK2XetkQqlS9uJEtEarpzwt%2FqjPkGkG3%2BDAQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/MinKyoungeun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=EZ9FUbNo9EK46VgPHq5%2B6ISRFTx%2FU%2F2ZFYSxmLVFHJooGN62pglUHSkqBql8agb2LiJwXXl3X0l0dfPcC6fI9lz%2BUV11ujDJ8VQ6yXX8tuxsYrKS4GF9EAxOHspo4MkTFxxTKJfCbm9tCAdR6ijxVpds8Qk%2BddWShZUbzBN5KoRmCQiFwJWOYqeDSZP%2ByimqPniTjY6pcILKZxYSyeY1X3epySqIwqM7NDg0DvyL4ybHL41ynH6M3BJJ3SmDApF7vNRhtdWFf0cgw8%2FMGnMNr25IS2OIG0cWJbbcP6xmxD%2FtnNUJc%2FOaX6ruY5V%2BReEvRIgYlcu%2FKZ1xMP1o1J8j3g%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/MoonJihee.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=TWK6BfvseLW%2B9ImrusKZJi6thSSfhBoaFh19piCpExZS3jP78BgpnuWmKXRktWJY6lxnP3tv0ioI9KCdqPv7TJdO2zcOx5uIl8OGvNJ3HRgalprX7giTFDM9gNdSGUlHiXjQeUUmbREoKSfdSsc14fzhfzpmfGvRzo0Gi12QhHwcXtBtVZEjcIDqQ6FF8p3218N5d%2F0mg%2BHuxlDzC8HomiDE4lRPzzjGNO%2B7kV%2BKJ%2FZShyPJ9mp6a5%2FzpyX2LxZrI0ijggIyYLpi1iqtfM166ErktysT4NaU8tvYM6bQ9T6Pt3POV8IY%2FeuCcMGKNWnR6%2BtkrEXJQK%2FvSAzigLou6g%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/MoonKyunghyuk.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=ATy7oB0twXiWPM8NpF%2FwcXJKiL0nPyRZQdNTf5UILst%2Fa8RD4U3XacfzHs2t1F4Dp4F6HWIOoWzrxWR49nzmQCb5EaEMoe8%2Bx0uj8VPA4S7gxMNP%2FmyfNZZjk%2BZXrvrW1YsSo6x2SP4tHejhb2E3vEO6xOmtYAYhuRjO3Uub0MehodgHi%2FRHjn%2BHRCFHNWNL2QyxzZzNlAXMZuJtjmp89WPfYtugo%2BdUKlS52jheJPRPsoiI9Yq0JbyuP6IJk3%2BsARyACtGrYivDeazAWvFDsQEq7De%2BXshSnaA9duVt1jT4jXhqN2l%2BXOE4Ck3AjKGY%2FTwkfLQWFDSwYXcvHtVxAg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/NohKyeongrae.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=r15GFvmSMwINFLfqLCgSvlVeNu0prPiMEk%2BVojZ3BdZ1iONqgyrYYnG9nbfe5TEFSp88S6inLJYOjMZGANvuwT0eOZk1KL6EdRudBMXMk2rYeqyqgtdqYMCi7RxnF1Sb8ciie%2BxucBfdWokIN6%2BbqtlG9aXv5RBBIxlbiOmlQkRAaYMwCrqqNrtzjHqc4IpjvAYtLp5b6VM1OJWqGKZxuu97%2BBUu%2FP1avF8vHV565vmhPKz29ZpXr8AuFDEhHir7oTnpH57bDuXYl4YUI%2Bd0wBbxFrGFSGDOjeele0QeIBsJ5Rw0RZqDN7LE7Rt0F4C3ViMyRJeZSbBxknuO45cZDg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/OSongmin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=jENJHYD60EyaOAgrQ7ElQtSd8IRzML7Vy3VbXy6pDMcc2OqSFLNbNo7PldBOjabPCfVTMF0OF2a8CbhFVv%2FvLRrZPRnqc%2F34RQKwWaNgoIElFRecKCAQxWdOlF61QCaN78zbMI0g2te3jwxKMqX6yKstv0rXqMmwvq0ZpJj42Lob6x7PwWXiG%2BXwP5EW1cicpB8M0nISja9PNGMcNLE9bNxBlbbecYvvocC%2FceLany0vngtrlaxB%2BQJh4tsEjRLqghnL8S0hDZAMV4UybU4Bd9%2FE2yUwW2tOdRGVaAFjNb38UzMjkxEXZNr3VvfLNVXjjIX6uQuuQ1TFLQpnvG0yWg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/OhChaewon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=CerzIhF7exIwzzSDhuaX4QsobXx9JX9gdc3FZW8K5by4q86RlEbXNjKpEEZDjEd5y%2Fy9meXDZOID7txlUMMbE4X%2FkM01zmB6SGlo3xL8Nbs60IQI%2B2QizN55mupnQdw5lA5RGtAMpj8z8ztSk6wB5WKPs9fTBPbh77xJrLpyrYm%2F1geGiOdIUs%2FBdzk7f1rK8yUHGVDsGAaVXhaaKJE%2BINI20W5auzWSwMTL1kQjJiV95KFFMI8NzHqZWboUdBSeYFDj8UAiqh%2Fhor3S%2BrBW3MuHkFHoGLCB%2BTuqKLTzsxME3albfB%2FbvmC7r6sLAE%2FQpsMAZm1KmKSk0f11mBqCQg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/OhHayun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=ACuyHiesBC7acMug%2BK2dHdECdlgLeXNPpuP69DmQF%2FPit7DlY5wPYxZeK%2Biyp6knSZBzyNObs1124ecbqAtQH0KFutwEglbrK7HGtMQAXRVU767edHrwIE6udlqkSa8EoJ6wA6rLLtRbmgcz1iw9n8EwAUzlyhQ6e6LxWIfJUqxgMePczYFAvUsM8noIwzKyfaE4P92G%2FFL8ffh1TK5zH6i%2BEAA1puVQorxejKAmfxnwRfmNOsiNBSyoQQDrQZhl4U9kQlPNNyRQAAwZ6WCUkQGQm5Q974WhDp12pg786gB0FSHtEazf3A0RECsW%2F3gXnB6diaFBLJbV0tFy89oVUA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ParkDongsoo.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=bcijvBDESW%2FLBLjUYilYJX%2F%2FHth93a9lAdyGMHASTTYNRios%2B1x0o1saIdDoN2UMC1eG1B5TgaGaFLeJqEtZ%2FVHbZFI2EG1QOB2RYhqOaXL7UL6HGLOW8CWxaBWskaJO%2FhNXnwauD%2Bdho28bvcRkPzVPNmSIt9ncEuKEjMDihju%2FZ5AXZiNzyAcT33oi2c%2FKW4Vg90yCIVBeY59jyr0okoetq%2FP5DtrU%2B8HDnKimTkqhemM3VR3KOHBsPwau43uouwbHrzFDbp4cUA5c%2FzETC4RZRhBVkFMTKpMYlU4ceoFPStcvHrA9kMy8eZB51ut4HXM9Tl1kSyxzSMVdHyZaJw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ParkGiwoong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=q5VEFUDhPLMhFs7a3aCk8U8VymPKJUmKxDROuJfKy5SwpD5xMGLhGYtrNspUR8Fc%2F34ProYMHiH%2BtQ1e8fda3PX%2FABfnQB42TgRNcNRAyF0eJvIDxyAg%2FD43itWTEriNEYIOIxYqXoQ0MEpjAKAEoNTKK37BOq4%2BF8rHWeiuaMq8gaJFRWgtUFxwJ5N9fmVvtp%2F2DjS5W88pyYAR1y7gd3KY0zX6%2BM0Z%2BdCOazrh%2BVnRpUQQLbevkCkIlLfR6lvz6CtUl99xyJva26sIE8OJy28roG7l6v2Zmmv4Gm%2F18HCrwOK%2FwcgbQ3MfRoQTuvgVRpvpcxDfDFKSaLSUYNn5Xw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ParkHyoungil.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=oQlCLAqodRFe%2BTq1JIs7CkgTg9WAPzFs8RaeLak67nrRzUH6%2FEypgmDcoQYXxZ%2B0QWbGq7S2J6G%2Bur3ywR8YV3DW2K8uJpO7c76uRC71RzOcpS9MVPiRMYWT9G1jxYrnMINBSsMhNobGcp4S47QKQOFesB6NSdAq4BkLVrXGWsvG14E8aUmPlb0xEgiadzYUkUYPqsTmMsoNa28bO8eK4TCa1dyQxV8ZyvZVCAhHKZuxtmdMOOiFl64ymIdyAadQK5Iqku0NsiFQ%2Fp6iXf6jjLKe73JFNGovbf90GF1mWp2OicH7faxMTXLJqwGk9GywFk0kyNY9LXtELY3WphZcQQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/PyoGaeun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=j%2BYjwJUSR1ge3ngwhgemRN1MeHxKMPpjG%2BYfDOyFO0UT4iW3Yeq95su9B2N0xSVuhIETIcNshw8lFdiGMgf3VgzqnJDub05d1VvqTZKsMCPaLu5Qt3E4KiLfhtwuyegFp0lVA66VlLvhJBG3KmAVu7DolN%2FYKnpzAYWPDlfKXr6vSRxPR28VZKM4WHAa2RtFAHwAJIZKFEOAHcTOFYGZa6KD5q8YXwSJz9GkcH0ebZcIziewg9Ed1UMZPxkBrUuGf1rIaWecLfKOH%2FXDfoAmQxmEBoOGVVuaKwxPl3g6IMMkMvLD9ATNPe6BZHgGw%2B16YTxBDPEo%2BnRv5rafdqhzMQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SeoSangwoo.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=m%2BnSBWuiNGGIULZi5BAIaeckCERfdiHLAGHwGy6BxU%2BLxBS1ORx6Is0Ih8wwi4SW87eZ3dTwlMKZljeeMGaS9wl8eKbA1bz74Xp3wV71j%2BwMFrliViTjuTOmjb8%2FqneHhdTZkzUKj4uXKE85C2hu27FJIA8Ipu0W9j8venEZOoQTnacjL49Hz9O3i8IvMq6BaYUcs2YrVMqzbyVcT8qyGAN3aqhuRQ2MpUvN3yU%2Bs6idfUVRRH%2BgADwMWb5l35eHKQdF3xGY5Mmpdsf7mcp3K37kF6C3y%2BfIuso8Q9l0CWO8cNtqsY5%2Fy%2F%2FXb3CE6jkob8CiFH0CEF97vZDetlxOPw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SeoSeok.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=YBFsJyHIanfu8nt3bQ2oPVfb2fAMjr78GXr7QmHP8MCDuVNZlggciD%2FKho%2BnHm3mGFTtb9Jdl%2FGljW9TXg1MkqkqxWb06DlSkh390bxsrxUJ%2BFUUMTDE%2B3kGSDtUaaMzh810TnycRpaJn8OygOVwtUT1%2BenaYDtf25sR%2BWWzPnrevNe0ETabCRYPrPtqrAvjeFYxrf9%2BT758lquGePWe9ziZOKXfcFgaSlU0psmfSST2%2FvaX%2BfVnT1F%2BWBqFPIBO88V9h99q5yDxUZiO5lTpu8RXNu%2Bgv8Go5lrMhgIvAQjVzbiA%2FzbCHgvSYoPyN8yYy6alubZIHoW5mn7Oh8jlZw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SeonMyeonho.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=PQCBw%2BMfRpUtoQ3pBL2nZkRW6EkNnd84%2Fa%2BVT6sDuPb%2BKTaWXKz4hwRy6KsPgoJIjDf4MYICIgniqoX1n1kJ36mCcrujR28PSth408YG7kPzvWU5zGjPIU3YQq2mzGMXXjTQ5dtJ7uWzSMEzjoWkk8vMDqabVQPFqZc%2Bt2cKht46CyfmxtNdCWArsutTsH0WOU38TLUbPL5GNFGzUIN%2B8A7ZBPLmQYyvuYIt2lkmw0poCK2gYVZ1zNcdLuNWhzRG3fkrpdM7uCBY2islna9P4VccbOAd%2FM3A0fFiSjeLiJrtYx8ydp%2FQPgjpBXaT3RMV7bqVta4XVQjva%2FOa3i38kw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ShinHyokyeong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=T1XObk9QcLwdQSE7GmGx%2FwOe7nrFyQWV6uEdrYlslIW5HVdsDK5fkLUHOMX3zijl%2B8WSVjtNcndiwpKPEIoxP9qQQ2LlCtAnlkyXH3d49VMoJlv9aHwN0HFWtKQrPVUyGQskSWHwaKWu5nmX4rEDVJkA%2F0%2Bswd6sFAR8Yu2BUbWr72fuZor9WCELwpZU1WDfCJ%2BNmrkBLsiQDeY%2BzBR1YLXEfZVZUWMY7BN%2B01ZjbpG8IaDS048FD0tQcm9Dr%2FE%2BeOjhYAbqnoMxtw8eSunwoqe8SgLiyxpBGtedO814O29Qy5csfKt5kx0iDzLtidfb735mXaYeYN29W%2BEVGqCOng%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ShinHyunjun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=XGOfkSkGUFeByBKwfxvc%2FApCFd7l5oS%2BNH4G5Uq4NxGrrptUOqEl9adz4dg4ojcN3HBY2klw%2FFqIwHREH9lZIPn1Sj02VHOpMMZF5hRUqvvb8Lo6h5yQf71jCUE84zkot97nY3Ya7cWlq7BM4Wxg3dggh2vY5pzSExG85x3qcY2AwopMMGGSiMyqJYeZ9ndHTc4kMYbrE74miiUG6mmVfqYb%2BoFQF7BJvaA0GdGd2qors62fnYl3V0SMrE9xsdPrRkJrcmZHAY%2BKRpi72wjS%2Bs24UbzXQau2HnSlKq%2F48uEfIWznw0ETgjIlWla46EF7nwae2tjsiVGNv24Xl2h9BA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/ShinSangseop.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=IMAyyeMRTWFttYSfEV6HtKC2gYyx1wx%2BitWM02l2IQFxM0U3Fk6rsZsceUPB980wtPgQox%2Fh2EXiooDp2jyV0VpEN%2B%2F2D5bB9TuZqKFAjuVq3g%2BDk%2BpzvPIWF6e01UDFp3J4YpH7lSQgz8FdZX0Qs1lzde9QnmMH3xsVK0RoRzdZuST2c0gpwwDIhyBYnmsHFsKaY9QpqMZ10HqkRZ3huOJrOUFG2P1Tq8CaKcaVo7s6Xb264r9a3axxpP7BIQk2bGOmBpsLEzdNbMKWwyTGl%2B1aUQxlsoAdgikEC87OijZs7kFJAA%2Fsrt4kfTYfgpvVw72nNqhcizI29wIawWnn2w%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SimYukyoung.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=tDjWhlcmfG4sEnsvC66TyLimFEP6%2B4FsyFE9xtpjhkih%2B705w96nGwuX57l0%2BS6hQWZX9yQpKR%2Bz9mcyiXoorQxf1N63CefdUbMQYrhI9lccmvAUlbe6UhtfRjWF3apF0cSWsYOaMf%2FUkUCz3QYmpgGigklHo1DTxRBR25SrAYz3DoimHar%2BLxImWGX4a%2Bt9LXdfIcZ4rWIDIS8ZZ3%2BoKcgWYaQznWRh8%2Ffy%2F%2BgxXBrBtwFQ%2FcdW24OVSCqpJEsSaIXHyLYk9wec1MEA3yknAsmHOsEQapxiqegfQktMZgcDb7N3j1xP1%2BGrgJgkfnkx2SHeZvXWkGxezN0tw%2FvZHw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SonJungmin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=nO1QMwfXUNMvcX0A5qDhKPMlBCDzkcKLsAvfUe09lXbH9AvH93rhiXIAOGcvPjbxGkI5aRryWunkpgu9ByUk44nUE2suVxxBWnUAQLD6lBCiPI%2FIofPrj5U92y%2Fb7Pmv%2BMmkKnmRZjQphWqfXZOKQ0U8IOEDXUWciBIiCvMt9WYplp%2Bo2JvUPQmMsTfO65jkKGg76bpe7gTvL3MuRv1%2BdMXO3v624iJs4hWqMOMmYWQqYgvVa2B3TIrcSUFhlHrFCQZBd9qOPMQD%2FwRu1zzlSP%2FPlXUiTbbywtwL0pBKYUkYyFTZ1rZfl0547IF63KcgVh%2Fxfw8xrHImY3onWiiOYw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SongGawon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=i3HiKSIFHuNS3ix43V7roD5NRrZrUGzXiVSiyJzS%2BW7Xq3JYw1SZdPKvfei5e6Zsz4kFHN0LjunRadR8IFcz5jEWz82e1JdQXfG4k5pZ8tYtpIuM2Yr1CIVBY%2BT1ywoTPNOO7Zzy%2BroL%2Fh1UniJitP06GJ0B99%2BbFhSfjELmyqlGAOrFCIBOMJ7c7WApuWF2FblV9BmAcGodDb%2Fw59aqPMEQYHjZrIRr21au8UuL3iHRXBBBM7AR5AyyeBmxStTUra%2FkhJAOqcb58qc6M%2B5VJNyGzFR%2BEC0Ltl2uc1EM8XOonFaGFmxstViTNy83M76WzxhPMS9LdRRLzd0qkRzzzQ%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SongJinkyu.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=WFncnA%2FU6ZTmLDPcw6pmfvIw1uqOAMaj5YWR3vNc%2Bgd%2FQM%2BV0oF8lmq1EkryiFzdGjdvX%2BPpZtUNq2YIwq%2FG9wA8%2FQATM9TOKGYONblkvqhu%2BgQHSJ1BlgA6Ayp%2FdHv61Hm0utm3FtYLbi6P%2FAlk%2F3iNCPCWUqajC5ceZxxpunNu1Gh2%2FQMmkKlqJ9ZOg3uYj1sPpxIX1uNoMQzdeqCuor8CTGDjOWBDdfbAn1lzx1PIPJKA0hY8yK%2FDPauY4Z0oGJ2E9wlD%2BN4PB4c0JMjRS4i4Iwmy0Nrias0vUAp%2FcTF%2Br4WlPE1fwQ2JbvwvR4UDnT13nVxYOs00NeP7UKsfjA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SongJunseong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=p9bar2dzxEj8reoMbIB1YhC25tImdjdnTDDYNz9my%2By6vmN2qhK%2FwjAmLocALLXJx6Ux0bK44v3gilr%2ByexFa2vf9uJ4VZmyRf8xDMMRQo85j%2FO6wgoRQ5VGd7%2B6HuOArBQ4Qn9izMVhCNXl3epz3xGzoz7t5dC2eEWhtakmNhKcPSAF%2Fjndolkmy8XcvyIHBVPCC9jrPG6ethbLsdw0cciNioc45TGfb9iMJw%2BbjSNc6hNqTV38hghmLNGRoFgCUtNjmvhiiHieXGznWRkMVuadAHy2sc4wjvzzL%2BLcIPs910s1u%2BpO6sr7la8GzB6j0sh4pamFpc4WWxbC651DUA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SunHaeun.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=ShI0u8fRo5rNxBRJ53ZIRbJXsrwWKula6qzOTlvhqoovtemBZYBRQQ6sRem9MHPFKESJv3cFyG6r62WywFuMDeQOksofvNBLL7CQXYQ5sTWm%2B%2BTuUHNhsVKUctNkKsgEOAu0AOzOZowV5O5alidswfhVORGNhWTOzKlo1rtOBKkuw%2BG0X%2Blg5qeYbucEgXe4dm4HRMYDBHDsv0N5D3xf218GwadTc5wjVF536ZPEGHSXyy4xwB%2FuKs8p71%2F9SFWN9GkgwReUJHr5xKjn55Nt5TwaokLVR%2Bxr8JJ5NSM1X3DH7Ovmn7DI%2BG8jc64rd6AV7H27mQIBnRe7oq0H4xuoAg%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/SungSeungyeon.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=MMDBpBieOKX%2BkcWJC5a9k6AwHblW8TcPnOvj6KtG9KkD772jGeu8b1oXPeiAiVIxNQ0QVfuZ1QICO51PqOq5g52O1OcxDooj%2FwfI%2BFFVrKyg%2Bb3QaVIjWFppOvyGyn%2BH1Riuo%2BaPBmMY0hu3%2FTf93%2FuJUYoYv4otkg3hwsQSaX484Tk8gPsD9vbFXwUMxmSVEK67JB4BPXc0rnCGAmfOfaL%2FpQ3Ijfzhb9BXCr36PrVPThHbdCX4V7b41kvjpQcVWPDt9b788mdHY75fNLvgNdVDEKo81%2FXMG0IjMZx8czVGjEFR8iYXdVb9GA3dOj1RT9tueYleHGiss0aAB58stA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/WooKyungmin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=UngiMpFmH94gN7w6NbAxsfG%2Bxy4txgUI4m%2BRjLcSmdEj9tfmoq5ulTEhHb08MuR9qBWwVlq2oJXXuD6%2F4dlWv5SrnGWJLF464dPAwYqYYi58gLameJtUlxh%2F5O5dZ3cg%2BQ5RyItZCpt9anLToKdY8MHSE8bs7CCiYH53rKet26g38v2wyb54vSX3NivrkgmhAN3V7HPSPFNgB%2BBGfiPSC5TfwfMRPOYidpUKLMdi3CCFhk%2BuXjuG9zUXrjrWnA9P37lxizOzEv1PLpkeMDHW5SKjOlhM9wtHe%2BZHtjc56pj%2FiA307bJlFckGpSKF3pfs%2FQqTrRx4LO8P9kgbt1IVPA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/YoonMyoungjune.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=j8BdjsrDm50A1QzORkkwQG9fO86klHjY3ukLxV3zABSBicKyFVcLp3bomZko45gwCQafjhWienmUi6DEBBnK5viMb%2BR%2BP58%2Ba2QMu9N7PN2hYoyf1ZRSql0GSDRA2CyCep9caPFMrjEkqQdFip0hdUBHeDDJGgtyCMCDdcMPXSbZv%2FWQoHZgmYGbcOzN8msK34gKbn8XvrBtsd7unK%2B4Hubmx5KeVjcnbqP%2FImU8eKKGMfMEgX8TipTudgGwWCiKOdzx5zEHNlLC4i7BHVDKHRV8%2B0F5K%2FkDMKajU5XUx1z1PPuSrSIGK1gIfWPjtC57j80nIGW3Nhz859yTZ6g2cA%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/YoonSubin.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=K6SFGcIuLgNE5FFFeY6V3CTkhQc8Ds%2FnNp3w2rJB9ISQXlyyf4TYYsm2hdPWZP3FaIN44LznSIQBvRoxmNJRsNm6jYFH%2Brs6MgiyT4FDJGXNBGEFjDCQoRi13WXfJE3qf1Te8hOGO50yRdwtvqN7xp07LemwTttnmhT4W8XiddM5rVJgpTToNOhWcWK6chzxY647crANAI%2B4yDjhWu8SCwP4bIk%2BC2QVx7vAadVrS1jOtOJ3f0wTauuYp1Bw6nDNkS0PKnPnBkPF0i1mGPDAEL2Tehd03X0Z0KLMuStIwm1JB%2BLWVkNs2VFmDL7y7K%2F8WqJizaX%2B%2B3shwuOLVv8iQw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/YounYounsong.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=jR2yB4OsIh503yKZBpPhMY0kzn7rVOM65FCqt%2FPEoKbJq%2BH0ISjHcREk%2BYGgwUuoGYaurHpL8uFaTq1Lh7RfGFlMaKwnFYFvcaGyySszxfjS%2BF1wLWm%2FZzQKhKnP0g8ToVnQIOROKezt0rkIUT2aDvA83wHhvam6ub1RVcXaNdzIjezLJYg0Kk%2F3UELF5LpMSh74wenm%2FLkptSPGsLGD0H1Y0dT4Q%2BuH9fHUsrYThagqnzjF%2FVw3aPYsaKNYTpHCFwaMyDmHaHmz5ijZABYIR%2B3k0CcUewe49cAUGDaegusCsbzv%2Bibj6u%2FSaedR9rOUGIzOxgFv52WpVm%2FUerv6Kw%3D%3D" alt="">
    <img src="https://storage.googleapis.com/hninepeople.firebasestorage.app/images/YunSuyoung.png?GoogleAccessId=firebase-adminsdk-fbsvc%40hninepeople.iam.gserviceaccount.com&Expires=16446985200&Signature=WL8Bw%2BbtXNA9%2BXTh%2B525RqATbuccE1hU51b1aJRY4eR%2FIzACJcWVVPrnrmKXuKsfX%2BhnPRJExzrIcXL2f8SisXn0f7dKHjTWjyzL0MNWS68C8i2A71fMeDknh9sNkd3GiE6KI8UKiOYgrKZYsJCrZ6ecLsAF48HGUBp1e8cuU4KyzNb63lCxwaGFWmKzS6aNdNp%2FPRqLQ1pGmDWT1%2B9dEXl%2FLc3wTr0KOvmrxwKW7duRwGRI5kEWtXxqSgkZGHiHX8fDOfgui4Ehl%2FZ7nBtPMQ%2BykKxxqI9fjWntBMkGK%2FeFDjJvymlP6%2FeEkH94DVG78gYMH%2FDrFUe9%2FOiAoVHrmg%3D%3D" alt="">
</div>
  <div style="width: 100%; height: 100vh; margin: 0; padding: 0; overflow: hidden;">
    <div id="canvasContainer1" class="canvas-container">
      <canvas id="imageCanvas1"></canvas>
      <!-- <div id="gradient" class="gradient"></div> -->
      <div id="imageCanvas1_text" class="canvas-text hide">Canvas 1 Text</div>
      <!-- <img src="images/YoonSubin.png" alt=""> -->
  </div>
    <div id="canvasContainer2" class="canvas-container">
      <canvas id="imageCanvas2"></canvas>
      <!-- <div id="gradient" class="gradient"></div> -->
      <div id="imageCanvas2_text" class="canvas-text hide">Canvas 2 Text</div></div>
    <div id="canvasContainer3" class="canvas-container">
      <canvas id="imageCanvas3"></canvas>
      <!-- <div id="gradient" class="gradient"></div> -->
      <div id="imageCanvas3_text" class="canvas-text hide">Canvas 3 Text</div></div>
    <div id="canvasContainer4" class="canvas-container">
      <canvas id="imageCanvas4"></canvas>
      <!-- <div id="gradient" class="gradient"></div> -->
      <div id="imageCanvas4_text" class="canvas-text hide">Canvas 4 Text</div></div></div>
  <script type="module" src="main.js?v=20250701.01"></script>
</body>

</html>
</file>

<file path="main.js">
import { initializePeopleData, shuffleArray } from './peopleDataLoader.js';
import { imageDataCache, initializeImageLoader, loadBatch, cleanupBatch } from './imageLoader.js';
import Particle from './Particle.js';
import OptimizedParticlePool from './OptimizedParticlePool.js';
import animationManager from './AnimationManager.js';
import performanceMonitor from './PerformanceMonitor.js';
import particleCalculatorWorkerManager from './ParticleCalculatorWorkerManager.js';

const canvasIds = ['imageCanvas1', 'imageCanvas2', 'imageCanvas3', 'imageCanvas4'];
const canvasContexts = {};
const particlePools = {}; // 이제 OptimizedParticlePool 인스턴스들을 저장
let shuffledPeople = [];

// --- State Management ---
let nextPersonIndex = 0; 
const animationQueue = []; // The queue of canvasIds ready for the next animation

// --- Constants ---
const maxParticles = 8200;
const stepPixel = 20;
const TICK_INTERVAL = 4000; // The conductor's steady beat for starting animations
const EXPLOSION_START_DELAY = 3000;
const EXPLOSION_PARTICLE_DELAY = 3000;
const IMAGE_BATCH_SIZE = 4; 

// --- Initialization ---

window.onload = () => {
    canvasIds.forEach(id => {
        const canvas = document.getElementById(id);
        if (canvas) {
            // AnimationManager를 사용하여 최적화된 컨텍스트 획득
            canvasContexts[id] = animationManager.getOptimizedContext(id);
        }
    });
    dataLoad();
};

async function dataLoad() {
    try {
        const peopleData = await initializePeopleData();
        if (!peopleData || !Array.isArray(peopleData) || peopleData.length === 0) {
            throw new Error('peopleData is empty');
        }
        shuffledPeople = shuffleArray([...peopleData]);
        console.log("People data shuffled. Initializing image loader...");

        await initializeImageLoader(shuffledPeople, stepPixel, IMAGE_BATCH_SIZE);

        canvasIds.forEach(id => {
            createParticles(id);
            animationQueue.push(id); // Prime the queue
        });

        startConductor();
    } catch (error) {
        console.error("Fatal error during initial data load:", error);
    }
}

function createParticles(canvasId) {
    // OptimizedParticlePool을 사용하여 메모리 효율성 개선
    particlePools[canvasId] = new OptimizedParticlePool(maxParticles);
}

// --- Conductor (The new core logic) ---

function startConductor() {
    console.log("--- Conductor starting ---");
    // Start the first animation immediately.
    conductorTick();

    // AnimationManager를 사용하여 메모리 누수 방지
    const intervalId = setInterval(conductorTick, TICK_INTERVAL);
    
    // 성능 모니터링 시작
    performanceMonitor.start();
    
    // 페이지 언로드 시 정리
    window.addEventListener('beforeunload', () => {
        clearInterval(intervalId);
        animationManager.cleanup();
        performanceMonitor.stop();
        particleCalculatorWorkerManager.cleanup();
    });
}

function conductorTick() {
    if (animationQueue.length === 0) {
        // console.log("Queue is empty, waiting for a canvas to finish.");
        return; // Nothing to do
    }

    const canvasId = animationQueue.shift(); // Get the next canvas from the front of the queue
    const personIndex = nextPersonIndex++;

    console.log(`Conductor tick: Starting ${canvasId} with person index ${personIndex}`);

    // --- Double Buffering Logic ---
    // This is the perfect place to manage the buffer, as it's tied to the assignment of a new index.
    const batchNumber = Math.floor(personIndex / IMAGE_BATCH_SIZE);
    if (personIndex % IMAGE_BATCH_SIZE === 0 && batchNumber > 0) {
        const batchToLoadIndex = (batchNumber + 1) * IMAGE_BATCH_SIZE;
        const batchToCleanupIndex = (batchNumber - 1) * IMAGE_BATCH_SIZE;

        console.log(`Triggering buffer update at person index ${personIndex}`);
        console.log(`  - Loading batch @ ${batchToLoadIndex}`);
        console.log(`  - Cleaning up batch @ ${batchToCleanupIndex}`);

        // Perform in the background
        cleanupBatch(batchToCleanupIndex, IMAGE_BATCH_SIZE);
        loadBatch(batchToLoadIndex, IMAGE_BATCH_SIZE).catch(console.error);
    }
    
    // Handle infinite looping of people data
    const loopedPersonIndex = personIndex % shuffledPeople.length;

    init(canvasId, loopedPersonIndex);
}

function onAnimationComplete(canvasId) {
    console.log(`${canvasId} finished. Returning to the back of the queue.`);
    animationQueue.push(canvasId); // Return the canvas to the end of the queue
}

// --- Animation Functions ---

const animationFrameIds = {};
const canvasRetryCounters = {}; // 캔버스별 재시도 카운터

function init(canvasId, personIndex) {
    const person = shuffledPeople[personIndex];
    
    // 디버깅을 위한 로그
    console.log(`Trying to load person ${personIndex}, cache size: ${imageDataCache.size}`);
    
    const pixels = imageDataCache.get(personIndex);

    if (!pixels) {
        console.error(`Image data for index ${personIndex} not in cache! Will retry...`);
        
        // 캐시 상태 확인
        console.log('Available cache keys:', Array.from(imageDataCache.keys()));
        
        // 무한 루프 방지를 위한 최대 재시도 횟수 제한
        if (!canvasRetryCounters[canvasId]) canvasRetryCounters[canvasId] = 0;
        canvasRetryCounters[canvasId]++;
        
        if (canvasRetryCounters[canvasId] > 10) {
            console.error(`Too many retries for ${canvasId}, skipping to next person`);
            canvasRetryCounters[canvasId] = 0;
            return; // 다음 틱에서 새로운 person index로 시도
        }
        
        // If data isn't ready, put the canvas back at the front of the queue to be picked up on the next tick.
        animationQueue.unshift(canvasId);
        nextPersonIndex--; // Decrement the counter since this attempt failed
        return;
    }
    
    // 성공 시 재시도 카운터 리셋
    canvasRetryCounters[canvasId] = 0;

    const text = document.getElementById(canvasId + '_text');
    const canvas = document.getElementById(canvasId);
    const ctx = canvasContexts[canvasId];

    canvas.width = window.innerWidth / 4;
    canvas.height = window.innerHeight;
    canvas.style.display = 'block';
    cancelAnimation(canvasId);

    const originalText = person.englishName.replace(/([a-z])([A-Z])/g, '$1 $2');
    text.innerText = originalText.toUpperCase();
    text.classList.remove("hide");

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let particles = particlePools[canvasId].activateParticles(pixels, canvas.width, canvas.height, stepPixel);

    async function animate(timestamp) {
        const frameStartTime = performance.now();
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let allParticlesAtTarget = true;

        // 파티클 업데이트 시간 측정
        const updateStartTime = performance.now();
        
        // 전역 애니메이션 상태 업데이트
        particlePools[canvasId].updateGlobalState(timestamp);
        
        // Web Worker를 통한 파티클 계산 (폴백 지원)
        try {
            await particleCalculatorWorkerManager.updateParticles(particles, timestamp);
        } catch (error) {
            // 폴백: 메인 스레드에서 직접 계산
            for (let i = 0; i < particles.length; i++) {
                particles[i].update(timestamp);
            }
        }
        
        // 렌더링은 메인 스레드에서 수행
        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            p.draw(ctx);
            if (!p.isAtTarget()) allParticlesAtTarget = false;
        }
        
        // 성능 모니터링
        const updateTime = performance.now() - updateStartTime;
        performanceMonitor.recordParticleUpdate(updateTime, particles.length);
        performanceMonitor.recordFrame(frameStartTime);

        if (!allParticlesAtTarget) {
            animationFrameIds[canvasId] = animationManager.requestAnimationFrame(animate);
        } else {
            console.log(`애니메이션이 ${canvasId}에서 완료되었습니다.`);
            animationManager.setTimeout(() => {
                console.log(`폭발 시작 ${canvasId}`);
                startExplosionAnimation(canvasId, particles, ctx);
            }, EXPLOSION_START_DELAY);
        }
    }
    animationFrameIds[canvasId] = animationManager.requestAnimationFrame(animate);
}

function startExplosionAnimation(canvasId, particles, ctx) {
    document.getElementById(canvasId + '_text').classList.add('hide');

    for (let i = 0; i < particles.length; i++) {
        animationManager.setTimeout(() => particles[i].explode(), Math.random() * EXPLOSION_PARTICLE_DELAY);
    }

    function explodeAnimation() {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        let allParticlesOutside = true;

        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            p.update(performance.now());
            if (p.pos.x > 0 && p.pos.x < ctx.canvas.width && p.pos.y > 0 && p.pos.y < ctx.canvas.height) {
                allParticlesOutside = false;
            }
            p.draw(ctx);
        }

        if (!allParticlesOutside) {
            animationFrameIds[canvasId] = animationManager.requestAnimationFrame(explodeAnimation);
        } else {
            console.log(`${canvasId} 폭발 애니메이션이 완료되었습니다.`);
            onAnimationComplete(canvasId);
        }
    }
    animationFrameIds[canvasId] = animationManager.requestAnimationFrame(explodeAnimation);
}

// activateParticles 함수는 OptimizedParticlePool.activateParticles()로 대체됨

function cancelAnimation(canvasId) {
    if (animationFrameIds[canvasId]) {
        animationManager.cancelAnimationFrame(animationFrameIds[canvasId]);
        animationFrameIds[canvasId] = null;
    }
}

// === 개발자 도구용 전역 함수들 ===
// 브라우저 콘솔에서 성능 정보 확인 가능

window.getPerformanceReport = () => {
    return performanceMonitor.generateReport();
};

window.getRealtimeStats = () => {
    return performanceMonitor.getRealTimeStats();
};

window.getAnimationManagerInfo = () => {
    return animationManager.getResourceInfo();
};

window.getImageWorkerStatus = () => {
    return import('./ImageWorkerManager.js').then(module => 
        module.default.getStatus()
    );
};

window.getParticleWorkerStatus = () => {
    return particleCalculatorWorkerManager.getStatus();
};

// 성능 정보를 주기적으로 콘솔에 출력 (개발 모드에서만)
if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
    setInterval(() => {
        const stats = window.getRealtimeStats();
        console.log('🎯 Real-time Performance:', {
            FPS: stats.currentFPS.toFixed(1),
            Memory: `${stats.memoryUsed}MB`,
            Frames: stats.frameCount,
            Runtime: `${(stats.runtime / 1000).toFixed(1)}s`
        });
    }, 10000); // 10초마다 출력
}
</file>

<file path="server.js">
// 환경 변수 로드
require('dotenv').config();

const express = require('express');
const multer = require('multer');
const fs = require('fs').promises;
const path = require('path');
const cors = require('cors');
const { parse } = require('csv-parse/sync');
const yauzl = require('yauzl');
const { promisify } = require('util');

// Firebase 조건부 로드
let firebase = null;
try {
  firebase = require('./firebase');
} catch (error) {
  console.log('Firebase 모듈을 로드할 수 없습니다. 로컬 파일 시스템을 사용합니다.');
}

const app = express();
const PORT = process.env.PORT || 3000;

// CORS 설정
const corsOptions = {
  origin: process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(',') : ['http://localhost:3000'],
  credentials: true,
  optionsSuccessStatus: 200
};

// 미들웨어 설정
app.use(cors(corsOptions));
app.use(express.json({ limit: '10mb' }));
app.use(express.static('.')); // 현재 디렉토리를 정적 파일 서버로 설정

// 파일 업로드 보안 설정
const allowedFileTypes = process.env.ALLOWED_FILE_TYPES ? 
  process.env.ALLOWED_FILE_TYPES.split(',') : 
  ['image/jpeg', 'image/png', 'image/gif'];

const maxFileSize = parseInt(process.env.MAX_FILE_SIZE) || 10 * 1024 * 1024; // 기본 10MB

// 파일 필터링 함수
const fileFilter = (req, file, cb) => {
  if (allowedFileTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error(`지원하지 않는 파일 타입입니다. 허용된 타입: ${allowedFileTypes.join(', ')}`), false);
  }
};

// 이미지 업로드 설정
const storage = multer.diskStorage({
    destination: './images/',
    filename: (req, file, cb) => {
        // 임시 파일명으로 저장 (timestamp + 확장자)
        cb(null, Date.now() + path.extname(file.originalname));
    }
});

const upload = multer({ 
    storage: multer.memoryStorage(),
    fileFilter: fileFilter,
    limits: {
        fileSize: maxFileSize
    }
});

const PEOPLE_PATH = './images/people.json';

// 현재 데이터 조회
app.get('/api/items', async (req, res) => {
    try {
        // words.js 파일 읽기
        const wordsContent = await fs.readFile('./words.js', 'utf8');

        // originWords 배열 추출
        const wordsMatch = wordsContent.match(/export const originWords\s*=\s*\[([\s\S]*?)\]/);
        const textsMatch = wordsContent.match(/export const originTexts\s*=\s*\[([\s\S]*?)\]/);

        let words = [];
        let texts = [];

        if (wordsMatch) {
            const wordsString = wordsMatch[1];
            words = parseArrayFromString(wordsString);
        }

        if (textsMatch) {
            const textsString = textsMatch[1];
            texts = parseArrayFromString(textsString);
        }

        // images.json 파일 읽기
        let images = [];
        try {
            const imagesContent = await fs.readFile('./images/images.json', 'utf8');
            images = JSON.parse(imagesContent);
        } catch (error) {
            console.warn('images.json 파일이 없습니다.');
        }

        res.json({ words, texts, images });
    } catch (error) {
        console.error('데이터 조회 실패:', error);
        res.status(500).json({ error: error.message });
    }
});

// 항목 추가 (이미지 업로드 + 파일 업데이트)
app.post('/api/items', upload.single('image'), async (req, res) => {
    try {
        const { koreanName, englishName } = req.body;
        console.log('req.file:', req.file);
        console.log('oldPath:', req.file.path);
        console.log('newPath:', path.join(req.file.destination, `${englishName}.png`));
        // 업로드된 파일의 경로
        const oldPath = req.file.path;
        const newPath = path.join(req.file.destination, `${englishName}.png`);
        // 파일명 변경
        await fs.rename(oldPath, newPath);

        // 1. words.js 업데이트
        await updateWordsJS(koreanName, englishName);

        // 2. images.json 업데이트
        await updateImagesJSON(englishName);

        // 3. index.html 업데이트
        await updateIndexHTML(englishName);

        res.json({
            success: true,
            message: '항목이 성공적으로 추가되었습니다.',
            filename: `${englishName}.png`
        });

    } catch (error) {
        console.error('항목 추가 실패:', error);
        res.status(500).json({ error: error.message });
    }
});

// 항목 삭제
app.delete('/api/items/:englishName', async (req, res) => {
    try {
        const { englishName } = req.params;

        // 1. 이미지 파일 삭제
        try {
            await fs.unlink(`./images/${englishName}.png`);
        } catch (error) {
            console.warn(`이미지 파일 삭제 실패: ${englishName}.png`);
        }

        // 2. 파일들에서 제거
        await removeFromFiles(englishName);

        res.json({
            success: true,
            message: '항목이 성공적으로 삭제되었습니다.'
        });

    } catch (error) {
        console.error('항목 삭제 실패:', error);
        res.status(500).json({ error: error.message });
    }
});

// 항목 편집 (이름/이미지 교체)
app.post('/api/items/:oldEnglishName/edit', upload.single('image'), async (req, res) => {
    try {
        const { oldEnglishName, oldKoreanName, newEnglishName, newKoreanName } = req.body;
        const oldImagePath = path.join('./images/', `${oldEnglishName}.png`);
        const newImagePath = path.join('./images/', `${newEnglishName}.png`);
        // 1. 이미지 교체(업로드 시)
        if (req.file) {
            // 새 이미지가 업로드된 경우: 무조건 newEnglishName.png로 저장
            await fs.writeFile(newImagePath, await fs.readFile(req.file.path));
            await fs.unlink(req.file.path);
            // oldEnglishName이 다르면 기존 파일 삭제
            if (oldEnglishName !== newEnglishName) {
                await fs.unlink(oldImagePath).catch(() => { });
            }
        } else if (oldEnglishName !== newEnglishName) {
            // 이미지 업로드 없이 이름만 바뀌면 파일명 변경
            await fs.rename(oldImagePath, newImagePath);
        }
        // 2. words.js, images.json, index.html 업데이트
        await updateWordsAndFilesOnEdit(oldEnglishName, oldKoreanName, newEnglishName, newKoreanName);
        res.json({ success: true, message: '항목이 성공적으로 수정되었습니다.' });
    } catch (error) {
        console.error('항목 편집 실패:', error);
        res.status(500).json({ error: error.message });
    }
});

// 편집 시 words.js, images.json, index.html 동기화 함수
async function updateWordsAndFilesOnEdit(oldEnglishName, oldKoreanName, newEnglishName, newKoreanName) {
    // words.js
    const content = await fs.readFile('./words.js', 'utf8');
    const wordsMatch = content.match(/(export const originWords\s*=\s*\[)([\s\S]*?)(\])/);
    const textsMatch = content.match(/(export const originTexts\s*=\s*\[)([\s\S]*?)(\])/);
    if (wordsMatch && textsMatch) {
        let wordsArray = parseArrayFromString(wordsMatch[2]);
        let textsArray = parseArrayFromString(textsMatch[2]);
        const idx = wordsArray.indexOf(oldEnglishName);
        if (idx !== -1) {
            wordsArray[idx] = newEnglishName;
            textsArray[idx] = newKoreanName;
        }
        const newWordsContent = wordsMatch[1] + wordsArray.map(word => `    "${word}"`).join(',\n') + wordsMatch[3];
        const newTextsContent = textsMatch[1] + textsArray.map(text => `    "${text}"`).join(',\n') + textsMatch[3];
        const newContent = content.replace(wordsMatch[0], newWordsContent).replace(textsMatch[0], newTextsContent);
        await fs.writeFile('./words.js', newContent, 'utf8');
    }
    // images.json
    let images = [];
    try {
        const imagesContent = await fs.readFile('./images/images.json', 'utf8');
        images = JSON.parse(imagesContent);
    } catch { }
    const imgIdx = images.indexOf(`${oldEnglishName}.png`);
    if (imgIdx !== -1) {
        images[imgIdx] = `${newEnglishName}.png`;
    }
    await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');
    // index.html
    const htmlContent = await fs.readFile('./index.html', 'utf8');
    const imageTagRegex = new RegExp(`<img src=\"images/${oldEnglishName}\.png\" alt=\"\">`, 'g');
    const newHtmlContent = htmlContent.replace(imageTagRegex, `<img src=\"images/${newEnglishName}.png\" alt=\"\">`);
    await fs.writeFile('./index.html', newHtmlContent, 'utf8');
}

// words.js 업데이트 함수
async function updateWordsJS(koreanName, englishName) {
    try {
        const content = await fs.readFile('./words.js', 'utf8');

        // originWords 배열에 추가
        const wordsMatch = content.match(/(export const originWords\s*=\s*\[)([\s\S]*?)(\])/);
        if (wordsMatch) {
            const newWordsContent = wordsMatch[1] +
                (wordsMatch[2].trim() ? wordsMatch[2] + ',\n    ' : '\n    ') +
                `"${englishName}"` +
                wordsMatch[3];

            // originTexts 배열에 추가
            const textsMatch = content.match(/(export const originTexts\s*=\s*\[)([\s\S]*?)(\])/);
            if (textsMatch) {
                const newTextsContent = textsMatch[1] +
                    (textsMatch[2].trim() ? textsMatch[2] + ',\n    ' : '\n    ') +
                    `"${koreanName}"` +
                    textsMatch[3];

                const newContent = content
                    .replace(wordsMatch[0], newWordsContent)
                    .replace(textsMatch[0], newTextsContent);

                await fs.writeFile('./words.js', newContent, 'utf8');
            }
        }
    } catch (error) {
        console.error('words.js 업데이트 실패:', error);
        throw error;
    }
}

// images.json 업데이트 함수
async function updateImagesJSON(englishName) {
    try {
        let images = [];
        try {
            const content = await fs.readFile('./images/images.json', 'utf8');
            images = JSON.parse(content);
        } catch (error) {
            console.warn('images.json 파일이 없어 새로 생성합니다.');
        }

        images.push(`${englishName}.png`);
        await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');
    } catch (error) {
        console.error('images.json 업데이트 실패:', error);
        throw error;
    }
}

// index.html 업데이트 함수
async function updateIndexHTML(englishName) {
    try {
        const content = await fs.readFile('./index.html', 'utf8');

        // 새로운 이미지 태그 추가
        const newImageTag = `    <img src="images/${englishName}.png" alt="">\n`;

        // </div> 태그 앞에 추가 (숨겨진 이미지 섹션)
        const insertPosition = content.lastIndexOf('  </div>');
        if (insertPosition !== -1) {
            const newContent = content.slice(0, insertPosition) + newImageTag + content.slice(insertPosition);
            await fs.writeFile('./index.html', newContent, 'utf8');
        }
    } catch (error) {
        console.error('index.html 업데이트 실패:', error);
        throw error;
    }
}

// 파일들에서 항목 제거 함수
async function removeFromFiles(englishName) {
    try {
        // 1. words.js에서 제거
        const wordsContent = await fs.readFile('./words.js', 'utf8');
        const wordsMatch = wordsContent.match(/(export const originWords\s*=\s*\[)([\s\S]*?)(\])/);
        const textsMatch = wordsContent.match(/(export const originTexts\s*=\s*\[)([\s\S]*?)(\])/);

        if (wordsMatch && textsMatch) {
            const wordsArray = parseArrayFromString(wordsMatch[2]);
            const textsArray = parseArrayFromString(textsMatch[2]);

            const wordIndex = wordsArray.indexOf(englishName);
            if (wordIndex !== -1) {
                wordsArray.splice(wordIndex, 1);
                textsArray.splice(wordIndex, 1);

                const newWordsContent = wordsMatch[1] +
                    wordsArray.map(word => `    "${word}"`).join(',\n') +
                    wordsMatch[3];
                const newTextsContent = textsMatch[1] +
                    textsArray.map(text => `    "${text}"`).join(',\n') +
                    textsMatch[3];

                const newContent = wordsContent
                    .replace(wordsMatch[0], newWordsContent)
                    .replace(textsMatch[0], newTextsContent);

                await fs.writeFile('./words.js', newContent, 'utf8');
            }
        }

        // 2. images.json에서 제거
        try {
            const imagesContent = await fs.readFile('./images/images.json', 'utf8');
            let images = JSON.parse(imagesContent);
            images = images.filter(img => img !== `${englishName}.png`);
            await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');
        } catch (error) {
            console.warn('images.json 파일이 없습니다.');
        }

        // 3. index.html에서 제거
        const htmlContent = await fs.readFile('./index.html', 'utf8');
        const imageTagRegex = new RegExp(`\\s*<img src="images/${englishName}\\.png" alt="">\\s*\\n?`, 'g');
        const newHtmlContent = htmlContent.replace(imageTagRegex, '');
        await fs.writeFile('./index.html', newHtmlContent, 'utf8');

    } catch (error) {
        console.error('파일에서 항목 제거 실패:', error);
        throw error;
    }
}

// 문자열 배열 파싱 함수
function parseArrayFromString(arrayString) {
    const matches = arrayString.match(/"([^"]*)"/g);
    if (matches) {
        return matches.map(match => match.slice(1, -1));
    }
    return [];
}

// Firestore에서 people 목록 조회
app.get('/api/people', async (req, res) => {
    try {
        console.log('GET /api/people 요청 받음');
        if (firebase && firebase.db) {
            const snapshot = await firebase.db.collection('people').get();
            const people = snapshot.docs.map(doc => doc.data());
            console.log(`${people.length}개의 people 데이터 반환`);
            res.json(people);
        } else {
            // 로컬 파일 시스템 사용 (Firebase 미설정 시)
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                console.log('people.json 파일이 없어 빈 배열 반환');
            }
            res.json(people);
        }
    } catch (error) {
        console.error('GET /api/people 에러:', error);
        res.status(500).json({ error: error.message });
    }
});

// Firestore 기반 동기화 함수
async function syncLegacyFilesFromFirestore() {
    if (!firebase || !firebase.db) {
        console.log('Firebase가 설정되지 않아 동기화를 건너뜁니다.');
        return;
    }
    
    try {
        // 1. Firestore에서 people 전체 목록 조회
        const snapshot = await firebase.db.collection('people').get();
        const people = snapshot.docs.map(doc => doc.data());

        // 2. words.js 생성
        const words = people.map(p => `    "${p.englishName}"`).join(',\n');
        const texts = people.map(p => `    "${p.koreanName}"`).join(',\n');
        const wordsJs = `export function shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}\nexport const originWords = [\n${words}\n];\n\nexport const originTexts = [\n${texts}\n];\n`;
        await fs.writeFile('./words.js', wordsJs, 'utf8');

        // 3. images.json 생성
        const images = people.map(p => p.imageFile || (p.englishName + '.png'));
        await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');

        // 4. index.html의 숨겨진 이미지 태그 영역 동기화
        let html = await fs.readFile('./index.html', 'utf8');
        html = html.replace(/(<div style="display: none;">)[\s\S]*?(<\/div>)/, (m, p1, p2) => {
            // imageUrl(Download URL) 우선 사용
            const tags = people.map(p => `    <img src="${p.imageUrl}" alt="">`).join('\n');
            return `${p1}\n${tags}\n${p2}`;
        });
        await fs.writeFile('./index.html', html, 'utf8');
    } catch (error) {
        console.error('Firestore 동기화 실패:', error);
    }
}

app.post('/api/people', upload.single('image'), async (req, res) => {
    try {
        const { koreanName, englishName, organization, role, position, email } = req.body;
        const file = req.file;
        let imageUrl = '';

        // Firebase가 설정된 경우에만 Firebase 사용
        if (firebase && firebase.db && firebase.bucket) {
            if (file) {
                // 1. Storage에 이미지 업로드
                const storageFile = firebase.bucket.file(`images/${englishName}.png`);
                await storageFile.save(file.buffer, {
                    metadata: { contentType: file.mimetype }
                });
                // 2. Download URL(공개 링크) 생성
                const [url] = await storageFile.getSignedUrl({
                    action: 'read',
                    expires: '03-09-2491' // 충분히 먼 미래
                });
                imageUrl = url;
            }

            // 3. Firestore에 데이터 저장
            await firebase.db.collection('people').doc(englishName).set({
                koreanName, englishName, organization, role, position, email, imageUrl
            });
            // 4. 파일 동기화
            await syncLegacyFilesFromFirestore();
        } else {
            // 로컬 파일 시스템 사용
            if (file) {
                const imagePath = path.join('./images/', `${englishName}.png`);
                await fs.writeFile(imagePath, file.buffer);
                imageUrl = `images/${englishName}.png`;
            }
            
            // people.json에 데이터 추가
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                console.log('people.json 파일이 없어 새로 생성합니다.');
            }
            
            people.push({
                koreanName, englishName, organization, role, position, email, 
                imageFile: `${englishName}.png`
            });
            
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }

        res.json({ success: true, message: '추가되었습니다.' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.patch('/api/people/:englishName', upload.single('image'), async (req, res) => {
    try {
        const { englishName } = req.params;
        const { koreanName, newEnglishName, organization, role, position, email } = req.body;
        const file = req.file;

        // Firebase가 설정된 경우에만 Firebase 사용
        if (firebase && firebase.db && firebase.bucket) {
            // Firestore에서 기존 데이터 조회
            const doc = await firebase.db.collection('people').doc(englishName).get();
            if (!doc.exists) return res.status(404).json({ error: 'Not found' });
            const person = doc.data();

            let imageUrl = person.imageUrl;

            // 이미지 교체 시 기존 이미지 삭제 후 새 이미지 업로드
            if (file) {
                // 기존 이미지 삭제
                await firebase.bucket.file(`images/${englishName}.png`).delete().catch(() => { });
                // 새 이미지 업로드
                const newFileName = `images/${newEnglishName || englishName}.png`;
                await firebase.bucket.file(newFileName).save(file.buffer, {
                    metadata: { contentType: file.mimetype }
                });
                // Download URL 생성
                const [url] = await firebase.bucket.file(newFileName).getSignedUrl({
                    action: 'read',
                    expires: '03-09-2491'
                });
                imageUrl = url;
            } else if (newEnglishName && newEnglishName !== englishName) {
                // 이름만 바뀌면 파일명 변경
                await firebase.bucket.file(`images/${englishName}.png`).move(`images/${newEnglishName}.png`);
                // Download URL 생성
                const [url] = await firebase.bucket.file(`images/${newEnglishName}.png`).getSignedUrl({
                    action: 'read',
                    expires: '03-09-2491'
                });
                imageUrl = url;
            }

            // Firestore 데이터 수정
            await firebase.db.collection('people').doc(newEnglishName || englishName).set({
                koreanName,
                englishName: newEnglishName || englishName,
                organization,
                role,
                position,
                email,
                imageUrl
            });

            // 기존 문서 삭제(이름이 바뀐 경우)
            if (newEnglishName && newEnglishName !== englishName) {
                await firebase.db.collection('people').doc(englishName).delete();
            }

            // 4. 파일 동기화
            await syncLegacyFilesFromFirestore();
        } else {
            // 로컬 파일 시스템 사용
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                return res.status(404).json({ error: 'Not found' });
            }
            
            const personIndex = people.findIndex(p => p.englishName === englishName);
            if (personIndex === -1) return res.status(404).json({ error: 'Not found' });
            
            // 이미지 처리
            if (file) {
                const imagePath = path.join('./images/', `${newEnglishName || englishName}.png`);
                await fs.writeFile(imagePath, file.buffer);
                
                // 기존 이미지 삭제
                if (newEnglishName && newEnglishName !== englishName) {
                    try {
                        await fs.unlink(path.join('./images/', `${englishName}.png`));
                    } catch (error) {
                        console.warn('기존 이미지 삭제 실패:', error);
                    }
                }
            } else if (newEnglishName && newEnglishName !== englishName) {
                // 파일명 변경
                try {
                    await fs.rename(
                        path.join('./images/', `${englishName}.png`),
                        path.join('./images/', `${newEnglishName}.png`)
                    );
                } catch (error) {
                    console.warn('이미지 파일명 변경 실패:', error);
                }
            }
            
            // 데이터 업데이트
            people[personIndex] = {
                koreanName,
                englishName: newEnglishName || englishName,
                organization,
                role,
                position,
                email,
                imageFile: `${newEnglishName || englishName}.png`
            };
            
            // 이름이 바뀐 경우 기존 항목 삭제
            if (newEnglishName && newEnglishName !== englishName) {
                people.splice(personIndex, 1);
            }
            
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }

        res.json({ success: true, message: '수정되었습니다.' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.delete('/api/people/:englishName', async (req, res) => {
    try {
        const { englishName } = req.params;
        
        // Firebase가 설정된 경우에만 Firebase 사용
        if (firebase && firebase.db && firebase.bucket) {
            // Firestore에서 데이터 조회
            const doc = await firebase.db.collection('people').doc(englishName).get();
            if (!doc.exists) return res.status(404).json({ error: 'Not found' });
            const person = doc.data();
            // Storage에서 이미지 삭제
            if (person.imageUrl) {
                const fileName = `images/${englishName}.png`;
                await firebase.bucket.file(fileName).delete().catch(() => { });
            }
            // Firestore에서 문서 삭제
            await firebase.db.collection('people').doc(englishName).delete();
            // 4. 파일 동기화
            await syncLegacyFilesFromFirestore();
        } else {
            // 로컬 파일 시스템 사용
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                return res.status(404).json({ error: 'Not found' });
            }
            
            const personIndex = people.findIndex(p => p.englishName === englishName);
            if (personIndex === -1) return res.status(404).json({ error: 'Not found' });
            
            // 이미지 파일 삭제
            try {
                await fs.unlink(path.join('./images/', `${englishName}.png`));
            } catch (error) {
                console.warn('이미지 파일 삭제 실패:', error);
            }
            
            // 데이터에서 제거
            people.splice(personIndex, 1);
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }
        
        res.json({ success: true, message: '삭제되었습니다.' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// people.json → words.js, images.json, index.html 동기화
async function syncLegacyFilesFromPeople() {
    const people = JSON.parse(await fs.readFile(PEOPLE_PATH, 'utf8'));
    // words.js
    const words = people.map(p => `    "${p.englishName}"`).join(',\n');
    const texts = people.map(p => `    "${p.koreanName}"`).join(',\n');
    const wordsJs = `export function shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}\nexport const originWords = [\n${words}\n];\n\nexport const originTexts = [\n${texts}\n];\n`;
    await fs.writeFile('./words.js', wordsJs, 'utf8');
    // images.json
    const images = people.map(p => p.imageFile);
    await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');
    // index.html (숨겨진 이미지 태그 영역만 동기화)
    let html = await fs.readFile('./index.html', 'utf8');
    html = html.replace(/(<div style="display: none;">)[\s\S]*?(<\/div>)/, (m, p1, p2) => {
        const tags = people.map(p => `    <img src="images/${p.imageFile}" alt="">`).join('\n');
        return `${p1}\n${tags}\n${p2}`;
    });
    await fs.writeFile('./index.html', html, 'utf8');
}

// people.json → Firestore/Storage 마이그레이션 함수
async function migratePeopleToFirebase() {
    if (!firebase || !firebase.db || !firebase.bucket) {
        console.log('Firebase가 설정되지 않아 마이그레이션을 건너뜁니다.');
        return;
    }
    
    try {
        const people = JSON.parse(await fs.readFile(PEOPLE_PATH, 'utf8'));
        for (const person of people) {
            // 1. 이미지 파일 Storage 업로드
            const localImagePath = path.join('./images/', person.imageFile);
            const storageFile = firebase.bucket.file(`images/${person.imageFile}`);
            await storageFile.save(await fs.readFile(localImagePath), {
                metadata: { contentType: 'image/png' }
            });
            // 2. public URL 생성
            const imageUrl = `https://storage.googleapis.com/${firebase.bucket.name}/images/${person.imageFile}`;
            // 3. Firestore에 저장
            await firebase.db.collection('people').doc(person.englishName).set({
                ...person,
                imageUrl
            });
            console.log(`마이그레이션 완료: ${person.englishName}`);
        }
    } catch (error) {
        console.error('마이그레이션 실패:', error);
        throw error;
    }
}

// people.json → Firebase 마이그레이션 API (관리자만 사용)
app.post('/api/migrate/people-to-firebase', async (req, res) => {
    try {
        await migratePeopleToFirebase();
        res.json({ success: true, message: '마이그레이션 완료' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// CSV 파일 업로드를 위한 multer 설정
const csvUpload = multer({
    storage: multer.memoryStorage(), // 메모리 스토리지 사용
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB 제한
    fileFilter: (req, file, cb) => {
        const allowedTypes = ['text/csv', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'];
        if (allowedTypes.includes(file.mimetype) || file.originalname.endsWith('.csv')) {
            cb(null, true);
        } else {
            cb(new Error('CSV 또는 Excel 파일만 업로드 가능합니다.'), false);
        }
    }
});

// 벌크 업로드 API
app.post('/api/people/bulk-upload', csvUpload.single('csvFile'), async (req, res) => {
    try {
        const file = req.file;
        const { conflictMode = 'skip' } = req.body;

        if (!file) {
            return res.status(400).json({ error: '파일이 필요합니다.' });
        }

        // CSV 파싱
        let csvData;
        try {
            // BOM 제거 및 CSV 파싱
            let csvContent = file.buffer.toString('utf-8');
            // UTF-8 BOM 제거
            if (csvContent.charCodeAt(0) === 0xFEFF) {
                csvContent = csvContent.slice(1);
            }
            
            csvData = parse(csvContent, {
                columns: true,
                skip_empty_lines: true,
                trim: true
            });
        } catch (parseError) {
            return res.status(400).json({ error: 'CSV 파일 파싱에 실패했습니다: ' + parseError.message });
        }

        if (!csvData || csvData.length === 0) {
            return res.status(400).json({ error: '데이터가 없습니다.' });
        }

        // 필수 컬럼 확인
        const requiredColumns = ['한글이름', '영문이름'];
        const firstRow = csvData[0];
        const missingColumns = requiredColumns.filter(col => !(col in firstRow));
        
        if (missingColumns.length > 0) {
            return res.status(400).json({ 
                error: `필수 컬럼이 누락되었습니다: ${missingColumns.join(', ')}` 
            });
        }

        const results = {
            total: csvData.length,
            success: 0,
            failed: 0,
            skipped: 0,
            errors: []
        };

        // Firebase 또는 로컬 파일시스템에 따라 처리
        if (firebase && firebase.db) {
            // Firebase 처리
            updateProgress('processing', '사용자 데이터 처리 중...', 30, {
                totalEntries: csvData.length,
                processedEntries: 0
            });
            
            for (let i = 0; i < csvData.length; i++) {
                // 진행 상황 업데이트 (30% ~ 70% 범위에서)
                const currentProgress = 30 + Math.floor((i / csvData.length) * 40);
                updateProgress('processing', `사용자 ${i + 1}/${csvData.length} 처리 중...`, currentProgress, {
                    totalEntries: csvData.length,
                    processedEntries: i,
                    currentUser: csvData[i]['영문이름'] || csvData[i]['한글이름'] || 'Unknown'
                });
                
                const row = csvData[i];
                try {
                    const personData = {
                        koreanName: row['한글이름'] || '',
                        englishName: row['영문이름'] || '',
                        organization: row['조직'] || '',
                        role: row['직무'] || '',
                        position: row['직위'] || '',
                        email: row['이메일'] || '',
                        imageUrl: ''
                    };

                    // 영문 이름 유효성 검사
                    if (!personData.englishName) {
                        results.failed++;
                        results.errors.push(`행 ${i + 2}: 영문이름이 필요합니다.`);
                        continue;
                    }

                    // 중복 확인
                    const existingDoc = await firebase.db.collection('people').doc(personData.englishName).get();
                    
                    if (existingDoc.exists && conflictMode === 'skip') {
                        results.skipped++;
                        continue;
                    }

                    // Firestore에 저장
                    await firebase.db.collection('people').doc(personData.englishName).set(personData);
                    results.success++;
                } catch (error) {
                    results.failed++;
                    results.errors.push(`행 ${i + 2}: ${error.message}`);
                }
            }

            // 레거시 파일 동기화
            await syncLegacyFilesFromFirestore();
        } else {
            // 로컬 파일시스템 처리
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                // 파일이 없으면 빈 배열로 시작
            }

            for (let i = 0; i < csvData.length; i++) {
                const row = csvData[i];
                try {
                    const personData = {
                        koreanName: row['한글이름'] || '',
                        englishName: row['영문이름'] || '',
                        organization: row['조직'] || '',
                        role: row['직무'] || '',
                        position: row['직위'] || '',
                        email: row['이메일'] || '',
                        imageFile: `${row['영문이름']}.png`
                    };

                    // 영문 이름 유효성 검사
                    if (!personData.englishName) {
                        results.failed++;
                        results.errors.push(`행 ${i + 2}: 영문이름이 필요합니다.`);
                        continue;
                    }

                    // 중복 확인
                    const existingIndex = people.findIndex(p => p.englishName === personData.englishName);
                    
                    if (existingIndex !== -1 && conflictMode === 'skip') {
                        results.skipped++;
                        continue;
                    }

                    if (existingIndex !== -1) {
                        // 덮어쓰기
                        people[existingIndex] = { ...people[existingIndex], ...personData };
                    } else {
                        // 새로 추가
                        people.push(personData);
                    }
                    
                    results.success++;
                } catch (error) {
                    results.failed++;
                    results.errors.push(`행 ${i + 2}: ${error.message}`);
                }
            }

            // people.json 파일 저장
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }

        res.json({
            success: true,
            message: '벌크 업로드가 완료되었습니다.',
            results
        });

    } catch (error) {
        console.error('벌크 업로드 에러:', error);
        res.status(500).json({ error: '벌크 업로드 중 오류가 발생했습니다: ' + error.message });
    }
});

// ZIP 파일을 위한 multer 설정
const zipUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 50 * 1024 * 1024 }, // 50MB 제한
    fileFilter: (req, file, cb) => {
        if (file.mimetype === 'application/zip' || file.originalname.endsWith('.zip')) {
            cb(null, true);
        } else {
            cb(new Error('ZIP 파일만 업로드 가능합니다.'), false);
        }
    }
});

// 진행 상황을 저장할 객체
const uploadProgress = new Map();

// SSE를 위한 진행 상황 스트림 API
app.get('/api/upload-progress/:sessionId', (req, res) => {
    const sessionId = req.params.sessionId;
    
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
    });

    // 즉시 연결 확인 메시지 전송
    res.write(`data: ${JSON.stringify({ type: 'connected', sessionId })}\n\n`);

    // 진행 상황 업데이트를 확인하는 인터벌
    const interval = setInterval(() => {
        const progress = uploadProgress.get(sessionId);
        if (progress) {
            res.write(`data: ${JSON.stringify(progress)}\n\n`);
            
            // 완료되면 세션 정리
            if (progress.type === 'completed' || progress.type === 'error') {
                uploadProgress.delete(sessionId);
                clearInterval(interval);
                res.end();
            }
        }
    }, 100);

    // 클라이언트 연결 종료 처리
    req.on('close', () => {
        clearInterval(interval);
        uploadProgress.delete(sessionId);
    });
});

// ZIP 파일 벌크 업로드 API
app.post('/api/people/bulk-upload-zip', zipUpload.single('zipFile'), async (req, res) => {
    try {
        const file = req.file;
        const { conflictMode = 'skip', sessionId } = req.body;

        if (!file) {
            return res.status(400).json({ error: 'ZIP 파일이 필요합니다.' });
        }

        // 진행 상황 업데이트 함수
        const updateProgress = (type, message, progress = 0, details = {}) => {
            if (sessionId) {
                uploadProgress.set(sessionId, {
                    type,
                    message,
                    progress,
                    timestamp: Date.now(),
                    ...details
                });
            }
        };

        // ZIP 파일 처리
        updateProgress('processing', 'ZIP 파일 분석 중...', 10);
        console.log('ZIP 파일 처리 시작...');
        const zipData = await processZipFile(file.buffer);
        console.log(`ZIP 파일 분석 완료 - CSV: ${zipData.csv ? '있음' : '없음'}, 이미지: ${Object.keys(zipData.images).length}개`);
        console.log('발견된 이미지 파일들:', Object.keys(zipData.images));
        
        updateProgress('processing', 'CSV 데이터 파싱 중...', 20, {
            totalImages: Object.keys(zipData.images).length
        });
        
        if (!zipData.csv) {
            return res.status(400).json({ error: 'ZIP 파일에 CSV 파일이 없습니다.' });
        }

        // CSV 데이터 파싱
        let csvData;
        try {
            // BOM 제거
            let csvContent = zipData.csv;
            if (csvContent.charCodeAt(0) === 0xFEFF) {
                csvContent = csvContent.slice(1);
            }
            
            csvData = parse(csvContent, {
                columns: true,
                skip_empty_lines: true,
                trim: true
            });
        } catch (parseError) {
            return res.status(400).json({ error: 'CSV 파일 파싱에 실패했습니다: ' + parseError.message });
        }

        if (!csvData || csvData.length === 0) {
            return res.status(400).json({ error: '데이터가 없습니다.' });
        }

        // 필수 컬럼 확인
        const requiredColumns = ['한글이름', '영문이름'];
        const firstRow = csvData[0];
        const missingColumns = requiredColumns.filter(col => !(col in firstRow));
        
        if (missingColumns.length > 0) {
            return res.status(400).json({ 
                error: `필수 컬럼이 누락되었습니다: ${missingColumns.join(', ')}` 
            });
        }

        const results = {
            total: csvData.length,
            success: 0,
            failed: 0,
            skipped: 0,
            errors: []
        };

        // Firebase 또는 로컬 파일시스템에 따라 처리
        if (firebase && firebase.db) {
            // Firebase 처리
            updateProgress('processing', '사용자 데이터 처리 중...', 30, {
                totalEntries: csvData.length,
                processedEntries: 0
            });
            
            for (let i = 0; i < csvData.length; i++) {
                // 진행 상황 업데이트 (30% ~ 70% 범위에서)
                const currentProgress = 30 + Math.floor((i / csvData.length) * 40);
                updateProgress('processing', `사용자 ${i + 1}/${csvData.length} 처리 중...`, currentProgress, {
                    totalEntries: csvData.length,
                    processedEntries: i,
                    currentUser: csvData[i]['영문이름'] || csvData[i]['한글이름'] || 'Unknown'
                });
                
                const row = csvData[i];
                try {
                    const personData = {
                        koreanName: row['한글이름'] || '',
                        englishName: row['영문이름'] || '',
                        organization: row['조직'] || '',
                        role: row['직무'] || '',
                        position: row['직위'] || '',
                        email: row['이메일'] || '',
                        imageUrl: ''
                    };

                    if (!personData.englishName) {
                        results.failed++;
                        results.errors.push(`행 ${i + 2}: 영문이름이 필요합니다.`);
                        continue;
                    }

                    // 중복 확인
                    const existingDoc = await firebase.db.collection('people').doc(personData.englishName).get();
                    
                    if (existingDoc.exists && conflictMode === 'skip') {
                        results.skipped++;
                        continue;
                    }

                    // 이미지 처리
                    const imageKey = `${personData.englishName}.png`;
                    const imageKeyJpg = `${personData.englishName}.jpg`;
                    const imageKeyJpeg = `${personData.englishName}.jpeg`;
                    
                    let imageBuffer = null;
                    let imageExt = null;
                    
                    if (zipData.images[imageKey]) {
                        imageBuffer = zipData.images[imageKey];
                        imageExt = 'png';
                    } else if (zipData.images[imageKeyJpg]) {
                        imageBuffer = zipData.images[imageKeyJpg];
                        imageExt = 'jpg';
                    } else if (zipData.images[imageKeyJpeg]) {
                        imageBuffer = zipData.images[imageKeyJpeg];
                        imageExt = 'jpeg';
                    }
                    
                    if (imageBuffer && imageExt) {
                        try {
                            updateProgress('uploading', `이미지 업로드 중: ${personData.englishName}.${imageExt}`, currentProgress + 5, {
                                totalEntries: csvData.length,
                                processedEntries: i,
                                currentUser: personData.englishName,
                                currentAction: 'uploading_image'
                            });
                            
                            console.log(`Firebase에 이미지 업로드 시작: ${personData.englishName}.${imageExt}`);
                            const imageUrl = await uploadImageToFirebase(imageBuffer, `${personData.englishName}.${imageExt}`);
                            personData.imageUrl = imageUrl;
                            console.log(`이미지 업로드 성공: ${personData.englishName} -> ${imageUrl.substring(0, 100)}...`);
                        } catch (imageError) {
                            console.error(`이미지 업로드 실패: ${personData.englishName} -`, imageError.message);
                            results.errors.push(`행 ${i + 2}: 이미지 업로드 실패 - ${imageError.message}`);
                        }
                    } else {
                        console.log(`이미지를 찾을 수 없음: ${personData.englishName} (찾은 이미지: ${Object.keys(zipData.images).join(', ')})`);
                    }

                    // Firestore에 저장
                    await firebase.db.collection('people').doc(personData.englishName).set(personData);
                    results.success++;
                } catch (error) {
                    results.failed++;
                    results.errors.push(`행 ${i + 2}: ${error.message}`);
                }
            }

            // 레거시 파일 동기화
            await syncLegacyFilesFromFirestore();
        } else {
            // 로컬 파일시스템 처리
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                // 파일이 없으면 빈 배열로 시작
            }

            for (let i = 0; i < csvData.length; i++) {
                const row = csvData[i];
                try {
                    const personData = {
                        koreanName: row['한글이름'] || '',
                        englishName: row['영문이름'] || '',
                        organization: row['조직'] || '',
                        role: row['직무'] || '',
                        position: row['직위'] || '',
                        email: row['이메일'] || '',
                        imageFile: `${row['영문이름']}.png`
                    };

                    if (!personData.englishName) {
                        results.failed++;
                        results.errors.push(`행 ${i + 2}: 영문이름이 필요합니다.`);
                        continue;
                    }

                    // 중복 확인
                    const existingIndex = people.findIndex(p => p.englishName === personData.englishName);
                    
                    if (existingIndex !== -1 && conflictMode === 'skip') {
                        results.skipped++;
                        continue;
                    }

                    // 이미지 처리
                    const imageKey = `${personData.englishName}.png`;
                    const imageKeyJpg = `${personData.englishName}.jpg`;
                    const imageKeyJpeg = `${personData.englishName}.jpeg`;
                    
                    let imageBuffer = null;
                    let imageExt = null;
                    
                    if (zipData.images[imageKey]) {
                        imageBuffer = zipData.images[imageKey];
                        imageExt = 'png';
                    } else if (zipData.images[imageKeyJpg]) {
                        imageBuffer = zipData.images[imageKeyJpg];
                        imageExt = 'jpg';
                    } else if (zipData.images[imageKeyJpeg]) {
                        imageBuffer = zipData.images[imageKeyJpeg];
                        imageExt = 'jpeg';
                    }
                    
                    if (imageBuffer && imageExt) {
                        try {
                            // 로컬 이미지 저장
                            const imagePath = `./images/${personData.englishName}.${imageExt}`;
                            await fs.writeFile(imagePath, imageBuffer);
                            personData.imageFile = `${personData.englishName}.${imageExt}`;
                            console.log(`이미지 저장 성공: ${imagePath}`);
                        } catch (imageError) {
                            console.error(`이미지 저장 실패: ${personData.englishName} -`, imageError.message);
                            results.errors.push(`행 ${i + 2}: 이미지 저장 실패 - ${imageError.message}`);
                        }
                    } else {
                        console.log(`이미지를 찾을 수 없음: ${personData.englishName} (찾은 이미지: ${Object.keys(zipData.images).join(', ')})`);
                    }

                    if (existingIndex !== -1) {
                        // 덮어쓰기
                        people[existingIndex] = { ...people[existingIndex], ...personData };
                    } else {
                        // 새로 추가
                        people.push(personData);
                    }
                    
                    results.success++;
                } catch (error) {
                    results.failed++;
                    results.errors.push(`행 ${i + 2}: ${error.message}`);
                }
            }

            // people.json 파일 저장
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }

        // 완료 상태 업데이트
        updateProgress('completed', 'ZIP 파일 업로드가 완료되었습니다.', 100, {
            totalEntries: results.total,
            successCount: results.success,
            failedCount: results.failed,
            skippedCount: results.skipped
        });

        res.json({
            success: true,
            message: 'ZIP 파일 업로드가 완료되었습니다.',
            results
        });

    } catch (error) {
        console.error('ZIP 업로드 에러:', error);
        
        // 오류 상태 업데이트
        updateProgress('error', 'ZIP 업로드 중 오류가 발생했습니다.', 0, {
            errorMessage: error.message
        });
        
        res.status(500).json({ error: 'ZIP 업로드 중 오류가 발생했습니다: ' + error.message });
    }
});

// ZIP 파일 처리 함수
async function processZipFile(zipBuffer) {
    return new Promise((resolve, reject) => {
        const zipData = {
            csv: null,
            images: {}
        };

        yauzl.fromBuffer(zipBuffer, { lazyEntries: true }, (err, zipfile) => {
            if (err) {
                reject(new Error('ZIP 파일을 읽을 수 없습니다: ' + err.message));
                return;
            }

            let processedEntries = 0;
            let allEntries = [];

            // 먼저 모든 엔트리를 수집
            zipfile.on('entry', (entry) => {
                console.log(`ZIP 엔트리 발견: ${entry.fileName} (디렉토리: ${/\/$/.test(entry.fileName)})`);
                allEntries.push(entry);
                zipfile.readEntry(); // 다음 엔트리 읽기
            });

            zipfile.on('end', () => {
                console.log(`총 ${allEntries.length}개의 엔트리 발견`);
                
                if (allEntries.length === 0) {
                    resolve(zipData);
                    return;
                }

                // 모든 엔트리를 순차적으로 처리
                let currentIndex = 0;
                
                const processNextEntry = () => {
                    if (currentIndex >= allEntries.length) {
                        console.log('모든 ZIP 엔트리 처리 완료');
                        resolve(zipData);
                        return;
                    }

                    const entry = allEntries[currentIndex];
                    currentIndex++;
                    
                    if (/\/$/.test(entry.fileName)) {
                        // 디렉토리는 건너뛰기
                        console.log(`디렉토리 건너뜀: ${entry.fileName}`);
                        processNextEntry();
                        return;
                    }

                    console.log(`파일 처리 시작: ${entry.fileName}`);
                    zipfile.openReadStream(entry, (err, readStream) => {
                        if (err) {
                            reject(new Error(`파일을 읽을 수 없습니다: ${entry.fileName}`));
                            return;
                        }

                        const chunks = [];
                        readStream.on('data', (chunk) => {
                            chunks.push(chunk);
                        });

                        readStream.on('end', () => {
                            const buffer = Buffer.concat(chunks);
                            const fileName = path.basename(entry.fileName);
                            console.log(`파일 처리 완료: ${fileName} (전체 경로: ${entry.fileName}, 크기: ${buffer.length})`);

                            // CSV 파일 처리
                            if (fileName.toLowerCase().endsWith('.csv')) {
                                zipData.csv = buffer.toString('utf-8');
                                console.log(`CSV 파일 로드: ${fileName}`);
                            }
                            // 이미지 파일 처리 (경로에 관계없이 파일명만 사용)
                            else if (/\.(png|jpg|jpeg)$/i.test(fileName)) {
                                zipData.images[fileName] = buffer;
                                console.log(`이미지 파일 발견: ${fileName} (${entry.fileName}) - ${buffer.length} bytes`);
                            } else {
                                console.log(`알 수 없는 파일 형식: ${fileName}`);
                            }

                            // 다음 엔트리 처리
                            processNextEntry();
                        });

                        readStream.on('error', (err) => {
                            reject(new Error(`파일 읽기 오류: ${entry.fileName} - ${err.message}`));
                        });
                    });
                };

                // 첫 번째 엔트리부터 처리 시작
                processNextEntry();
            });

            zipfile.on('error', (err) => {
                reject(new Error('ZIP 파일 처리 오류: ' + err.message));
            });

            // 첫 번째 엔트리 읽기 시작
            zipfile.readEntry();
        });
    });
}

// Firebase Storage에 이미지 업로드 함수
async function uploadImageToFirebase(imageBuffer, fileName) {
    if (!firebase || !firebase.bucket) {
        throw new Error('Firebase Storage가 설정되지 않았습니다.');
    }

    try {
        const bucket = firebase.bucket;
        const file = bucket.file(`images/${fileName}`);
        
        await file.save(imageBuffer, {
            metadata: {
                contentType: fileName.endsWith('.png') ? 'image/png' : 'image/jpeg'
            }
        });

        // 서명된 URL 생성 (1년 유효)
        const [url] = await file.getSignedUrl({
            action: 'read',
            expires: '12-31-2030'
        });

        return url;
    } catch (error) {
        throw new Error(`이미지 업로드 실패: ${fileName} - ${error.message}`);
    }
}

// 에러 핸들링 미들웨어
app.use((error, req, res, next) => {
  console.error('서버 에러:', error);
  
  if (error.code === 'LIMIT_FILE_SIZE') {
    return res.status(400).json({ 
      error: `파일 크기가 너무 큽니다. 최대 ${maxFileSize / (1024 * 1024)}MB까지 업로드 가능합니다.` 
    });
  }
  
  if (error.message.includes('지원하지 않는 파일 타입')) {
    return res.status(400).json({ 
      error: error.message 
    });
  }
  
  res.status(500).json({ 
    error: process.env.NODE_ENV === 'production' ? '서버 내부 오류가 발생했습니다.' : error.message 
  });
});

// 404 핸들러
app.use((req, res) => {
  res.status(404).json({ error: '요청한 리소스를 찾을 수 없습니다.' });
});

// 서버 실행 (직접 실행할 때만 listen)
if (require.main === module) {
    app.listen(PORT, () => {
        console.log(`🚀 서버가 http://localhost:${PORT} 에서 실행 중입니다.`);
        console.log(`📊 관리자 페이지: http://localhost:${PORT}/admin.html`);
        console.log(`🏠 메인 페이지: http://localhost:${PORT}/index.html`);
        console.log(`🔒 환경: ${process.env.NODE_ENV || 'development'}`);
        console.log(`🌐 CORS 허용 도메인: ${process.env.ALLOWED_ORIGINS || 'http://localhost:3000'}`);
        console.log(`📁 파일 업로드 제한: ${maxFileSize / (1024 * 1024)}MB, 타입: ${allowedFileTypes.join(', ')}`);
    });
}

// 테스트용 app 객체 export
module.exports = app;
</file>

<file path="words.js">
export function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}
export const originWords = [
    "AhnHyeonseo",
    "BaeJisu",
    "BaeSeongmin",
    "BaeYounchan",
    "ChaeSeoungpyo",
    "ChoWonjun",
    "ChoYounjin",
    "ChoYuhjung",
    "ChoiJunyong",
    "ChoiMinki",
    "ChoiSeungjin",
    "ChoiSoowan",
    "ChoiWoosik",
    "ChungAyun",
    "ChungSewook",
    "GuHeesub",
    "HaMinu",
    "HanHyangryeon",
    "HanSejin",
    "HanSol",
    "HongHyebin",
    "HwangHeetae",
    "HwangInsun",
    "HwangJina",
    "InSubin",
    "JangBeomseok",
    "JangEunJung",
    "JangHayoung",
    "JangIlgoo",
    "JangSeonhui",
    "JangSojin",
    "JeonAreum",
    "JeonJinhee",
    "JeonSeoyoung",
    "JeonSuhong",
    "JeongDaekyo",
    "JeongHyeonjeong",
    "JisueKim",
    "JungHajin",
    "JungMinji",
    "JungMinjung",
    "JungSujin",
    "JungSunghwa",
    "KangBumin",
    "KangDongho",
    "KimDeokHyeon",
    "KimDongwook",
    "KimEeseul",
    "KimEunwoo",
    "KimHajung",
    "KimHanna",
    "KimHyogyeong",
    "KimInhwan",
    "KimJieun",
    "KimJihyeon",
    "KimJungsun",
    "KimJungyu",
    "KimMina",
    "KimMinjoong",
    "KimNamkyun",
    "KimNuri",
    "KimSohie",
    "KimSuhyun",
    "KimSuyeon",
    "KimWoosuk",
    "KwonSoyeon",
    "LeeAeri",
    "LeeDahye",
    "LeeEuntaeg",
    "LeeJinho",
    "LeeJongmin",
    "LeeJungki",
    "LeeKihoon",
    "LeeMinuk",
    "LeeMyeonggyu",
    "LeeMyungeun",
    "LeeSeungmin",
    "LeeWoojeong",
    "LeeYejin",
    "LeeYujeong",
    "LimYongdae",
    "MinKyoungeun",
    "MoonJihee",
    "MoonKyunghyuk",
    "NohKyeongrae",
    "OSongmin",
    "OhChaewon",
    "OhHayun",
    "ParkDongsoo",
    "ParkGiwoong",
    "ParkHyoungil",
    "PyoGaeun",
    "SeoSangwoo",
    "SeoSeok",
    "SeonMyeonho",
    "ShinHyokyeong",
    "ShinHyunjun",
    "ShinSangseop",
    "SimYukyoung",
    "SonJungmin",
    "SongGawon",
    "SongJinkyu",
    "SongJunseong",
    "SunHaeun",
    "SungSeungyeon",
    "WooKyungmin",
    "YoonMyoungjune",
    "YoonSubin",
    "YounYounsong",
    "YunSuyoung"
];

export const originTexts = [
    "안현서",
    "배지수",
    "배성민",
    "배윤찬",
    "채승표",
    "조원준",
    "조윤진",
    "조여정",
    "최준용",
    "최민기",
    "최승진",
    "최수완",
    "최우식",
    "정아윤",
    "정세욱",
    "구희섭",
    "하민우",
    "한향련",
    "한세진",
    "한솔",
    "홍혜빈",
    "황희태",
    "황인선",
    "황진아",
    "인수빈",
    "장범석",
    "장은정",
    "장하영",
    "장일구",
    "장선희",
    "장소진",
    "전아름",
    "전진희",
    "전서영",
    "전수홍",
    "정대교",
    "정현정",
    "김지수",
    "정하진",
    "정민지",
    "정민정",
    "정수진",
    "정성화",
    "강부민",
    "강동호",
    "김덕현",
    "김동욱",
    "김이슬",
    "김은우",
    "김하정",
    "김한나",
    "김효경",
    "김인환",
    "김지은",
    "김지현",
    "김정선",
    "김준규",
    "김민아",
    "김민중",
    "김남균",
    "김누리",
    "김소희",
    "김수현",
    "김수연",
    "김우석",
    "권소연",
    "이애리",
    "이다혜",
    "이은택",
    "이진호",
    "이종민",
    "이정기",
    "이기훈",
    "이민욱",
    "이명규",
    "이명은",
    "이승민",
    "이우정",
    "이예진",
    "이유정",
    "임용대",
    "민경은",
    "문지희",
    "문경혁",
    "노경래",
    "오송민",
    "오채원",
    "오하윤",
    "박동수",
    "박기웅",
    "박형일",
    "표가은",
    "서상우",
    "서석",
    "선면호",
    "신효경",
    "신현준",
    "신상섭",
    "심유경",
    "손정민",
    "송가원",
    "송진규",
    "송준성",
    "선하은",
    "성승연",
    "우경민",
    "윤명준",
    "윤수빈",
    "윤윤성",
    "윤수영"
];
</file>

<file path="Particle.js">
// 최적화된 Particle.js
const easeInOutQuart = (t) => {
    return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
}

const easeInOutQuartModified = (t) => {
    if (t < 0.5) {
        return 1 - Math.pow(1 - (2 * t), 3);
    } else {
        return 1 - Math.pow(-2 * t + 2, 5) / 2;
    }
};

// 전역 임시 객체들 - 가비지 컬렉션 방지
const tempPos = { x: 0, y: 0 };
const directions = [0, 1, 2, 3];

const getOutsidePos = (canvasWidth, canvasHeight, reusablePos = tempPos) => {
    const direction = directions[Math.floor(Math.random() * 4)];
    
    switch (direction) {
        case 0: // 위
            reusablePos.x = Math.random() * canvasWidth;
            reusablePos.y = -1000;
            break;
        case 1: // 아래
            reusablePos.x = Math.random() * canvasWidth;
            reusablePos.y = canvasHeight + 1000;
            break;
        case 2: // 왼쪽
            reusablePos.x = -1000;
            reusablePos.y = Math.random() * canvasHeight;
            break;
        case 3: // 오른쪽
            reusablePos.x = canvasWidth + 1000;
            reusablePos.y = Math.random() * canvasHeight;
            break;
    }
    return { x: reusablePos.x, y: reusablePos.y };
}

const getRandomPos = (target, reusablePos = tempPos) => {
    const direction = directions[Math.floor(Math.random() * 4)];
    const rand1 = Math.random() * 100 - 50; // -50 ~ +50
    const rand2 = Math.random() * 100;      // 0 ~ 100

    switch (direction) {
        case 0: // 위
            reusablePos.x = target.x + rand1;
            reusablePos.y = target.y - rand2;
            break;
        case 1: // 아래
            reusablePos.x = target.x + rand1;
            reusablePos.y = target.y + rand2;
            break;
        case 2: // 왼쪽
            reusablePos.x = target.x - rand2;
            reusablePos.y = target.y + rand1;
            break;
        case 3: // 오른쪽
            reusablePos.x = target.x + rand2;
            reusablePos.y = target.y + rand1;
            break;
    }
    return { x: reusablePos.x, y: reusablePos.y };
}

class Particle {
    constructor(x, y, color, canvasWidth, canvasHeight, stepPixel) {
        // 객체 생성 최소화 - 직접 프로퍼티 할당
        this.target = { x: x, y: y };
        this.color = { r: color.r, g: color.g, b: color.b };
        this.pos = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        
        // 계산 결과 캐싱
        this.brightness = 0;
        this.size = 0;
        this.targetSize = 0;
        this.atTarget = false;
        this.exploding = false;
        this.isActive = true;
        
        // 타이밍 관련
        this.startTime = 0;
        this.duration = 0;
        
        // 성능 최적화용 플래그
        this.needsUpdate = true;
        this.lastUpdateTime = 0;
        
        // 물리 속성 (폭발 시 설정)
        this.mass = 1.0; // 질량 (사이즈에 따라 결정)
        this.gravityFactor = 1.0; // 중력 계수
        this.airResistance = 0.98; // 공기 저항 계수
        this.initialY = 0; // 초기 Y 위치 저장용
        
        // 2단계 애니메이션 관리
        this.phase = 'falling'; // 'falling' | 'sizing'
        this.positionComplete = false; // 위치 이동 완료 여부
        this.sizingStartTime = 0; // 사이즈 조정 시작 시간
        this.maxSize = 0; // 최대 사이즈 저장
        
        this.reset(x, y, color, canvasWidth, canvasHeight, stepPixel);
    }

    reset(x, y, color, canvasWidth, canvasHeight, stepPixel) {
        // 타겟 위치 설정
        this.target.x = x;
        this.target.y = y;
        
        // 색상 설정 (흰색으로 고정)
        this.color = { r: 255, g: 255, b: 255 };
        
        // 밝기 계산 및 크기 설정
        this.brightness = (color.r + color.g + color.b) / 3;
        this.targetSize = Math.max(stepPixel * ((1 - (this.brightness / 255)) * 0.8), stepPixel * 0.2);
        this.size = 0;
        
        // 속도 초기화
        this.velocity.x = 0;
        this.velocity.y = 0;
        
        // 시작 위치 설정 (상단에서 떨어지는 모래 효과)
        this.pos.x = x + (Math.random() - 0.5) * 200; // 더 넓은 범위에서 시작
        this.initialY = -400 - (Math.random() * 600); // 훨씬 높은 곳에서 시작
        this.pos.y = this.initialY; // 화면 상단 위에서 시작
        
        // 드라마틱한 효과를 위한 추가 속성
        this.initialX = this.pos.x; // 초기 X 위치 저장
        this.swayAmount = (Math.random() - 0.5) * 3; // 떨어지며 흔들리는 정도
        this.rotationSpeed = (Math.random() - 0.5) * 0.3; // 회전 속도
        this.currentRotation = 0; // 현재 회전각
        
        // 상태 초기화
        this.atTarget = false;
        this.exploding = false;
        this.isActive = true;
        this.needsUpdate = true;
        
        // 2단계 애니메이션 초기화
        this.phase = 'falling';
        this.positionComplete = false;
        this.sizingStartTime = 0;
        this.maxSize = Math.max(stepPixel * 0.2, this.targetSize * 0.2); // 최대 사이즈 설정
        
        // 타이밍 설정 (더 랜덤하고 넓은 간격)
        const fallHeight = Math.abs(this.pos.y - y); // 떨어져야 하는 거리
        const baseHeightDelay = (canvasHeight - y) * 1.5; // 하단부터 기본 지연
        const randomDelay = Math.random() * 1500; // 큰 랜덤 지연 (0-1.5초)
        const extraRandomDelay = Math.random() * Math.random() * 2000; // 이중 랜덤으로 더 불규칙하게
        
        this.startTime = performance.now() + baseHeightDelay + randomDelay + extraRandomDelay;
        
        // 듀레이션도 더 길고 랜덤하게
        const baseDuration = 2500 + (fallHeight / canvasHeight) * 1500; // 기본 듀레이션 증가
        const randomDurationVariation = (Math.random() - 0.5) * 1000; // ±0.5초 변화
        this.duration = baseDuration + randomDurationVariation;
        this.lastUpdateTime = 0;
    }

    update(currentTime) {
        // 기존 스킵 로직 제거 - 매 프레임마다 업데이트 허용
        
        if (!this.exploding) {
            const timeElapsed = (currentTime - this.startTime) / this.duration;
            const progress = Math.min(Math.max(timeElapsed, 0), 1);
            
            // 낙엽이 쌓이는 듯한 부드러운 효과
            if (progress > 0) {
                // 낙엽처럼 자연스러운 낙하 곡선 - 처음 가속 후 공기저항으로 서서히 감속
                const naturalFallProgress = progress < 0.7 ? 
                    Math.pow(progress, 0.8) : // 70%까지 부드러운 가속
                    Math.pow(0.7, 0.8) + (1 - Math.pow(0.7, 0.8)) * (1 - Math.pow(1 - (progress - 0.7) / 0.3, 2)); // 70% 이후 점진적 감속
                
                // 수평 이동도 동일한 곡선 적용
                const horizontalProgress = naturalFallProgress;
                
                // 낙엽처럼 좌우로 부드럽게 흔들리는 효과
                const swayIntensity = Math.sin(progress * Math.PI * 1.5 + this.swayAmount) * this.swayAmount * 12;
                const leafSway = swayIntensity * (1 - Math.pow(progress, 1.2)); // 착지할수록 흔들림 자연스럽게 감소
                
                // 회전도 자연스럽게 감소 - 낙엽이 바닥에 가까워질수록 회전 느려짐
                const rotationIntensity = (1 - Math.pow(progress, 1.2));
                this.currentRotation += this.rotationSpeed * 0.4 * rotationIntensity;
                
                // 수평 위치 + 낙엽 흔들림 효과
                const baseX = this.target.x * horizontalProgress + this.initialX * (1 - horizontalProgress);
                this.pos.x = baseX + leafSway;
                
                // 수직 위치 - 자연스러운 낙하
                const fallDistance = this.target.y - this.initialY;
                this.pos.y = this.initialY + (fallDistance * naturalFallProgress);
                
                // 크기 변화 - 떨어지기 시작할 때부터 도착까지 점진적으로 증가
                const sizeProgress = Math.pow(progress, 1.1); // 자연스럽게 증가
                
                this.size = this.maxSize + (this.targetSize - this.maxSize) * sizeProgress;
            }
            
            if (timeElapsed >= 1) {
                this.pos.x = this.target.x;
                this.pos.y = this.target.y;
                this.size = this.targetSize;
                this.atTarget = true;
                this.needsUpdate = false;
            }
        } else {
            // 폭발 로직 (사이즈별 차별화된 중력 효과)
            this.velocity.x *= this.airResistance; // 공기 저항 (개별 설정)
            this.velocity.y += this.gravityFactor; // 중력 효과 (사이즈별 차별화)
            this.pos.x += this.velocity.x;
            this.pos.y += this.velocity.y;
            this.size -= 0.05;
            
            if (this.size <= 0) {
                this.size = 0;
                this.isActive = false;
                this.needsUpdate = false;
            }
            
            // 속도가 매우 작아지면 비활성화
            if (Math.abs(this.velocity.x) < 0.1 && Math.abs(this.velocity.y) < 0.1) {
                this.isActive = false;
                this.needsUpdate = false;
            }
        }
    }

    // 최적화된 draw 메서드 (회전 효과 포함)
    draw(ctx) {
        if (this.size <= 0) return;
        
        const halfSize = this.size * 0.5;
        const x = this.pos.x;
        const y = this.pos.y;
        
        // 회전 효과가 있는 경우
        if (this.currentRotation !== 0 && !this.atTarget) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.currentRotation);
            ctx.fillStyle = `rgb(${this.color.r},${this.color.g},${this.color.b})`;
            ctx.fillRect(-halfSize, -halfSize, this.size, this.size);
            ctx.restore();
        } else {
            // 기본 렌더링
            ctx.fillStyle = `rgb(${this.color.r},${this.color.g},${this.color.b})`;
            ctx.fillRect(x - halfSize, y - halfSize, this.size, this.size);
        }
    }

    isAtTarget() {
        return this.atTarget;
    }

    explode() {
        this.exploding = true;
        this.needsUpdate = true;
        this.isActive = true;
        
        // 사이즈에 따른 물리 속성 설정
        this.mass = this.size / 10; // 사이즈에 비례한 질량
        
        // 큰 파티클: 빠르게 떨어짐, 작은 파티클: 천천히 떨어짐
        const sizeRatio = this.size / 20; // 사이즈 비율 (일반적으로 0.5-2.0)
        this.gravityFactor = 0.3 + (sizeRatio * 0.4) + (Math.random() * 0.2 - 0.1); // 0.2-0.9 + 랜덤
        
        // 공기 저항도 사이즈에 따라 조정 (큰 파티클은 저항이 적음)
        this.airResistance = 0.98 - (sizeRatio * 0.05) + (Math.random() * 0.02 - 0.01); // 0.93-0.99 + 랜덤
        
        // 폭발 속도 설정 (사이즈에 따라 차별화)
        const randX = Math.random() - 0.5;
        const randY = Math.random() - 0.5;
        const speedMultiplier = 1 + (sizeRatio * 0.5) + (Math.random() * 0.3 - 0.15); // 랜덤 속도 변화
        this.velocity.x = randX * 3 * speedMultiplier;
        this.velocity.y = randY * 2 * speedMultiplier;
    }
}

export default Particle;
</file>

<file path="admin.css">
/* 기본 스타일 */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background-color: #f5f7fa;
    color: #2c3e50;
    line-height: 1.6;
    font-size: 14px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

/* 헤더 */
.header {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.header h1 {
    color: #2c3e50;
    font-size: 28px;
    font-weight: 700;
    letter-spacing: -0.5px;
    margin: 0;
}

.header-actions {
    display: flex;
    gap: 10px;
}

/* 메인 콘텐츠 */
.main-content {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 20px;
}

/* 패널 공통 스타일 */
.panel {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 20px;
    margin-bottom: 20px;
}

.panel h2 {
    color: #2c3e50;
    margin-bottom: 24px;
    font-size: 20px;
    font-weight: 600;
    border-bottom: 3px solid #3498db;
    padding-bottom: 12px;
    letter-spacing: -0.3px;
}

/* 왼쪽 패널 */
.left-panel {
    display: flex;
    flex-direction: column;
}

/* 폼 스타일 */
.add-form {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.form-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
    min-width: 200px;
}

.form-group label {
    font-weight: 600;
    color: #2c3e50;
    font-size: 14px;
    margin-bottom: 4px;
}

.form-group input[type="text"],
.form-group input[type="email"] {
    padding: 14px 16px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    font-size: 14px;
    transition: all 0.3s ease;
    background-color: #fff;
    line-height: 1.4;
}

.form-group input[type="text"]:focus,
.form-group input[type="email"]:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    transform: translateY(-1px);
}

.form-group input[type="text"]::placeholder,
.form-group input[type="email"]::placeholder {
    color: #6c757d;
    font-style: italic;
}

.form-group input[type="text"]:hover,
.form-group input[type="email"]:hover {
    border-color: #d5dbdb;
}

.form-group input[type="text"]:invalid:not(:placeholder-shown),
.form-group input[type="email"]:invalid:not(:placeholder-shown) {
    border-color: #e74c3c;
    background-color: #fdf2f2;
}

.form-group input[type="text"]:valid:not(:placeholder-shown),
.form-group input[type="email"]:valid:not(:placeholder-shown) {
    border-color: #27ae60;
    background-color: #f8fff8;
}

.input-with-button {
    display: flex;
    gap: 10px;
}

.input-with-button input {
    flex: 1;
}

/* 드래그 앤 드롭 영역 */
.drag-drop-area {
    border: 2px dashed #bdc3c7;
    border-radius: 12px;
    padding: 40px 20px;
    max-width: 280px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    position: relative;
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.drag-drop-area:hover {
    border-color: #3498db;
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(52, 152, 219, 0.2);
}

.drag-drop-area.dragover {
    border-color: #3498db;
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    transform: scale(1.02);
}

.drag-drop-area p {
    color: #5a6c7d;
    margin: 0;
    font-size: 14px;
    line-height: 1.5;
    font-weight: 500;
}

.drag-drop-area::before {
    content: "📸";
    font-size: 48px;
    margin-bottom: 15px;
    opacity: 0.7;
    display: block;
}

/* 버튼 스타일 */
.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    position: relative;
    overflow: hidden;
    min-height: 44px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-primary {
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    color: white;
}

.btn-primary:hover {
    background: linear-gradient(135deg, #2980b9 0%, #1f5f8b 100%);
}

.btn-secondary {
    background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
    color: white;
}

.btn-secondary:hover {
    background: linear-gradient(135deg, #7f8c8d 0%, #566165 100%);
}

.btn-danger {
    background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    color: white;
}

.btn-danger:hover {
    background: linear-gradient(135deg, #c0392b 0%, #922b21 100%);
}

.btn-small {
    padding: 8px 16px;
    font-size: 12px;
    min-height: 36px;
}

.btn-large {
    padding: 18px 36px;
    font-size: 16px;
    font-weight: bold;
    width: 100%;
    margin-bottom: 20px;
    min-height: 52px;
}

.btn-success {
    background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
    color: white;
}

.btn-success:hover {
    background: linear-gradient(135deg, #229954 0%, #1e7e34 100%);
}

/* 폼 액션 */
.form-actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

/* 사용법 안내 */
.usage-guide {
    font-size: 14px;
    color: #495057;
    line-height: 1.5;
}

.usage-guide h3 {
    color: #2c3e50;
    margin: 20px 0 10px 0;
    font-size: 17px;
    font-weight: 600;
    letter-spacing: -0.2px;
}

.usage-guide ol {
    margin-left: 20px;
    margin-bottom: 15px;
}

.usage-guide li {
    margin-bottom: 5px;
}

.usage-guide p {
    margin-bottom: 10px;
}

/* 오른쪽 패널 */
.right-panel {
    display: flex;
    flex-direction: column;
}

.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    flex-wrap: wrap;
    gap: 10px;
}

.panel-actions {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
}

.search-input {
    padding: 10px 14px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    font-size: 14px;
    min-width: 200px;
    transition: all 0.3s ease;
    background-color: #fff;
}

.search-input:hover {
    border-color: #d5dbdb;
}

.search-input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    transform: translateY(-1px);
}

/* 항목 컨테이너 */
.items-container {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 기본값 4개 */
    gap: 15px;
    max-height: auto;
    overflow-y: auto;
}

/* 항목 카드 */
.item-card {
    position: relative;
    background: white;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    overflow: hidden;
    transition: all 0.3s;
    cursor: pointer;
    display: flex;
    flex-direction: column;
}

.item-card:hover {
    border-color: #3498db;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.item-card.selected {
    border-color: #3498db;
    background: #e3f2fd;
}

.item-header {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0px;
    background: rgba(255, 255, 255, 0);
    /* border-bottom: 1px solid #e0e0e0; */
}

.item-checkbox {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 3;
    width: 20px;
    height: 20px;
    appearance: none;
    -webkit-appearance: none;
    border: 2px solid #bbb;
    border-radius: 50%;
    background: #fff;
    cursor: pointer;
    transition: border-color 0.2s;
    outline: none;
    box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    display: inline-block;
    vertical-align: middle;
}

.item-checkbox:checked {
    border-color: #3498db;
    background: #3498db;
}

.item-checkbox:checked::after {
    content: '';
    display: block;
    width: 10px;
    height: 10px;
    margin: 3px auto;
    border-radius: 50%;
    background: #fff;
}

.item-actions {
    display: flex;
    gap: 5px;
}

.item-image {
    position: static;
    width: 100%;
    aspect-ratio: 4/3;
    object-fit: cover;
    display: block;
    height: auto;
    background: #f8f9fa;
}

.item-info {
    padding: 10px;
}

.item-name {
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 6px;
    font-size: 15px;
    letter-spacing: -0.1px;
    line-height: 1.3;
}

.item-filename {
    color: #6c757d;
    font-size: 12px;
    font-family: 'SF Mono', Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    letter-spacing: 0.2px;
    font-weight: 500;
}

.item-meta {
    display: flex;
    flex-direction: column;
    gap: 5px;
    font-size: 11px;
    font-family: 'SF Mono', Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    line-height: 1.2;
    color: #6c757d;
    font-weight: 500;
}

/* 로딩 오버레이 */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    flex-direction: column;
}

.loading-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 15px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loading-overlay p {
    color: white;
    font-size: 16px;
}

/* 모달 */
.modal {
    display: none;
    position: fixed;
    z-index: 1001;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    backdrop-filter: blur(5px);
    animation: fadeIn 0.3s ease-out;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(30px) scale(0.95);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.modal-content {
    background-color: white;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    width: 90%;
    max-width: 500px;
    /* max-height: 90vh; */
    text-align: center;
    overflow-y: auto;
    animation: slideUp 0.3s ease-out;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.modal-content h3 {
    color: #2c3e50;
    margin-bottom: 15px;
}

.modal-content p {
    margin-bottom: 20px;
    color: #555;
}

.modal-actions {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-top: 20px;
}

/* 편집 모달 스타일 */
.edit-modal-content {
    max-width: 1000px;
    width: 95%;
    text-align: left;
    box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
    border-radius: 16px;
    overflow: hidden;
    background: white;
}

.edit-modal-body {
    display: flex;
    gap: 40px;
    margin-bottom: 30px;
    padding: 0 10px;
}

.edit-modal-left {
    flex: 1;
    min-width: 320px;
}

.edit-modal-right {
    flex: 1;
    min-width: 320px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.form-row {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
}

.form-row .form-group {
    flex: 1;
    min-width: 0;
}

/* 드래그 앤 드롭 영역 개선 */
.edit-modal-left .drag-drop-area {
    border: 2px dashed #bdc3c7;
    border-radius: 12px;
    padding: 40px 20px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    position: relative;
    min-height: 250px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.edit-modal-left .drag-drop-area:hover {
    border-color: #3498db;
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(52, 152, 219, 0.2);
}

.edit-modal-left .drag-drop-area.drag-over {
    border-color: #3498db;
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    transform: scale(1.02);
}

.drag-drop-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
}

.drag-drop-icon {
    font-size: 48px;
    margin-bottom: 15px;
    opacity: 0.7;
}

.drag-drop-content p {
    color: #7f8c8d;
    margin: 0;
    font-size: 14px;
    line-height: 1.5;
}

#editImagePreview {
    max-width: 100%;
    max-height: 200px;
    border-radius: 8px;
    cursor: pointer;
    border: 2px solid #e0e0e0;
    object-fit: cover;
    transition: transform 0.3s ease;
}

#editImagePreview:hover {
    transform: scale(1.05);
    border-color: #3498db;
}

.edit-image-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.edit-image-container .btn {
    align-self: center;
}

/* 필수 필드 표시 및 현대적인 스타일링 */
.edit-modal-right .form-group label.required::after {
    content: ' *';
    color: #e74c3c;
    font-weight: bold;
}

.edit-modal-right .form-group input {
    padding: 14px 16px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    font-size: 14px;
    transition: all 0.3s ease;
    background-color: #fff;
    line-height: 1.4;
    min-height: 48px;
}

.edit-modal-right .form-group input:hover {
    border-color: #d5dbdb;
}

.edit-modal-right .form-group input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    transform: translateY(-1px);
}

.edit-modal-right .form-group input::placeholder {
    color: #6c757d;
    font-style: italic;
}

.edit-modal-right .form-group input:invalid:not(:placeholder-shown) {
    border-color: #e74c3c;
    background-color: #fdf2f2;
    animation: shake 0.5s ease-in-out;
}

.edit-modal-right .form-group input:valid:not(:placeholder-shown) {
    border-color: #27ae60;
    background-color: #f8fff8;
}

.edit-modal-right .form-group label {
    font-weight: 600;
    color: #2c3e50;
    font-size: 14px;
    margin-bottom: 8px;
    display: block;
    letter-spacing: 0.5px;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* 모달 제목 스타일링 */
.edit-modal-content h3 {
    text-align: center;
    color: #2c3e50;
    font-size: 26px;
    font-weight: 700;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 3px solid #e9ecef;
    position: relative;
}

.edit-modal-content h3::after {
    content: '';
    position: absolute;
    bottom: -3px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 3px;
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    border-radius: 2px;
}

/* 버튼 개선 */
.modal-actions .btn {
    padding: 12px 24px;
    font-size: 14px;
    font-weight: 600;
    border-radius: 8px;
    transition: all 0.3s ease;
    border: none;
    cursor: pointer;
    min-width: 100px;
}

.modal-actions .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.modal-actions .btn-primary {
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    color: white;
}

.modal-actions .btn-primary:hover {
    background: linear-gradient(135deg, #2980b9 0%, #1f5f8b 100%);
}

.modal-actions .btn-danger {
    background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    color: white;
}

.modal-actions .btn-danger:hover {
    background: linear-gradient(135deg, #c0392b 0%, #922b21 100%);
}

.modal-actions .btn-secondary {
    background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
    color: white;
}

.modal-actions .btn-secondary:hover {
    background: linear-gradient(135deg, #7f8c8d 0%, #566165 100%);
}

/* 반응형 디자인 */
@media (max-width: 768px) {
    .main-content {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .header {
        flex-direction: column;
        gap: 15px;
        text-align: center;
        padding: 15px;
    }
    
    .panel {
        padding: 15px;
    }
    
    .panel-header {
        flex-direction: column;
        align-items: stretch;
        gap: 15px;
    }
    
    .panel-actions {
        justify-content: center;
        flex-wrap: wrap;
    }
    
    .items-container {
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 12px;
    }
    
    .input-with-button {
        flex-direction: column;
        gap: 12px;
    }
    
    .form-actions {
        flex-direction: column;
        gap: 12px;
    }
    
    .add-form {
        gap: 16px;
    }
    
    .drag-drop-area {
        max-width: 100%;
        min-height: 180px;
        padding: 30px 15px;
    }
    
    /* 편집 모달 반응형 */
    .edit-modal-content {
        width: 95%;
        max-width: none;
        margin: 2% auto;
        padding: 20px;
    }
    
    .edit-modal-body {
        flex-direction: column;
        gap: 25px;
    }
    
    .edit-modal-left,
    .edit-modal-right {
        min-width: auto;
    }
    
    .edit-modal-left .drag-drop-area {
        min-height: 200px;
        padding: 30px 15px;
    }
    
    .form-row {
        flex-direction: column;
        gap: 15px;
    }
    
    .modal-actions {
        flex-direction: column;
        gap: 12px;
    }
    
    .modal-actions .btn {
        width: 100%;
    }
}

@media (max-width: 1200px) {
    .items-container {
        grid-template-columns: repeat(2, 1fr);
    }
}
@media (max-width: 800px) {
    .items-container {
        grid-template-columns: repeat(1, 1fr);
    }
}

/* 스크롤바 스타일 */
.items-container::-webkit-scrollbar {
    width: 8px;
}

.items-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.items-container::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

.items-container::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

.grid-count-select {
    padding: 6px 10px;
    border-radius: 4px;
    border: 2px solid #e0e0e0;
    font-size: 14px;
    margin-right: 10px;
}

#editImagePreview {
    width: 100%;
    aspect-ratio: 1/1;
    object-fit: cover;
    border-radius: 8px;
    background: #f8f9fa;
    display: block;
}

#editImagePreview {
    max-width: 100%;
    max-height: 150px;
    border-radius: 4px;
}

/* 토스트 스타일 */
.toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10000;
    pointer-events: none;
}

.toast {
    background: #2c3e50;
    color: white;
    padding: 12px 20px;
    border-radius: 6px;
    margin-bottom: 10px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    font-size: 14px;
    font-weight: 500;
    opacity: 0;
    transform: translateX(100%);
    transition: all 0.3s ease;
    max-width: 300px;
    word-wrap: break-word;
}

.toast.show {
    opacity: 1;
    transform: translateX(0);
}

.toast.success {
    background: #27ae60;
}

.toast.error {
    background: #e74c3c;
}

.toast.info {
    background: #3498db;
}

/* 이미지 편집 모달 스타일 */
.editor-modal-content {
    max-width: 800px;
    width: 95%;
    margin: 5% auto;
}

.image-editor-container {
    display: flex;
    gap: 20px;
    margin-top: 20px;
}

.editor-main-panel {
    flex: 3;
}

.crop-container {
    width: 100%;
    height: 450px; /* 고정 높이 */
    background-color: #eee;
}

#imageToCrop {
    display: block;
    max-width: 100%;
    max-height: 100%;
}

.editor-controls-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.control-group label {
    font-weight: 600;
    font-size: 14px;
}

.control-group input[type="range"] {
    width: 100%;
}

/* Cropper.js의 기본 스타일을 일부 오버라이드 */
.cropper-view-box,
.cropper-face {
    border-radius: 4px;
}

.cropper-container {
    background-color: #f0f0f0;
    border-radius: 4px;
}

.edit-image-container {
    display: flex;
    align-items: center;
    gap: 15px;
}

.toast.warning {
    background: #f39c12;
} 

/* 저장 버튼 로딩 상태 스타일 */
.btn.loading {
    position: relative;
    pointer-events: none;
    color: rgba(255, 255, 255, 0.9) \!important;
}

.btn.loading .loading-spinner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) !important;
    width: 16px;
    height: 16px;
    border: 2px solid transparent;
    border-top: 2px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: inline-block;
    margin: 0 !important;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none \!important;
    box-shadow: none \!important;
}

.btn:disabled:hover {
    transform: none \!important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) \!important;
}


/* 엑셀 업로드 모달 스타일 */
.upload-step {
    margin: 20px 0;
}

.upload-options {
    margin: 15px 0;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 4px;
}

.upload-options label {
    display: block;
    margin-bottom: 8px;
    cursor: pointer;
    font-size: 14px;
}

.upload-options input[type="radio"] {
    margin-right: 8px;
}

.progress-container {
    margin: 20px 0;
}

.progress-bar {
    width: 100%;
    height: 20px;
    background: #e9ecef;
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 10px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
    transition: width 0.3s ease;
    width: 0%;
}

#progressText {
    text-align: center;
    font-size: 14px;
    color: #666;
}

/* 업로드 방식 선택 UI */
.upload-method-selection {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 20px 0;
}

.upload-method-option {
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 20px;
    text-align: center;
    transition: all 0.3s ease;
    cursor: pointer;
    background: #f8f9fa;
}

.upload-method-option:hover {
    border-color: #3498db;
    background: #e3f2fd;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
}

.upload-method-option.recommended {
    border-color: #27ae60;
    background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%);
}

.upload-method-option.recommended:hover {
    border-color: #229954;
    background: linear-gradient(135deg, #e8f5e8 0%, #d4f1d4 100%);
}

.method-icon {
    font-size: 48px;
    margin-bottom: 15px;
    opacity: 0.8;
}

.upload-method-option h5 {
    color: #2c3e50;
    margin: 15px 0 10px 0;
    font-size: 18px;
    font-weight: 600;
}

.upload-method-option p {
    color: #666;
    margin: 10px 0;
    font-size: 14px;
    line-height: 1.4;
}

.upload-method-option ul {
    text-align: left;
    margin: 15px 0;
    padding-left: 20px;
    font-size: 13px;
    color: #555;
}

.upload-method-option ul li {
    margin-bottom: 6px;
    line-height: 1.3;
}

.method-select-btn {
    margin-top: 15px;
    width: 100%;
}

/* 미리보기 테이블 반응형 */
@media (max-width: 768px) {
    .upload-method-selection {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .upload-method-option {
        padding: 15px;
    }
    
    .method-icon {
        font-size: 36px;
    }
    
    .upload-method-option h5 {
        font-size: 16px;
    }
    
    .upload-options {
        padding: 10px;
    }
    
    #previewContainer table {
        font-size: 10px;
    }
    
    #previewContainer th,
    #previewContainer td {
        padding: 4px \!important;
    }
}
</file>

<file path="admin.html">
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Photo 관리자</title>
    <link rel="stylesheet" href="admin.css">
    <link  href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet">
</head>
<body>
    <!-- 토스트 컨테이너 -->
    <div id="toastContainer" class="toast-container"></div>
    
    <div class="container">
        <!-- 헤더 -->
        <header class="header">
            <h1>Particle Photo 관리자</h1>
            <div class="header-actions">
                <button id="refreshBtn" class="btn btn-secondary">새로고침</button>
                <button id="excelDownloadBtn" class="btn btn-success">📊 엑셀 다운로드</button>
                <button id="excelUploadBtn" class="btn btn-primary">📤 엑셀 업로드</button>
                <input type="file" id="excelFileInput" accept=".csv,.xlsx,.xls,.zip" style="display: none;">
            </div>
        </header>

        <!-- 메인 콘텐츠 -->
        <div class="main-content">
            <!-- 왼쪽 패널: 추가 폼 -->
            <div class="left-panel">
                <div class="panel">
                    <h2>인원 추가</h2>
                    <div class="add-form">
                        <button type="button" id="addNewItemBtn" class="btn btn-primary btn-large">인원 추가</button>
                    </div>
                </div>

                <!-- 사용법 안내 -->
                <div class="panel">
                    <h2>사용법</h2>
                    <div class="usage-guide">
                        <h3>📸 이미지 추가</h3>
                        <ol>
                            <li>이미지를 드래그하거나 클릭하여 선택</li>
                            <li>한글 이름 입력</li>
                            <li>영문 이름 띄어쓰기 없이 ex)HongGilDong</li>
                            <li>추가 버튼 클릭</li>
                        </ol>
                        
                        <h3>🗑️ 인원 삭제</h3>
                        <ol>
                            <li>삭제할 항목 체크박스 선택</li>
                            <li>삭제 버튼 클릭</li>
                            <li>확인 후 삭제 완료</li>
                        </ol>
                        
                        <h3>🔍 검색</h3>
                        <p>검색창에 한글 이름이나 파일명을 입력하여 필터링</p>
                    </div>
                </div>
            </div>

            <!-- 오른쪽 패널: 목록 -->
            <div class="right-panel">
                <div class="panel">
                    <div class="panel-header">
                        <h2>현재 인원 목록 <span id="itemCount" class="item-count"></span></h2>
                        <div class="panel-actions">
                            <input type="text" id="searchInput" placeholder="검색..." class="search-input">
                            <select id="gridCountSelect" class="grid-count-select">
                                <option value="4">4명씩</option>
                                <option value="6">6명씩</option>
                                <option value="8">8명씩</option>
                                <option value="10">10명씩</option>
                            </select>
                            <button id="selectAllBtn" class="btn btn-small btn-secondary">전체 선택</button>
                            <button id="deleteSelectedBtn" class="btn btn-small btn-danger">선택 삭제</button>
                        </div>
                    </div>
                    
                    <div id="itemsContainer" class="items-container">
                        <!-- 항목들이 여기에 동적으로 추가됩니다 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 엑셀 업로드 모달 -->
    <div id="excelUploadModal" class="modal">
        <div class="modal-content">
            <h3>엑셀 파일 업로드</h3>
            <div id="uploadStep1" class="upload-step">
                <h4>업로드 방식을 선택해주세요</h4>
                
                <!-- 업로드 방식 선택 -->
                <div class="upload-method-selection">
                    <div class="upload-method-option" data-method="csv">
                        <div class="method-icon">📄</div>
                        <h5>CSV/Excel 파일만</h5>
                        <p>사람 정보만 업로드 (이미지 별도 업로드)</p>
                        <ul>
                            <li><strong>지원 형식:</strong> .csv, .xlsx, .xls</li>
                            <li><strong>필수 컬럼:</strong> 한글이름, 영문이름</li>
                            <li><strong>선택 컬럼:</strong> 조직, 직무, 직위, 이메일</li>
                        </ul>
                        <button class="btn btn-primary method-select-btn">CSV 파일 선택</button>
                    </div>
                    
                    <div class="upload-method-option" data-method="zip">
                        <div class="method-icon">📦</div>
                        <h5>ZIP 파일 (추천)</h5>
                        <p>CSV + 이미지를 한 번에 업로드</p>
                        <ul>
                            <li><strong>구성:</strong> CSV파일 + 이미지폴더</li>
                            <li><strong>이미지명:</strong> 영문이름.png/jpg</li>
                            <li><strong>예시:</strong> data.csv + images/JohnDoe.png</li>
                        </ul>
                        <button class="btn btn-success method-select-btn">ZIP 파일 선택</button>
                    </div>
                </div>
                
                <div class="modal-actions">
                    <button id="uploadCancelBtn" class="btn btn-secondary">취소</button>
                </div>
            </div>
            <div id="uploadStep2" class="upload-step" style="display: none;">
                <h4>파일 미리보기</h4>
                <div id="previewContainer"></div>
                <div class="upload-options">
                    <label>
                        <input type="radio" name="conflictMode" value="skip" checked>
                        중복 데이터 건너뛰기
                    </label>
                    <label>
                        <input type="radio" name="conflictMode" value="overwrite">
                        중복 데이터 덮어쓰기
                    </label>
                </div>
                <div class="modal-actions">
                    <button id="startUploadBtn" class="btn btn-success">업로드 시작</button>
                    <button id="uploadBackBtn" class="btn btn-secondary">뒤로</button>
                </div>
            </div>
            <div id="uploadStep3" class="upload-step" style="display: none;">
                <h4 id="uploadProgressTitle">업로드 진행 중...</h4>
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill"></div>
                    </div>
                    <div id="progressText">0 / 0</div>
                </div>
                <div id="uploadResults" style="display: none;">
                    <h4 id="uploadResultTitle">업로드 완료</h4>
                    <div id="resultSummary"></div>
                </div>
                <div id="uploadError" style="display: none;">
                    <h4 style="color: #e74c3c;">업로드 오류</h4>
                    <div id="errorMessage" style="color: #e74c3c; margin: 15px 0; padding: 15px; background: #fdf2f2; border-radius: 4px; border-left: 4px solid #e74c3c;">
                    </div>
                    <div style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                        <strong>해결 방법:</strong>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>CSV 파일의 첫 번째 행에 <strong>한글이름, 영문이름</strong> 컬럼이 포함되어 있는지 확인해주세요.</li>
                            <li>파일이 UTF-8 인코딩으로 저장되어 있는지 확인해주세요.</li>
                            <li>Excel에서 CSV로 저장할 때 'CSV UTF-8(쉼표로 분리)' 형식을 선택해주세요.</li>
                        </ul>
                    </div>
                </div>
                <div class="modal-actions">
                    <button id="uploadCloseBtn" class="btn btn-primary" style="display: none;">완료</button>
                    <button id="uploadErrorCloseBtn" class="btn btn-secondary" style="display: none;">닫기</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 로딩 오버레이 -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <p>처리 중...</p>
    </div>

    <!-- 확인 모달 -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <h3>확인</h3>
            <p id="modalMessage"></p>
            <div class="modal-actions">
                <button id="modalConfirmBtn" class="btn btn-danger">확인</button>
                <button id="modalCancelBtn" class="btn btn-secondary">취소</button>
            </div>
        </div>
    </div>

    <!-- 편집 모달 -->
    <div id="editModal" class="modal">
        <div class="modal-content edit-modal-content">
            <h3 id="modalTitle">항목 편집</h3>
            <form id="editForm">
                <div class="edit-modal-body">
                    <!-- 좌측: 이미지 업로드 영역 -->
                    <div class="edit-modal-left">
                        <div class="form-group">
                            <label>이미지 업로드</label>
                            <div class="edit-image-container">
                                <div id="editDragDropArea" class="drag-drop-area">
                                    <div class="drag-drop-content">
                                        <div class="drag-drop-icon">📁</div>
                                        <p>이미지를 드래그하거나 클릭하여 선택하세요</p>
                                        <img id="editImagePreview" src="" alt="미리보기" style="display:none;">
                                    </div>
                                </div>
                                <button type="button" id="changeImageBtn" class="btn btn-secondary">이미지 변경</button>
                            </div>
                            <input type="file" id="editImageUpload" accept="image/*" style="display: none;">
                        </div>
                    </div>
                    
                    <!-- 우측: 정보 입력 영역 -->
                    <div class="edit-modal-right">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="required">한글 이름</label>
                                <input type="text" id="editKoreanName" required placeholder="한글 이름을 입력하세요">
                            </div>
                            <div class="form-group">
                                <label class="required">영문 이름(공백없이)</label>
                                <input type="text" id="editEnglishName" required placeholder="영문 이름을 입력하세요 ex) HongGilDong">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>조직</label>
                                <input type="text" id="editOrganization" placeholder="조직명을 입력하세요">
                            </div>
                            <div class="form-group">
                                <label>직무</label>
                                <input type="text" id="editRole" placeholder="직무를 입력하세요">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>직위</label>
                                <input type="text" id="editPosition" placeholder="직위를 입력하세요">
                            </div>
                            <div class="form-group">
                                <label>이메일</label>
                                <input type="email" id="editEmail" placeholder="이메일을 입력하세요">
                            </div>
                        </div>
                    </div>
                </div>
                <div>
                    <h3></h3>
                </div>
                <div class="modal-actions">
                    <button type="submit" class="btn btn-primary">저장</button>
                    <button type="button" id="editModalDeleteBtn" class="btn btn-danger">삭제</button>
                    <button type="button" id="editModalCancelBtn" class="btn btn-secondary">취소</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 이미지 편집 모달 -->
    <div id="imageEditorModal" class="modal">
        <div class="modal-content editor-modal-content">
            <h3>이미지 편집</h3>
            <div class="image-editor-container">
                <div class="editor-main-panel">
                    <div class="crop-container">
                        <img id="imageToCrop" src="" alt="편집할 이미지">
                    </div>
                </div>
                <div class="editor-controls-panel">
                    <h4>편집 도구</h4>
                    <div class="control-group">
                        <label for="brightness">밝기</label>
                        <input type="range" id="brightness" min="0" max="200" value="100">
                    </div
                    <div class="control-group">
                        <label for="contrast">대비</label>
                        <input type="range" id="contrast" min="0" max="200" value="100">
                    </div>
                </div>
                <div class="modal-actions">
                    <button id="editorSaveBtn" class="btn btn-primary">편집 완료</button>
                    <button id="editorCancelBtn" class="btn btn-secondary">취소</button>
                </div>
            </div>
        </div>
    </div>

    <script src="admin.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>
</body>
</html>
</file>

<file path="admin.js">
// 관리자 페이지 메인 JavaScript

class AdminManager {
    constructor() {
        this.people = [];
        this.selectedItems = new Set();
        this.selectedFile = null;
        this.editIndex = null;
        this.editImageFile = null;
        this.cropper = null;
        this.editingContext = null; // 'add' 또는 'edit'
        this.isSaving = false; // 저장 중 상태 관리
        this.isDeleting = false; // 삭제 중 상태 관리
        this.init();
    }

    async init() {
        this.bindEvents();
        await this.loadPeople();
        this.renderItems();
        this.showMessage('관리자 페이지가 로드되었습니다.', 'info');
        this.applyGridCount();
    }

    bindEvents() {
        const gridCountSelect = document.getElementById('gridCountSelect');
        if (gridCountSelect) {
            gridCountSelect.addEventListener('change', () => this.applyGridCount());
        }
        // 기존 요소들에 대한 조건부 이벤트 리스너
        const refreshBtn = document.getElementById('refreshBtn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => this.refreshData());
        }

        const excelDownloadBtn = document.getElementById('excelDownloadBtn');
        if (excelDownloadBtn) {
            excelDownloadBtn.addEventListener('click', () => this.downloadExcel());
        }

        const excelUploadBtn = document.getElementById('excelUploadBtn');
        if (excelUploadBtn) {
            excelUploadBtn.addEventListener('click', () => this.openExcelUploadModal());
        }

        // 엑셀 업로드 관련 이벤트 리스너들
        this.bindExcelUploadEvents();
        
        document.getElementById('searchInput').addEventListener('input', (e) => this.handleSearch(e));
        document.getElementById('selectAllBtn').addEventListener('click', () => this.toggleSelectAll());
        document.getElementById('deleteSelectedBtn').addEventListener('click', () => this.deleteSelected());
        // 기존 dragDropArea는 제거되었으므로 이벤트 리스너 제거
        document.getElementById('editModalCancelBtn').addEventListener('click', () => this.closeEditModal());
        document.getElementById('editForm').addEventListener('submit', (e) => this.saveEdit(e));
        // 이미지 관련 이벤트는 setupEditModalDragDrop에서 처리됨
        document.getElementById('editModalDeleteBtn').addEventListener('click', () => this.deleteEditItem());

        // previewImage 요소는 더 이상 존재하지 않음

        // 새항목 추가 버튼 이벤트
        document.getElementById('addNewItemBtn').addEventListener('click', () => this.openAddModal());
        
        // 이미지 편집 모달 이벤트
        document.getElementById('editorSaveBtn').addEventListener('click', () => this.saveEditedImage());
        document.getElementById('editorCancelBtn').addEventListener('click', () => this.closeImageEditor());
        document.getElementById('brightness').addEventListener('input', () => this.applyImageFilters());
        document.getElementById('contrast').addEventListener('input', () => this.applyImageFilters());
        
        // 편집 모달 드래그 앤 드롭 이벤트
        this.setupEditModalDragDrop();
    }
    
    // 편집 모달 드래그 앤 드롭 설정
    setupEditModalDragDrop() {
        const editDragDropArea = document.getElementById('editDragDropArea');
        const editImageUpload = document.getElementById('editImageUpload');
        const editImagePreview = document.getElementById('editImagePreview');
        const changeImageBtn = document.getElementById('changeImageBtn');
        
        // 드래그 앤 드롭 이벤트
        editDragDropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            editDragDropArea.classList.add('drag-over');
        });
        
        editDragDropArea.addEventListener('dragleave', () => {
            editDragDropArea.classList.remove('drag-over');
        });
        
        editDragDropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            editDragDropArea.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleEditImageFile(files[0]);
            }
        });
        
        // 클릭으로 파일 선택 (미리보기 이미지가 아닌 경우에만)
        editDragDropArea.addEventListener('click', (e) => {
            if (e.target !== editImagePreview) {
                editImageUpload.click();
            }
        });
        
        changeImageBtn.addEventListener('click', () => {
            editImageUpload.click();
        });
        
        editImageUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.handleEditImageFile(e.target.files[0]);
            }
        });
        
        // 미리보기 이미지 클릭 시 이미지 편집 (이벤트 버블링 방지)
        editImagePreview.addEventListener('click', (e) => {
            e.stopPropagation(); // 이벤트 버블링 방지
            if (this.editSelectedFile) {
                this.openImageEditor(this.editSelectedFile);
            } else if (editImagePreview.src) {
                // editSelectedFile이 없으면 현재 미리보기 이미지 사용
                this.openImageEditor(editImagePreview.src);
            }
        });
    }
    
    // 편집 모달 이미지 파일 처리
    handleEditImageFile(file) {
        if (!file.type.startsWith('image/')) {
            this.showMessage('이미지 파일만 업로드할 수 있습니다.', 'error');
            return;
        }
        
        this.editSelectedFile = file;
        const reader = new FileReader();
        reader.onload = (e) => {
            const editImagePreview = document.getElementById('editImagePreview');
            editImagePreview.src = e.target.result;
            editImagePreview.style.display = 'block';
            document.querySelector('.drag-drop-content p').style.display = 'none';
            document.querySelector('.drag-drop-icon').style.display = 'none';
        };
        reader.readAsDataURL(file);
    }
    
    // 기존 이미지를 File 객체로 변환
    async loadExistingImageAsFile(imageSrc) {
        try {
            const response = await fetch(imageSrc);
            const blob = await response.blob();
            const filename = imageSrc.split('/').pop() || 'image.png';
            this.editSelectedFile = new File([blob], filename, { type: blob.type });
        } catch (error) {
            console.warn('기존 이미지 로드 실패:', error);
            this.editSelectedFile = null;
        }
    }

    async loadPeople() {
        try {
            this.showLoading(true);
            const response = await fetch('/api/people');
            if (response.ok) {
                this.people = await response.json();
            } else {
                throw new Error('서버에서 데이터를 가져올 수 없습니다.');
            }
        } catch (error) {
            this.people = [];
            this.showMessage('데이터 로드 실패: ' + error.message, 'error');
        } finally {
            this.showLoading(false);
        }
    }

    async refreshData() {
        await this.loadPeople();
        this.renderItems();
        this.showMessage('데이터가 새로고침되었습니다.', 'success');
    }

    renderItems(filtered = null) {
        const container = document.getElementById('itemsContainer');
        container.innerHTML = '';
        const data = filtered || this.people;
        data.forEach((person) => {
            const item = this.createItemCard(person);
            container.appendChild(item);
        });
        this.applyGridCount();
        const itemCount = document.getElementById('itemCount');
        if (itemCount) {
            itemCount.textContent = `(${data.length}명)`;
        }
    }

    createItemCard(person) {
        const card = document.createElement('div');
        card.className = 'item-card';
        card.dataset.englishName = person.englishName;
        const imagePath = person.imageUrl || `images/${person.imageFile || person.englishName + '.png'}?v=${Date.now()}`;
        card.innerHTML = `
            <div class="item-header">
                <img src="${imagePath}" alt="${person.koreanName}" class="item-image" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjE1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vdCBmb3VuZDwvdGV4dD48L3N2Zz4='">
                <input type="checkbox" class="item-checkbox" data-english-name="${person.englishName}">
            </div>
            <div class="item-info">
                <div class="item-name">${person.koreanName}</div>
                <div class="item-filename">${person.englishName}.png</div>
                <div class="item-meta">
                  <span>${person.organization || ''}</span>
                  <span>${person.position || ''}</span>
                  <span>${person.role || ''}</span>
                  <span>${person.email || ''}</span>
                </div>
            </div>
        `;
        card.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-checkbox')) return;
            this.editItemByEnglishName(person.englishName);
        });
        const checkbox = card.querySelector('.item-checkbox');
        checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                this.selectedItems.add(person.englishName);
                card.classList.add('selected');
            } else {
                this.selectedItems.delete(person.englishName);
                card.classList.remove('selected');
            }
        });
        return card;
    }

    // 이제 편집 모달에서 통합 처리됨

    // reEditImage 메서드는 편집 모달의 이미지 클릭으로 대체됨

    processImageFile(file) {
        if (!file.type.startsWith('image/')) {
            this.showMessage('이미지 파일만 업로드 가능합니다.', 'error');
            return;
        }
        
        // 편집 모달용 파일 처리로 통합
        this.handleEditImageFile(file);
    }

    openImageEditor(imageSrc) {
        const modal = document.getElementById('imageEditorModal');
        const image = document.getElementById('imageToCrop');
        
        let src = imageSrc;
        if (this.editSelectedFile) {
            src = URL.createObjectURL(this.editSelectedFile);
        }
        image.src = src;

        modal.style.display = 'block';

        image.onload = () => {
            if (this.cropper) {
                this.cropper.destroy();
            }
            this.cropper = new Cropper(image, {
                aspectRatio: 4 / 3,
                viewMode: 1,
                autoCropArea: 1,
                background: false,
                ready: () => {
                    this.applyImageFilters();
                }
            });
        };
    }

    applyImageFilters() {
        const brightness = document.getElementById('brightness').value;
        const contrast = document.getElementById('contrast').value;
        const filterValue = `grayscale(100%) brightness(${brightness}%) contrast(${contrast}%)`;
        
        // 전체 이미지에 필터 적용
        const image = document.querySelector('.cropper-canvas img');
        if (image) {
            image.style.filter = filterValue;
        }
        
        // 크롭박스 내부 이미지에도 필터 적용
        const cropBoxImage = document.querySelector('.cropper-crop-box img');
        if (cropBoxImage) {
            cropBoxImage.style.filter = filterValue;
        }
        
        // Cropper 컨테이너 전체에 필터 적용
        const cropperContainer = document.querySelector('.cropper-container');
        if (cropperContainer) {
            cropperContainer.style.filter = filterValue;
        }
    }

    closeImageEditor() {
        document.getElementById('imageEditorModal').style.display = 'none';
        if (this.cropper) {
            this.cropper.destroy();
            this.cropper = null;
        }
        document.getElementById('imageUpload').value = ''; // 파일 선택 초기화
    }

    saveEditedImage() {
        if (!this.cropper) return;

        const canvas = this.cropper.getCroppedCanvas({ width: 400, height: 300 });
        const ctx = canvas.getContext('2d');
        const brightness = document.getElementById('brightness').value;
        const contrast = document.getElementById('contrast').value;

        ctx.filter = `grayscale(100%) brightness(${brightness}%) contrast(${contrast}%)`;
        ctx.drawImage(canvas, 0, 0, 400, 300);

        canvas.toBlob((blob) => {
            const editedFile = new File([blob], "edited_image.png", { type: "image/png" });

            // 편집된 이미지를 편집 모달에 설정
            this.editSelectedFile = editedFile;
            const editImagePreview = document.getElementById('editImagePreview');
            editImagePreview.src = URL.createObjectURL(this.editSelectedFile);
            editImagePreview.style.display = 'block';
            document.querySelector('.drag-drop-content p').style.display = 'none';
            document.querySelector('.drag-drop-icon').style.display = 'none';

            this.closeImageEditor();
        }, 'image/png');
    }
    clearForm() {
        // 이 메서드는 더 이상 사용되지 않음 (편집 모달로 통합됨)
        // clearEditForm()을 대신 사용
        this.clearEditForm();
    }
    // 새항목 추가 모달 열기
    openAddModal() {
        this.isEditMode = false;
        this.currentEditingItem = null;
        this.isSaving = false;
        this.isDeleting = false;
        this.clearEditForm();
        this.setEditFormPlaceholders();
        this.setSaveButtonLoading(false); // 버튼 상태 초기화
        this.setDeleteButtonLoading(false, 'modal'); // 삭제 버튼 상태 초기화
        document.getElementById('modalTitle').textContent = '새항목 추가';
        document.getElementById('editModalDeleteBtn').style.display = 'none';
        document.getElementById('editModal').style.display = 'flex';
    }
    
    // 편집 폼 초기화
    clearEditForm() {
        document.getElementById('editKoreanName').value = '';
        document.getElementById('editEnglishName').value = '';
        document.getElementById('editOrganization').value = '';
        document.getElementById('editRole').value = '';
        document.getElementById('editPosition').value = '';
        document.getElementById('editEmail').value = '';
        
        const previewImage = document.getElementById('editImagePreview');
        previewImage.style.display = 'none';
        previewImage.src = '';
        document.querySelector('.drag-drop-content p').style.display = 'block';
        document.querySelector('.drag-drop-icon').style.display = 'block';
        this.editSelectedFile = null;
    }
    
    // 플레이스홀더 설정
    setEditFormPlaceholders() {
        document.getElementById('editKoreanName').placeholder = '한글 이름을 입력하세요';
        document.getElementById('editEnglishName').placeholder = '영문 이름을 입력하세요 ex) HongGilDong';
        document.getElementById('editOrganization').placeholder = '조직명을 입력하세요';
        document.getElementById('editRole').placeholder = '직무를 입력하세요';
        document.getElementById('editPosition').placeholder = '직위를 입력하세요';
        document.getElementById('editEmail').placeholder = '이메일을 입력하세요';
    }

    async addItem() {
        // 중복 저장 방지 및 삭제 중일 때 저장 방지
        if (this.isSaving || this.isDeleting) {
            return;
        }

        const koreanName = document.getElementById('editKoreanName').value.trim();
        const englishName = document.getElementById('editEnglishName').value.trim();
        const organization = document.getElementById('editOrganization').value.trim();
        const role = document.getElementById('editRole').value.trim();
        const position = document.getElementById('editPosition').value.trim();
        const email = document.getElementById('editEmail').value.trim();
        
        if (!koreanName || !englishName || !this.editSelectedFile) {
            this.showMessage('모든 필드를 입력하고 이미지를 선택해주세요.', 'error');
            return;
        }
        if (this.people.some(p => p.englishName === englishName)) {
            this.showMessage('이미 존재하는 영문 이름입니다.', 'error');
            return;
        }
        
        try {
            this.isSaving = true;
            this.setSaveButtonLoading(true);
            this.showLoading(true);
            
            const formData = new FormData();
            formData.append('koreanName', koreanName);
            formData.append('englishName', englishName);
            formData.append('organization', organization);
            formData.append('role', role);
            formData.append('position', position);
            formData.append('email', email);
            formData.append('image', this.editSelectedFile);
            
            const response = await fetch('/api/people', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                this.showMessage(result.message, 'success');
                await this.loadPeople();
                this.renderItems();
                this.clearEditForm();
                document.getElementById('editModal').style.display = 'none';
            } else {
                const error = await response.json();
                throw new Error(error.error || '서버 오류가 발생했습니다.');
            }
        } catch (error) {
            this.showMessage('항목 추가에 실패했습니다: ' + error.message, 'error');
        } finally {
            this.isSaving = false;
            this.setSaveButtonLoading(false);
            this.showLoading(false);
        }
    }
    handleSearch(event) {
        const searchTerm = event.target.value.toLowerCase();
        const filtered = this.people.filter(person => {
            return (
                person.koreanName.toLowerCase().includes(searchTerm) ||
                person.englishName.toLowerCase().includes(searchTerm) ||
                (person.organization || '').toLowerCase().includes(searchTerm) ||
                (person.role || '').toLowerCase().includes(searchTerm) ||
                (person.position || '').toLowerCase().includes(searchTerm) ||
                (person.email || '').toLowerCase().includes(searchTerm)
            );
        });
        this.renderItems(filtered);
    }
    toggleSelectAll() {
        const checkboxes = document.querySelectorAll('.item-checkbox');
        const selectAllBtn = document.getElementById('selectAllBtn');
        if (this.selectedItems.size === checkboxes.length) {
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                this.selectedItems.delete(checkbox.dataset.englishName);
                checkbox.closest('.item-card').classList.remove('selected');
            });
            selectAllBtn.textContent = '전체 선택';
        } else {
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                this.selectedItems.add(checkbox.dataset.englishName);
                checkbox.closest('.item-card').classList.add('selected');
            });
            selectAllBtn.textContent = '전체 해제';
        }
    }
    async deleteSelected() {
        // 중복 삭제 방지 및 저장 중일 때 삭제 방지
        if (this.isDeleting || this.isSaving) {
            return;
        }

        if (this.selectedItems.size === 0) {
            this.showMessage('삭제할 항목을 선택해주세요.', 'error');
            return;
        }
        
        if (!confirm('정말로 삭제하시겠습니까?')) return;
        
        try {
            this.isDeleting = true;
            this.setDeleteButtonLoading(true, 'selected');
            this.showLoading(true);
            
            const sortedEnglishNames = Array.from(this.selectedItems).sort((a, b) => b.localeCompare(a));
            for (const englishName of sortedEnglishNames) {
                const response = await fetch(`/api/people/${englishName}`, {
                    method: 'DELETE'
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || '삭제 실패');
                }
            }
            
            await this.loadPeople();
            this.renderItems();
            this.selectedItems.clear();
            this.showMessage('선택된 항목이 삭제되었습니다.', 'success');
        } catch (error) {
            this.showMessage('삭제에 실패했습니다: ' + error.message, 'error');
        } finally {
            this.isDeleting = false;
            this.setDeleteButtonLoading(false, 'selected');
            this.showLoading(false);
        }
    }
    editItemByEnglishName(englishName) {
        const index = this.people.findIndex(p => p.englishName === englishName);
        if (index === -1) return;
        
        this.isEditMode = true;
        this.currentEditingItem = this.people[index];
        this.editIndex = index;
        
        const person = this.people[index];
        
        // 이미지 설정
        const editImagePreview = document.getElementById('editImagePreview');
        const imageSrc = person.imageUrl || `images/${person.imageFile || person.englishName + '.png'}?v=${Date.now()}`;
        editImagePreview.src = imageSrc;
        editImagePreview.style.display = 'block';
        document.querySelector('.drag-drop-content p').style.display = 'none';
        document.querySelector('.drag-drop-icon').style.display = 'none';
        
        // 기존 이미지를 File 객체로 변환하여 편집 가능하도록 설정
        this.loadExistingImageAsFile(imageSrc);
        
        // 폼 데이터 설정
        document.getElementById('editKoreanName').value = person.koreanName;
        document.getElementById('editEnglishName').value = person.englishName;
        document.getElementById('editOrganization').value = person.organization || '';
        document.getElementById('editRole').value = person.role || '';
        document.getElementById('editPosition').value = person.position || '';
        document.getElementById('editEmail').value = person.email || '';
        
        // 플레이스홀더 제거
        document.getElementById('editKoreanName').placeholder = '';
        document.getElementById('editEnglishName').placeholder = '';
        document.getElementById('editOrganization').placeholder = '';
        document.getElementById('editRole').placeholder = '';
        document.getElementById('editPosition').placeholder = '';
        document.getElementById('editEmail').placeholder = '';
        
        this.editSelectedFile = null;
        this.isSaving = false;
        this.isDeleting = false;
        this.setSaveButtonLoading(false); // 버튼 상태 초기화
        this.setDeleteButtonLoading(false, 'modal'); // 삭제 버튼 상태 초기화
        document.getElementById('modalTitle').textContent = '항목 편집';
        document.getElementById('editModalDeleteBtn').style.display = 'inline-block';
        document.getElementById('editModal').style.display = 'flex';
    }
    closeEditModal() {
        document.getElementById('editModal').style.display = 'none';
        this.editIndex = null;
        this.editSelectedFile = null;
        this.isEditMode = false;
        this.isSaving = false;
        this.isDeleting = false;
        this.currentEditingItem = null;
        this.setSaveButtonLoading(false); // 버튼 상태 초기화
        this.setDeleteButtonLoading(false, 'modal'); // 삭제 버튼 상태 초기화
        this.clearEditForm();
    }
    // handleEditImageSelect는 setupEditModalDragDrop에서 처리됨
    async saveEdit(event) {
        event.preventDefault();
        
        // 중복 저장 방지 및 삭제 중일 때 저장 방지
        if (this.isSaving || this.isDeleting) {
            return;
        }
        
        const koreanName = document.getElementById('editKoreanName').value.trim();
        const englishName = document.getElementById('editEnglishName').value.trim();
        const organization = document.getElementById('editOrganization').value.trim();
        const role = document.getElementById('editRole').value.trim();
        const position = document.getElementById('editPosition').value.trim();
        const email = document.getElementById('editEmail').value.trim();
        
        if (!koreanName || !englishName) {
            this.showMessage('이름을 모두 입력하세요.', 'error');
            return;
        }
        
        // 새항목 추가 모드인 경우
        if (!this.isEditMode) {
            await this.addItem();
            return;
        }
        
        // 편집 모드인 경우
        if (this.editIndex === null) return;
        const oldPerson = this.people[this.editIndex];
        
        try {
            this.isSaving = true;
            this.setSaveButtonLoading(true);
            this.showLoading(true);
            
            const formData = new FormData();
            formData.append('koreanName', koreanName);
            formData.append('newEnglishName', englishName);
            formData.append('organization', organization);
            formData.append('role', role);
            formData.append('position', position);
            formData.append('email', email);
            if (this.editSelectedFile) {
                formData.append('image', this.editSelectedFile);
            }
            
            const response = await fetch(`/api/people/${oldPerson.englishName}`, {
                method: 'PATCH',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                this.showMessage(result.message, 'success');
                await this.loadPeople();
                this.renderItems();
                this.closeEditModal();
            } else {
                const error = await response.json();
                throw new Error(error.error || '서버 오류가 발생했습니다.');
            }
        } catch (error) {
            this.showMessage('편집에 실패했습니다: ' + error.message, 'error');
        } finally {
            this.isSaving = false;
            this.setSaveButtonLoading(false);
            this.showLoading(false);
        }
    }
    async deleteEditItem() {
        // 중복 삭제 방지 및 저장 중일 때 삭제 방지
        if (this.isDeleting || this.isSaving) {
            return;
        }

        if (this.editIndex === null) return;
        const englishName = this.people[this.editIndex].englishName;
        
        if (!confirm('정말로 삭제하시겠습니까?')) return;
        
        try {
            this.isDeleting = true;
            this.setDeleteButtonLoading(true, 'modal');
            this.showLoading(true);
            
            const response = await fetch(`/api/people/${englishName}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                this.showMessage('항목이 삭제되었습니다.', 'success');
                await this.loadPeople();
                this.renderItems();
                this.closeEditModal();
            } else {
                const error = await response.json();
                throw new Error(error.error || '서버 오류가 발생했습니다.');
            }
        } catch (error) {
            this.showMessage('삭제에 실패했습니다: ' + error.message, 'error');
        } finally {
            this.isDeleting = false;
            this.setDeleteButtonLoading(false, 'modal');
            this.showLoading(false);
        }
    }
    applyGridCount() {
        const gridCountSelect = document.getElementById('gridCountSelect');
        const itemsContainer = document.getElementById('itemsContainer');
        if (gridCountSelect && itemsContainer) {
            const count = parseInt(gridCountSelect.value, 10) || 4;
            itemsContainer.style.gridTemplateColumns = `repeat(${count}, 1fr)`;
        }
    }
    showLoading(show) {
        document.getElementById('loadingOverlay').style.display = show ? 'flex' : 'none';
    }

    // 저장 버튼 상태 관리 메서드들
    setSaveButtonLoading(loading) {
        const saveButton = document.querySelector('#editModal .btn-primary');
        const deleteButton = document.getElementById('editModalDeleteBtn');
        const cancelButton = document.getElementById('editModalCancelBtn');
        
        if (loading) {
            // 저장 버튼을 로딩 상태로 변경
            saveButton.disabled = true;
            saveButton.classList.add('loading');
            saveButton.dataset.originalText = saveButton.textContent;
            saveButton.innerHTML = '<span class="loading-spinner"></span>저장 중...';
            
            // 다른 버튼들도 비활성화
            deleteButton.disabled = true;
            deleteButton.style.opacity = '0.5';
            cancelButton.disabled = true;
            cancelButton.style.opacity = '0.5';
        } else {
            // 원래 상태로 복원
            saveButton.disabled = false;
            saveButton.classList.remove('loading');
            saveButton.textContent = saveButton.dataset.originalText || '저장';
            
            // 다른 버튼들도 활성화
            deleteButton.disabled = false;
            deleteButton.style.opacity = '1';
            cancelButton.disabled = false;
            cancelButton.style.opacity = '1';
        }
    }

    // 삭제 버튼 상태 관리 메서드들
    setDeleteButtonLoading(loading, buttonType = 'modal') {
        if (buttonType === 'modal') {
            // 편집 모달의 삭제 버튼
            const deleteButton = document.getElementById('editModalDeleteBtn');
            const saveButton = document.querySelector('#editModal .btn-primary');
            const cancelButton = document.getElementById('editModalCancelBtn');
            
            if (loading) {
                deleteButton.disabled = true;
                deleteButton.classList.add('loading');
                deleteButton.dataset.originalText = deleteButton.textContent;
                deleteButton.innerHTML = '<span class="loading-spinner"></span>삭제 중...';
                
                // 다른 버튼들도 비활성화
                saveButton.disabled = true;
                saveButton.style.opacity = '0.5';
                cancelButton.disabled = true;
                cancelButton.style.opacity = '0.5';
            } else {
                deleteButton.disabled = false;
                deleteButton.classList.remove('loading');
                deleteButton.textContent = deleteButton.dataset.originalText || '삭제';
                
                // 다른 버튼들도 활성화
                saveButton.disabled = false;
                saveButton.style.opacity = '1';
                cancelButton.disabled = false;
                cancelButton.style.opacity = '1';
            }
        } else if (buttonType === 'selected') {
            // 선택된 항목 삭제 버튼
            const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
            const selectAllBtn = document.getElementById('selectAllBtn');
            
            if (loading) {
                deleteSelectedBtn.disabled = true;
                deleteSelectedBtn.classList.add('loading');
                deleteSelectedBtn.dataset.originalText = deleteSelectedBtn.textContent;
                deleteSelectedBtn.innerHTML = '<span class="loading-spinner"></span>삭제 중...';
                
                // 전체 선택 버튼도 비활성화
                selectAllBtn.disabled = true;
                selectAllBtn.style.opacity = '0.5';
            } else {
                deleteSelectedBtn.disabled = false;
                deleteSelectedBtn.classList.remove('loading');
                deleteSelectedBtn.textContent = deleteSelectedBtn.dataset.originalText || '선택 삭제';
                
                // 전체 선택 버튼도 활성화
                selectAllBtn.disabled = false;
                selectAllBtn.style.opacity = '1';
            }
        }
    }
    showMessage(message, type = 'info') {
        console.log(`[${type.toUpperCase()}] ${message}`);
        
        // 토스트 메시지 생성
        const toastContainer = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        // 토스트를 컨테이너에 추가
        toastContainer.appendChild(toast);
        
        // 애니메이션을 위해 약간의 지연 후 show 클래스 추가
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);
        
        // 2초 후 토스트 제거
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300); // 애니메이션 완료 후 DOM에서 제거
        }, 2000);
    }

    // 엑셀 다운로드 기능
    downloadExcel() {
        try {
            // CSV 형식으로 데이터 생성 (엑셀에서 열 수 있음)
            const headers = ['한글이름', '영문이름', '조직', '직무', '직위', '이메일', '이미지파일명'];
            const csvContent = [
                headers.join(','), // 헤더 행
                ...this.people.map(person => [
                    `"${person.koreanName || ''}"`,
                    `"${person.englishName || ''}"`,
                    `"${person.organization || ''}"`,
                    `"${person.role || ''}"`,
                    `"${person.position || ''}"`,
                    `"${person.email || ''}"`,
                    `"${person.imageFile || person.englishName + '.png'}"`
                ].join(','))
            ].join('\n');

            // BOM 추가 (UTF-8 인코딩을 위해)
            const bom = '\uFEFF';
            const blob = new Blob([bom + csvContent], { 
                type: 'text/csv;charset=utf-8;' 
            });

            // 다운로드 링크 생성
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            
            // 파일명에 현재 날짜 포함
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD 형식
            const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '-'); // HH-MM-SS 형식
            link.setAttribute('download', `particle_photo_data_${dateStr}_${timeStr}.csv`);
            
            // 다운로드 실행
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            this.showMessage(`데이터가 엑셀 파일로 다운로드되었습니다. (총 ${this.people.length}개 항목)`, 'success');
        } catch (error) {
            console.error('Excel download error:', error);
            this.showMessage('엑셀 다운로드 중 오류가 발생했습니다.', 'error');
        }
    }

    // 엑셀 업로드 관련 이벤트 바인딩
    bindExcelUploadEvents() {
        // 업로드 방식 선택 버튼들
        const methodSelectBtns = document.querySelectorAll('.method-select-btn');
        methodSelectBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const method = e.target.closest('.upload-method-option').dataset.method;
                this.selectedUploadMethod = method;
                
                // 파일 input의 accept 속성 업데이트
                const fileInput = document.getElementById('excelFileInput');
                if (method === 'zip') {
                    fileInput.accept = '.zip';
                } else {
                    fileInput.accept = '.csv,.xlsx,.xls';
                }
                
                fileInput.click();
            });
        });

        // 파일 입력 변경
        const fileInput = document.getElementById('excelFileInput');
        if (fileInput) {
            fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
        }

        // 모달 버튼들
        const uploadCancelBtn = document.getElementById('uploadCancelBtn');
        if (uploadCancelBtn) {
            uploadCancelBtn.addEventListener('click', () => this.closeExcelUploadModal());
        }

        const uploadBackBtn = document.getElementById('uploadBackBtn');
        if (uploadBackBtn) {
            uploadBackBtn.addEventListener('click', () => this.showUploadStep(1));
        }

        const startUploadBtn = document.getElementById('startUploadBtn');
        if (startUploadBtn) {
            startUploadBtn.addEventListener('click', () => this.startBulkUpload());
        }

        const uploadCloseBtn = document.getElementById('uploadCloseBtn');
        if (uploadCloseBtn) {
            uploadCloseBtn.addEventListener('click', () => this.closeExcelUploadModal());
        }

        const uploadErrorCloseBtn = document.getElementById('uploadErrorCloseBtn');
        if (uploadErrorCloseBtn) {
            uploadErrorCloseBtn.addEventListener('click', () => this.closeExcelUploadModal());
        }
    }

    // 엑셀 업로드 모달 열기
    openExcelUploadModal() {
        this.selectedCsvData = null;
        this.showUploadStep(1);
        document.getElementById('excelUploadModal').style.display = 'block';
    }

    // 엑셀 업로드 모달 닫기
    closeExcelUploadModal() {
        document.getElementById('excelUploadModal').style.display = 'none';
        document.getElementById('excelFileInput').value = '';
        this.selectedCsvData = null;
        
        // 모든 상태 초기화
        document.getElementById('uploadResults').style.display = 'none';
        document.getElementById('uploadError').style.display = 'none';
        document.getElementById('progressContainer').style.display = 'block';
        document.getElementById('uploadCloseBtn').style.display = 'none';
        document.getElementById('uploadErrorCloseBtn').style.display = 'none';
        
        // 진행률 초기화
        document.getElementById('progressFill').style.width = '0%';
        document.getElementById('progressText').textContent = '0 / 0';
    }

    // 업로드 단계 표시
    showUploadStep(step) {
        // 모든 단계 숨기기
        for (let i = 1; i <= 3; i++) {
            const stepElement = document.getElementById(`uploadStep${i}`);
            if (stepElement) {
                stepElement.style.display = 'none';
            }
        }

        // 선택된 단계 표시
        const activeStep = document.getElementById(`uploadStep${step}`);
        if (activeStep) {
            activeStep.style.display = 'block';
        }
    }

    // 파일 선택 처리
    async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            // ZIP 파일 처리
            if (this.selectedUploadMethod === 'zip' && file.name.toLowerCase().endsWith('.zip')) {
                await this.handleZipFile(file);
                return;
            }
            
            // CSV/Excel 파일 처리
            const content = await this.readFileAsText(file);
            const csvData = this.parseCSV(content);
            
            if (!csvData || csvData.length === 0) {
                this.showMessage('파일에 데이터가 없습니다.', 'error');
                return;
            }

            // 필수 컬럼 확인
            const requiredColumns = ['한글이름', '영문이름'];
            const firstRow = csvData[0];
            const missingColumns = requiredColumns.filter(col => !(col in firstRow));
            
            if (missingColumns.length > 0) {
                this.showMessage(`필수 컬럼이 누락되었습니다: ${missingColumns.join(', ')}`, 'error');
                return;
            }

            this.selectedCsvData = csvData;
            this.showPreview(csvData);
            this.showUploadStep(2);

        } catch (error) {
            console.error('파일 처리 오류:', error);
            this.showMessage('파일 처리 중 오류가 발생했습니다: ' + error.message, 'error');
        }
    }

    // 파일을 텍스트로 읽기
    readFileAsText(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error('파일 읽기 실패'));
            reader.readAsText(file, 'utf-8');
        });
    }

    // CSV 파싱
    parseCSV(content) {
        const lines = content.split('\n').filter(line => line.trim());
        if (lines.length < 2) return [];

        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
        const data = [];

        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
            const row = {};
            
            headers.forEach((header, index) => {
                row[header] = values[index] || '';
            });
            
            data.push(row);
        }

        return data;
    }

    // 미리보기 표시
    showPreview(csvData) {
        const previewContainer = document.getElementById('previewContainer');
        const maxPreviewRows = 5;
        const previewData = csvData.slice(0, maxPreviewRows);

        let html = `
            <p><strong>총 ${csvData.length}개 행</strong> (미리보기: ${previewData.length}개)</p>
            <div style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;">
                <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                    <thead>
                        <tr style="background: #f5f5f5; position: sticky; top: 0;">
        `;

        // 헤더
        const headers = Object.keys(previewData[0]);
        headers.forEach(header => {
            html += `<th style="border: 1px solid #ddd; padding: 8px; text-align: left;">${header}</th>`;
        });

        html += `</tr></thead><tbody>`;

        // 데이터 행들
        previewData.forEach(row => {
            html += `<tr>`;
            headers.forEach(header => {
                const value = row[header] || '';
                html += `<td style="border: 1px solid #ddd; padding: 8px;">${value}</td>`;
            });
            html += `</tr>`;
        });

        html += `</tbody></table></div>`;

        if (csvData.length > maxPreviewRows) {
            html += `<p style="font-size: 12px; color: #666; margin-top: 8px;">... 및 ${csvData.length - maxPreviewRows}개 행 더</p>`;
        }

        previewContainer.innerHTML = html;
    }

    // 벌크 업로드 시작
    async startBulkUpload() {
        if (!this.selectedCsvData) {
            this.showMessage('업로드할 데이터가 없습니다.', 'error');
            return;
        }

        const conflictMode = document.querySelector('input[name="conflictMode"]:checked').value;
        
        this.showUploadStep(3);
        
        try {
            // CSV 데이터를 다시 CSV 문자열로 변환
            const headers = Object.keys(this.selectedCsvData[0]);
            const csvContent = [
                headers.join(','),
                ...this.selectedCsvData.map(row => 
                    headers.map(header => `"${row[header] || ''}"`).join(',')
                )
            ].join('\n');

            // FormData 생성
            const formData = new FormData();
            const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
            formData.append('csvFile', blob, 'upload.csv');
            formData.append('conflictMode', conflictMode);

            // 진행률 표시
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressText.textContent = '업로드 중...';
            progressFill.style.width = '50%';

            // API 호출
            const response = await fetch('/api/people/bulk-upload', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (response.ok) {
                // 성공
                progressFill.style.width = '100%';
                progressText.textContent = '완료';
                
                // 결과 표시
                this.showUploadResults(result.results);
                
                // 데이터 새로고침
                await this.loadPeople();
                this.renderItems();
                
                this.showMessage(result.message, 'success');
            } else {
                throw new Error(result.error || '업로드 실패');
            }

        } catch (error) {
            console.error('업로드 오류:', error);
            this.showUploadError(error.message);
        }
    }

    // 업로드 결과 표시
    showUploadResults(results) {
        const uploadResults = document.getElementById('uploadResults');
        const resultSummary = document.getElementById('resultSummary');
        const uploadCloseBtn = document.getElementById('uploadCloseBtn');

        let html = `
            <div style="background: #f9f9f9; padding: 15px; border-radius: 4px; margin: 15px 0;">
                <p><strong>업로드 완료</strong></p>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    <li>전체: ${results.total}개</li>
                    <li style="color: #27ae60;">성공: ${results.success}개</li>
                    <li style="color: #f39c12;">건너뜀: ${results.skipped}개</li>
                    <li style="color: #e74c3c;">실패: ${results.failed}개</li>
                </ul>
        `;

        if (results.errors && results.errors.length > 0) {
            html += `
                <details style="margin-top: 10px;">
                    <summary style="cursor: pointer; color: #e74c3c;">오류 상세 (${results.errors.length}개)</summary>
                    <ul style="margin: 10px 0; padding-left: 20px; font-size: 12px;">
            `;
            results.errors.forEach(error => {
                html += `<li>${error}</li>`;
            });
            html += `</ul></details>`;
        }

        html += `</div>`;

        resultSummary.innerHTML = html;
        uploadResults.style.display = 'block';
        uploadCloseBtn.style.display = 'block';
    }

    // 업로드 에러 표시
    showUploadError(errorMessage) {
        // 진행률 숨기기
        document.getElementById('progressContainer').style.display = 'none';
        
        // 에러 메시지 표시
        const uploadError = document.getElementById('uploadError');
        const errorMessageDiv = document.getElementById('errorMessage');
        const uploadErrorCloseBtn = document.getElementById('uploadErrorCloseBtn');
        
        errorMessageDiv.textContent = errorMessage;
        uploadError.style.display = 'block';
        uploadErrorCloseBtn.style.display = 'block';
        
        this.showMessage('업로드 중 오류가 발생했습니다: ' + errorMessage, 'error');
    }

    // ZIP 파일 처리
    async handleZipFile(file) {
        try {
            // ZIP 파일 크기 확인 (최대 50MB)
            if (file.size > 50 * 1024 * 1024) {
                this.showMessage('ZIP 파일 크기가 너무 큽니다. (최대 50MB)', 'error');
                return;
            }

            this.showMessage('ZIP 파일을 분석하고 있습니다...', 'info');
            
            // 3단계로 직접 이동 (업로드 진행)
            this.showUploadStep(3);
            
            // 세션 ID 생성
            const sessionId = 'upload_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // 진행률 표시 요소
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressTitle = document.getElementById('uploadProgressTitle');
            
            // SSE 연결 설정
            const eventSource = new EventSource(`/api/upload-progress/${sessionId}`);
            let uploadCompleted = false;
            
            eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'connected') {
                        console.log('진행 상황 스트림 연결됨:', data.sessionId);
                        return;
                    }
                    
                    // 진행 상황 업데이트
                    progressFill.style.width = `${data.progress}%`;
                    progressText.textContent = data.message;
                    
                    if (data.type === 'processing') {
                        progressTitle.textContent = 'ZIP 파일 처리 중...';
                        if (data.currentUser) {
                            progressText.textContent = `${data.message} (${data.currentUser})`;
                        }
                    } else if (data.type === 'uploading') {
                        progressTitle.textContent = '이미지 업로드 중...';
                    } else if (data.type === 'completed') {
                        progressTitle.textContent = '업로드 완료';
                        progressText.textContent = '모든 작업이 완료되었습니다.';
                        uploadCompleted = true;
                        eventSource.close();
                    } else if (data.type === 'error') {
                        progressTitle.textContent = '오류 발생';
                        progressText.textContent = data.message;
                        uploadCompleted = true;
                        eventSource.close();
                    }
                    
                } catch (e) {
                    console.error('진행 상황 파싱 오류:', e);
                }
            };
            
            eventSource.onerror = (error) => {
                console.error('SSE 연결 오류:', error);
                eventSource.close();
            };
            
            // FormData 생성
            const formData = new FormData();
            formData.append('zipFile', file);
            formData.append('conflictMode', 'skip');
            formData.append('sessionId', sessionId);
            
            // 초기 상태 설정
            progressTitle.textContent = 'ZIP 파일 업로드 중...';
            progressText.textContent = '파일 전송 중...';
            progressFill.style.width = '5%';

            // API 호출
            const response = await fetch('/api/people/bulk-upload-zip', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            // SSE가 완료 상태를 받지 못한 경우 대비
            if (!uploadCompleted) {
                eventSource.close();
            }

            if (response.ok) {
                // 성공 처리
                if (!uploadCompleted) {
                    progressFill.style.width = '100%';
                    progressText.textContent = '완료';
                    progressTitle.textContent = '업로드 완료';
                }
                
                // 결과 표시
                this.showUploadResults(result.results);
                
                // 데이터 새로고침
                await this.loadPeople();
                this.renderItems();
                
                this.showMessage(result.message, 'success');
            } else {
                throw new Error(result.error || 'ZIP 업로드 실패');
            }

        } catch (error) {
            console.error('ZIP 업로드 오류:', error);
            this.showUploadError(error.message);
        }
    }
}

let adminManager;
window.addEventListener('DOMContentLoaded', () => {
    adminManager = new AdminManager();
});
window.adminManager = adminManager;
</file>

</files>
