// ÌôòÍ≤Ω Î≥ÄÏàò Î°úÎìú
require('dotenv').config();

const express = require('express');
const multer = require('multer');
const fs = require('fs').promises;
const path = require('path');
const cors = require('cors');
const { parse } = require('csv-parse/sync');
const yauzl = require('yauzl');
const { promisify } = require('util');

// Firebase Ï°∞Í±¥Î∂Ä Î°úÎìú
let firebase = null;
try {
  firebase = require('./firebase');
} catch (error) {
  console.log('Firebase Î™®ÎìàÏùÑ Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§. Î°úÏª¨ ÌååÏùº ÏãúÏä§ÌÖúÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.');
}

const app = express();
const PORT = process.env.PORT || 3000;

// CORS ÏÑ§Ï†ï
const corsOptions = {
  origin: process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(',') : ['http://localhost:3000'],
  credentials: true,
  optionsSuccessStatus: 200
};

// ÏûêÎèô Î≤ÑÏ†Ñ ÏÉùÏÑ± (ÏÑúÎ≤Ñ ÏãúÏûë ÏãúÍ∞Ñ Í∏∞Î∞ò)
const startTime = new Date();
const appVersion = `${startTime.getFullYear()}${String(startTime.getMonth() + 1).padStart(2, '0')}${String(startTime.getDate()).padStart(2, '0')}.${String(startTime.getHours()).padStart(2, '0')}${String(startTime.getMinutes()).padStart(2, '0')}`;

console.log(`üöÄ App Version: ${appVersion}`);

// ÎØ∏Îì§Ïõ®Ïñ¥ ÏÑ§Ï†ï
app.use(cors(corsOptions));
app.use(express.json({ limit: '10mb' }));

// Î≤ÑÏ†Ñ Ï†ïÎ≥¥Î•º ÌÖúÌîåÎ¶ø Î≥ÄÏàòÎ°ú Ï†úÍ≥µÌïòÎäî ÎØ∏Îì§Ïõ®Ïñ¥
app.use((req, res, next) => {
  res.locals.appVersion = appVersion;
  next();
});

app.use(express.static('.')); // ÌòÑÏû¨ ÎîîÎ†âÌÜ†Î¶¨Î•º Ï†ïÏ†Å ÌååÏùº ÏÑúÎ≤ÑÎ°ú ÏÑ§Ï†ï

// ÌååÏùº ÏóÖÎ°úÎìú Î≥¥Ïïà ÏÑ§Ï†ï
const allowedFileTypes = process.env.ALLOWED_FILE_TYPES ? 
  process.env.ALLOWED_FILE_TYPES.split(',') : 
  ['image/jpeg', 'image/png', 'image/gif'];

const maxFileSize = parseInt(process.env.MAX_FILE_SIZE) || 10 * 1024 * 1024; // Í∏∞Î≥∏ 10MB

// ÌååÏùº ÌïÑÌÑ∞ÎßÅ Ìï®Ïàò
const fileFilter = (req, file, cb) => {
  if (allowedFileTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error(`ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌååÏùº ÌÉÄÏûÖÏûÖÎãàÎã§. ÌóàÏö©Îêú ÌÉÄÏûÖ: ${allowedFileTypes.join(', ')}`), false);
  }
};

// Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏÑ§Ï†ï
const storage = multer.diskStorage({
    destination: './images/',
    filename: (req, file, cb) => {
        // ÏûÑÏãú ÌååÏùºÎ™ÖÏúºÎ°ú Ï†ÄÏû• (timestamp + ÌôïÏû•Ïûê)
        cb(null, Date.now() + path.extname(file.originalname));
    }
});

const upload = multer({ 
    storage: multer.memoryStorage(),
    fileFilter: fileFilter,
    limits: {
        fileSize: maxFileSize
    }
});

const PEOPLE_PATH = './images/people.json';

// ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
app.get('/api/items', async (req, res) => {
    try {
        // words.js ÌååÏùº ÏùΩÍ∏∞
        const wordsContent = await fs.readFile('./words.js', 'utf8');

        // originWords Î∞∞Ïó¥ Ï∂îÏ∂ú
        const wordsMatch = wordsContent.match(/export const originWords\s*=\s*\[([\s\S]*?)\]/);
        const textsMatch = wordsContent.match(/export const originTexts\s*=\s*\[([\s\S]*?)\]/);

        let words = [];
        let texts = [];

        if (wordsMatch) {
            const wordsString = wordsMatch[1];
            words = parseArrayFromString(wordsString);
        }

        if (textsMatch) {
            const textsString = textsMatch[1];
            texts = parseArrayFromString(textsString);
        }

        // images.json ÌååÏùº ÏùΩÍ∏∞
        let images = [];
        try {
            const imagesContent = await fs.readFile('./images/images.json', 'utf8');
            images = JSON.parse(imagesContent);
        } catch (error) {
            console.warn('images.json ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
        }

        res.json({ words, texts, images });
    } catch (error) {
        console.error('Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®:', error);
        res.status(500).json({ error: error.message });
    }
});

// Ìï≠Î™© Ï∂îÍ∞Ä (Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú + ÌååÏùº ÏóÖÎç∞Ïù¥Ìä∏)
app.post('/api/items', upload.single('image'), async (req, res) => {
    try {
        const { koreanName, englishName } = req.body;
        console.log('req.file:', req.file);
        console.log('oldPath:', req.file.path);
        console.log('newPath:', path.join(req.file.destination, `${englishName}.png`));
        // ÏóÖÎ°úÎìúÎêú ÌååÏùºÏùò Í≤ΩÎ°ú
        const oldPath = req.file.path;
        const newPath = path.join(req.file.destination, `${englishName}.png`);
        // ÌååÏùºÎ™Ö Î≥ÄÍ≤Ω
        await fs.rename(oldPath, newPath);

        // 1. words.js ÏóÖÎç∞Ïù¥Ìä∏
        await updateWordsJS(koreanName, englishName);

        // 2. images.json ÏóÖÎç∞Ïù¥Ìä∏
        await updateImagesJSON(englishName);

        // 3. index.html ÏóÖÎç∞Ïù¥Ìä∏
        await updateIndexHTML(englishName);

        res.json({
            success: true,
            message: 'Ìï≠Î™©Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.',
            filename: `${englishName}.png`
        });

    } catch (error) {
        console.error('Ìï≠Î™© Ï∂îÍ∞Ä Ïã§Ìå®:', error);
        res.status(500).json({ error: error.message });
    }
});

// Ìï≠Î™© ÏÇ≠Ï†ú
app.delete('/api/items/:englishName', async (req, res) => {
    try {
        const { englishName } = req.params;

        // 1. Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÇ≠Ï†ú
        try {
            await fs.unlink(`./images/${englishName}.png`);
        } catch (error) {
            console.warn(`Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÇ≠Ï†ú Ïã§Ìå®: ${englishName}.png`);
        }

        // 2. ÌååÏùºÎì§ÏóêÏÑú Ï†úÍ±∞
        await removeFromFiles(englishName);

        res.json({
            success: true,
            message: 'Ìï≠Î™©Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.'
        });

    } catch (error) {
        console.error('Ìï≠Î™© ÏÇ≠Ï†ú Ïã§Ìå®:', error);
        res.status(500).json({ error: error.message });
    }
});

// Ìï≠Î™© Ìé∏Ïßë (Ïù¥Î¶Ñ/Ïù¥ÎØ∏ÏßÄ ÍµêÏ≤¥)
app.post('/api/items/:oldEnglishName/edit', upload.single('image'), async (req, res) => {
    try {
        const { oldEnglishName, oldKoreanName, newEnglishName, newKoreanName } = req.body;
        const oldImagePath = path.join('./images/', `${oldEnglishName}.png`);
        const newImagePath = path.join('./images/', `${newEnglishName}.png`);
        // 1. Ïù¥ÎØ∏ÏßÄ ÍµêÏ≤¥(ÏóÖÎ°úÎìú Ïãú)
        if (req.file) {
            // ÏÉà Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÖÎ°úÎìúÎêú Í≤ΩÏö∞: Î¨¥Ï°∞Í±¥ newEnglishName.pngÎ°ú Ï†ÄÏû•
            await fs.writeFile(newImagePath, await fs.readFile(req.file.path));
            await fs.unlink(req.file.path);
            // oldEnglishNameÏù¥ Îã§Î•¥Î©¥ Í∏∞Ï°¥ ÌååÏùº ÏÇ≠Ï†ú
            if (oldEnglishName !== newEnglishName) {
                await fs.unlink(oldImagePath).catch(() => { });
            }
        } else if (oldEnglishName !== newEnglishName) {
            // Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏóÜÏù¥ Ïù¥Î¶ÑÎßå Î∞îÎÄåÎ©¥ ÌååÏùºÎ™Ö Î≥ÄÍ≤Ω
            await fs.rename(oldImagePath, newImagePath);
        }
        // 2. words.js, images.json, index.html ÏóÖÎç∞Ïù¥Ìä∏
        await updateWordsAndFilesOnEdit(oldEnglishName, oldKoreanName, newEnglishName, newKoreanName);
        res.json({ success: true, message: 'Ìï≠Î™©Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.' });
    } catch (error) {
        console.error('Ìï≠Î™© Ìé∏Ïßë Ïã§Ìå®:', error);
        res.status(500).json({ error: error.message });
    }
});

// Ìé∏Ïßë Ïãú words.js, images.json, index.html ÎèôÍ∏∞Ìôî Ìï®Ïàò
async function updateWordsAndFilesOnEdit(oldEnglishName, oldKoreanName, newEnglishName, newKoreanName) {
    // words.js
    const content = await fs.readFile('./words.js', 'utf8');
    const wordsMatch = content.match(/(export const originWords\s*=\s*\[)([\s\S]*?)(\])/);
    const textsMatch = content.match(/(export const originTexts\s*=\s*\[)([\s\S]*?)(\])/);
    if (wordsMatch && textsMatch) {
        let wordsArray = parseArrayFromString(wordsMatch[2]);
        let textsArray = parseArrayFromString(textsMatch[2]);
        const idx = wordsArray.indexOf(oldEnglishName);
        if (idx !== -1) {
            wordsArray[idx] = newEnglishName;
            textsArray[idx] = newKoreanName;
        }
        const newWordsContent = wordsMatch[1] + wordsArray.map(word => `    "${word}"`).join(',\n') + wordsMatch[3];
        const newTextsContent = textsMatch[1] + textsArray.map(text => `    "${text}"`).join(',\n') + textsMatch[3];
        const newContent = content.replace(wordsMatch[0], newWordsContent).replace(textsMatch[0], newTextsContent);
        await fs.writeFile('./words.js', newContent, 'utf8');
    }
    // images.json
    let images = [];
    try {
        const imagesContent = await fs.readFile('./images/images.json', 'utf8');
        images = JSON.parse(imagesContent);
    } catch { }
    const imgIdx = images.indexOf(`${oldEnglishName}.png`);
    if (imgIdx !== -1) {
        images[imgIdx] = `${newEnglishName}.png`;
    }
    await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');
    // index.html
    const htmlContent = await fs.readFile('./index.html', 'utf8');
    const imageTagRegex = new RegExp(`<img src=\"images/${oldEnglishName}\.png\" alt=\"\">`, 'g');
    const newHtmlContent = htmlContent.replace(imageTagRegex, `<img src=\"images/${newEnglishName}.png\" alt=\"\">`);
    await fs.writeFile('./index.html', newHtmlContent, 'utf8');
}

// words.js ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
async function updateWordsJS(koreanName, englishName) {
    try {
        const content = await fs.readFile('./words.js', 'utf8');

        // originWords Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
        const wordsMatch = content.match(/(export const originWords\s*=\s*\[)([\s\S]*?)(\])/);
        if (wordsMatch) {
            const newWordsContent = wordsMatch[1] +
                (wordsMatch[2].trim() ? wordsMatch[2] + ',\n    ' : '\n    ') +
                `"${englishName}"` +
                wordsMatch[3];

            // originTexts Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
            const textsMatch = content.match(/(export const originTexts\s*=\s*\[)([\s\S]*?)(\])/);
            if (textsMatch) {
                const newTextsContent = textsMatch[1] +
                    (textsMatch[2].trim() ? textsMatch[2] + ',\n    ' : '\n    ') +
                    `"${koreanName}"` +
                    textsMatch[3];

                const newContent = content
                    .replace(wordsMatch[0], newWordsContent)
                    .replace(textsMatch[0], newTextsContent);

                await fs.writeFile('./words.js', newContent, 'utf8');
            }
        }
    } catch (error) {
        console.error('words.js ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
        throw error;
    }
}

// images.json ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
async function updateImagesJSON(englishName) {
    try {
        let images = [];
        try {
            const content = await fs.readFile('./images/images.json', 'utf8');
            images = JSON.parse(content);
        } catch (error) {
            console.warn('images.json ÌååÏùºÏù¥ ÏóÜÏñ¥ ÏÉàÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.');
        }

        images.push(`${englishName}.png`);
        await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');
    } catch (error) {
        console.error('images.json ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
        throw error;
    }
}

// index.html ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
async function updateIndexHTML(englishName) {
    try {
        const content = await fs.readFile('./index.html', 'utf8');

        // ÏÉàÎ°úÏö¥ Ïù¥ÎØ∏ÏßÄ ÌÉúÍ∑∏ Ï∂îÍ∞Ä
        const newImageTag = `    <img src="images/${englishName}.png" alt="">\n`;

        // </div> ÌÉúÍ∑∏ ÏïûÏóê Ï∂îÍ∞Ä (Ïà®Í≤®ÏßÑ Ïù¥ÎØ∏ÏßÄ ÏÑπÏÖò)
        const insertPosition = content.lastIndexOf('  </div>');
        if (insertPosition !== -1) {
            const newContent = content.slice(0, insertPosition) + newImageTag + content.slice(insertPosition);
            await fs.writeFile('./index.html', newContent, 'utf8');
        }
    } catch (error) {
        console.error('index.html ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', error);
        throw error;
    }
}

// ÌååÏùºÎì§ÏóêÏÑú Ìï≠Î™© Ï†úÍ±∞ Ìï®Ïàò
async function removeFromFiles(englishName) {
    try {
        // 1. words.jsÏóêÏÑú Ï†úÍ±∞
        const wordsContent = await fs.readFile('./words.js', 'utf8');
        const wordsMatch = wordsContent.match(/(export const originWords\s*=\s*\[)([\s\S]*?)(\])/);
        const textsMatch = wordsContent.match(/(export const originTexts\s*=\s*\[)([\s\S]*?)(\])/);

        if (wordsMatch && textsMatch) {
            const wordsArray = parseArrayFromString(wordsMatch[2]);
            const textsArray = parseArrayFromString(textsMatch[2]);

            const wordIndex = wordsArray.indexOf(englishName);
            if (wordIndex !== -1) {
                wordsArray.splice(wordIndex, 1);
                textsArray.splice(wordIndex, 1);

                const newWordsContent = wordsMatch[1] +
                    wordsArray.map(word => `    "${word}"`).join(',\n') +
                    wordsMatch[3];
                const newTextsContent = textsMatch[1] +
                    textsArray.map(text => `    "${text}"`).join(',\n') +
                    textsMatch[3];

                const newContent = wordsContent
                    .replace(wordsMatch[0], newWordsContent)
                    .replace(textsMatch[0], newTextsContent);

                await fs.writeFile('./words.js', newContent, 'utf8');
            }
        }

        // 2. images.jsonÏóêÏÑú Ï†úÍ±∞
        try {
            const imagesContent = await fs.readFile('./images/images.json', 'utf8');
            let images = JSON.parse(imagesContent);
            images = images.filter(img => img !== `${englishName}.png`);
            await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');
        } catch (error) {
            console.warn('images.json ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
        }

        // 3. index.htmlÏóêÏÑú Ï†úÍ±∞
        const htmlContent = await fs.readFile('./index.html', 'utf8');
        const imageTagRegex = new RegExp(`\\s*<img src="images/${englishName}\\.png" alt="">\\s*\\n?`, 'g');
        const newHtmlContent = htmlContent.replace(imageTagRegex, '');
        await fs.writeFile('./index.html', newHtmlContent, 'utf8');

    } catch (error) {
        console.error('ÌååÏùºÏóêÏÑú Ìï≠Î™© Ï†úÍ±∞ Ïã§Ìå®:', error);
        throw error;
    }
}

// Î¨∏ÏûêÏó¥ Î∞∞Ïó¥ ÌååÏã± Ìï®Ïàò
function parseArrayFromString(arrayString) {
    const matches = arrayString.match(/"([^"]*)"/g);
    if (matches) {
        return matches.map(match => match.slice(1, -1));
    }
    return [];
}

// FirestoreÏóêÏÑú people Î™©Î°ù Ï°∞Ìöå
app.get('/api/people', async (req, res) => {
    try {
        console.log('GET /api/people ÏöîÏ≤≠ Î∞õÏùå');
        if (firebase && firebase.db) {
            const snapshot = await firebase.db.collection('people').get();
            const people = snapshot.docs.map(doc => doc.data());
            console.log(`${people.length}Í∞úÏùò people Îç∞Ïù¥ÌÑ∞ Î∞òÌôò`);
            res.json(people);
        } else {
            // Î°úÏª¨ ÌååÏùº ÏãúÏä§ÌÖú ÏÇ¨Ïö© (Firebase ÎØ∏ÏÑ§Ï†ï Ïãú)
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                console.log('people.json ÌååÏùºÏù¥ ÏóÜÏñ¥ Îπà Î∞∞Ïó¥ Î∞òÌôò');
            }
            res.json(people);
        }
    } catch (error) {
        console.error('GET /api/people ÏóêÎü¨:', error);
        res.status(500).json({ error: error.message });
    }
});

// Firestore Í∏∞Î∞ò ÎèôÍ∏∞Ìôî Ìï®Ïàò
async function syncLegacyFilesFromFirestore() {
    if (!firebase || !firebase.db) {
        console.log('FirebaseÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïÑ ÎèôÍ∏∞ÌôîÎ•º Í±¥ÎÑàÎúÅÎãàÎã§.');
        return;
    }
    
    try {
        // 1. FirestoreÏóêÏÑú people Ï†ÑÏ≤¥ Î™©Î°ù Ï°∞Ìöå
        const snapshot = await firebase.db.collection('people').get();
        const people = snapshot.docs.map(doc => doc.data());

        // 2. words.js ÏÉùÏÑ±
        const words = people.map(p => `    "${p.englishName}"`).join(',\n');
        const texts = people.map(p => `    "${p.koreanName}"`).join(',\n');
        const wordsJs = `export function shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}\nexport const originWords = [\n${words}\n];\n\nexport const originTexts = [\n${texts}\n];\n`;
        await fs.writeFile('./words.js', wordsJs, 'utf8');

        // 3. images.json ÏÉùÏÑ±
        const images = people.map(p => p.imageFile || (p.englishName + '.png'));
        await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');

        // 4. index.htmlÏùò Ïà®Í≤®ÏßÑ Ïù¥ÎØ∏ÏßÄ ÌÉúÍ∑∏ ÏòÅÏó≠ ÎèôÍ∏∞Ìôî
        let html = await fs.readFile('./index.html', 'utf8');
        html = html.replace(/(<div style="display: none;">)[\s\S]*?(<\/div>)/, (m, p1, p2) => {
            // imageUrl(Download URL) Ïö∞ÏÑ† ÏÇ¨Ïö©
            const tags = people.map(p => `    <img src="${p.imageUrl}" alt="">`).join('\n');
            return `${p1}\n${tags}\n${p2}`;
        });
        await fs.writeFile('./index.html', html, 'utf8');
    } catch (error) {
        console.error('Firestore ÎèôÍ∏∞Ìôî Ïã§Ìå®:', error);
    }
}

app.post('/api/people', upload.single('image'), async (req, res) => {
    try {
        const { koreanName, englishName, organization, role, position, email } = req.body;
        const file = req.file;
        let imageUrl = '';

        // FirebaseÍ∞Ä ÏÑ§Ï†ïÎêú Í≤ΩÏö∞ÏóêÎßå Firebase ÏÇ¨Ïö©
        if (firebase && firebase.db && firebase.bucket) {
            if (file) {
                // 1. StorageÏóê Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
                const storageFile = firebase.bucket.file(`images/${englishName}.png`);
                await storageFile.save(file.buffer, {
                    metadata: { contentType: file.mimetype }
                });
                // 2. Download URL(Í≥µÍ∞ú ÎßÅÌÅ¨) ÏÉùÏÑ±
                const [url] = await storageFile.getSignedUrl({
                    action: 'read',
                    expires: '03-09-2491' // Ï∂©Î∂ÑÌûà Î®º ÎØ∏Îûò
                });
                imageUrl = url;
            }

            // 3. FirestoreÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
            await firebase.db.collection('people').doc(englishName).set({
                koreanName, englishName, organization, role, position, email, imageUrl
            });
            // 4. ÌååÏùº ÎèôÍ∏∞Ìôî
            await syncLegacyFilesFromFirestore();
        } else {
            // Î°úÏª¨ ÌååÏùº ÏãúÏä§ÌÖú ÏÇ¨Ïö©
            if (file) {
                const imagePath = path.join('./images/', `${englishName}.png`);
                await fs.writeFile(imagePath, file.buffer);
                imageUrl = `images/${englishName}.png`;
            }
            
            // people.jsonÏóê Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                console.log('people.json ÌååÏùºÏù¥ ÏóÜÏñ¥ ÏÉàÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.');
            }
            
            people.push({
                koreanName, englishName, organization, role, position, email, 
                imageFile: `${englishName}.png`
            });
            
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }

        res.json({ success: true, message: 'Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.patch('/api/people/:englishName', upload.single('image'), async (req, res) => {
    try {
        const { englishName } = req.params;
        const { koreanName, newEnglishName, organization, role, position, email } = req.body;
        const file = req.file;

        // FirebaseÍ∞Ä ÏÑ§Ï†ïÎêú Í≤ΩÏö∞ÏóêÎßå Firebase ÏÇ¨Ïö©
        if (firebase && firebase.db && firebase.bucket) {
            // FirestoreÏóêÏÑú Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
            const doc = await firebase.db.collection('people').doc(englishName).get();
            if (!doc.exists) return res.status(404).json({ error: 'Not found' });
            const person = doc.data();

            let imageUrl = person.imageUrl;

            // Ïù¥ÎØ∏ÏßÄ ÍµêÏ≤¥ Ïãú Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú ÌõÑ ÏÉà Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
            if (file) {
                // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú
                await firebase.bucket.file(`images/${englishName}.png`).delete().catch(() => { });
                // ÏÉà Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
                const newFileName = `images/${newEnglishName || englishName}.png`;
                await firebase.bucket.file(newFileName).save(file.buffer, {
                    metadata: { contentType: file.mimetype }
                });
                // Download URL ÏÉùÏÑ±
                const [url] = await firebase.bucket.file(newFileName).getSignedUrl({
                    action: 'read',
                    expires: '03-09-2491'
                });
                imageUrl = url;
            } else if (newEnglishName && newEnglishName !== englishName) {
                // Ïù¥Î¶ÑÎßå Î∞îÎÄåÎ©¥ ÌååÏùºÎ™Ö Î≥ÄÍ≤Ω
                await firebase.bucket.file(`images/${englishName}.png`).move(`images/${newEnglishName}.png`);
                // Download URL ÏÉùÏÑ±
                const [url] = await firebase.bucket.file(`images/${newEnglishName}.png`).getSignedUrl({
                    action: 'read',
                    expires: '03-09-2491'
                });
                imageUrl = url;
            }

            // Firestore Îç∞Ïù¥ÌÑ∞ ÏàòÏ†ï
            await firebase.db.collection('people').doc(newEnglishName || englishName).set({
                koreanName,
                englishName: newEnglishName || englishName,
                organization,
                role,
                position,
                email,
                imageUrl
            });

            // Í∏∞Ï°¥ Î¨∏ÏÑú ÏÇ≠Ï†ú(Ïù¥Î¶ÑÏù¥ Î∞îÎÄê Í≤ΩÏö∞)
            if (newEnglishName && newEnglishName !== englishName) {
                await firebase.db.collection('people').doc(englishName).delete();
            }

            // 4. ÌååÏùº ÎèôÍ∏∞Ìôî
            await syncLegacyFilesFromFirestore();
        } else {
            // Î°úÏª¨ ÌååÏùº ÏãúÏä§ÌÖú ÏÇ¨Ïö©
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                return res.status(404).json({ error: 'Not found' });
            }
            
            const personIndex = people.findIndex(p => p.englishName === englishName);
            if (personIndex === -1) return res.status(404).json({ error: 'Not found' });
            
            // Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨
            if (file) {
                const imagePath = path.join('./images/', `${newEnglishName || englishName}.png`);
                await fs.writeFile(imagePath, file.buffer);
                
                // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú
                if (newEnglishName && newEnglishName !== englishName) {
                    try {
                        await fs.unlink(path.join('./images/', `${englishName}.png`));
                    } catch (error) {
                        console.warn('Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú Ïã§Ìå®:', error);
                    }
                }
            } else if (newEnglishName && newEnglishName !== englishName) {
                // ÌååÏùºÎ™Ö Î≥ÄÍ≤Ω
                try {
                    await fs.rename(
                        path.join('./images/', `${englishName}.png`),
                        path.join('./images/', `${newEnglishName}.png`)
                    );
                } catch (error) {
                    console.warn('Ïù¥ÎØ∏ÏßÄ ÌååÏùºÎ™Ö Î≥ÄÍ≤Ω Ïã§Ìå®:', error);
                }
            }
            
            // Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            people[personIndex] = {
                koreanName,
                englishName: newEnglishName || englishName,
                organization,
                role,
                position,
                email,
                imageFile: `${newEnglishName || englishName}.png`
            };
            
            // Ïù¥Î¶ÑÏù¥ Î∞îÎÄê Í≤ΩÏö∞ Í∏∞Ï°¥ Ìï≠Î™© ÏÇ≠Ï†ú
            if (newEnglishName && newEnglishName !== englishName) {
                people.splice(personIndex, 1);
            }
            
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }

        res.json({ success: true, message: 'ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.delete('/api/people/:englishName', async (req, res) => {
    try {
        const { englishName } = req.params;
        
        // FirebaseÍ∞Ä ÏÑ§Ï†ïÎêú Í≤ΩÏö∞ÏóêÎßå Firebase ÏÇ¨Ïö©
        if (firebase && firebase.db && firebase.bucket) {
            // FirestoreÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
            const doc = await firebase.db.collection('people').doc(englishName).get();
            if (!doc.exists) return res.status(404).json({ error: 'Not found' });
            const person = doc.data();
            // StorageÏóêÏÑú Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú
            if (person.imageUrl) {
                const fileName = `images/${englishName}.png`;
                await firebase.bucket.file(fileName).delete().catch(() => { });
            }
            // FirestoreÏóêÏÑú Î¨∏ÏÑú ÏÇ≠Ï†ú
            await firebase.db.collection('people').doc(englishName).delete();
            // 4. ÌååÏùº ÎèôÍ∏∞Ìôî
            await syncLegacyFilesFromFirestore();
        } else {
            // Î°úÏª¨ ÌååÏùº ÏãúÏä§ÌÖú ÏÇ¨Ïö©
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                return res.status(404).json({ error: 'Not found' });
            }
            
            const personIndex = people.findIndex(p => p.englishName === englishName);
            if (personIndex === -1) return res.status(404).json({ error: 'Not found' });
            
            // Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÇ≠Ï†ú
            try {
                await fs.unlink(path.join('./images/', `${englishName}.png`));
            } catch (error) {
                console.warn('Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÇ≠Ï†ú Ïã§Ìå®:', error);
            }
            
            // Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Ï†úÍ±∞
            people.splice(personIndex, 1);
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }
        
        res.json({ success: true, message: 'ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// people.json ‚Üí words.js, images.json, index.html ÎèôÍ∏∞Ìôî
async function syncLegacyFilesFromPeople() {
    const people = JSON.parse(await fs.readFile(PEOPLE_PATH, 'utf8'));
    // words.js
    const words = people.map(p => `    "${p.englishName}"`).join(',\n');
    const texts = people.map(p => `    "${p.koreanName}"`).join(',\n');
    const wordsJs = `export function shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}\nexport const originWords = [\n${words}\n];\n\nexport const originTexts = [\n${texts}\n];\n`;
    await fs.writeFile('./words.js', wordsJs, 'utf8');
    // images.json
    const images = people.map(p => p.imageFile);
    await fs.writeFile('./images/images.json', JSON.stringify(images, null, 4), 'utf8');
    // index.html (Ïà®Í≤®ÏßÑ Ïù¥ÎØ∏ÏßÄ ÌÉúÍ∑∏ ÏòÅÏó≠Îßå ÎèôÍ∏∞Ìôî)
    let html = await fs.readFile('./index.html', 'utf8');
    html = html.replace(/(<div style="display: none;">)[\s\S]*?(<\/div>)/, (m, p1, p2) => {
        const tags = people.map(p => `    <img src="images/${p.imageFile}" alt="">`).join('\n');
        return `${p1}\n${tags}\n${p2}`;
    });
    await fs.writeFile('./index.html', html, 'utf8');
}

// people.json ‚Üí Firestore/Storage ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ìï®Ïàò
async function migratePeopleToFirebase() {
    if (!firebase || !firebase.db || !firebase.bucket) {
        console.log('FirebaseÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïÑ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§.');
        return;
    }
    
    try {
        const people = JSON.parse(await fs.readFile(PEOPLE_PATH, 'utf8'));
        for (const person of people) {
            // 1. Ïù¥ÎØ∏ÏßÄ ÌååÏùº Storage ÏóÖÎ°úÎìú
            const localImagePath = path.join('./images/', person.imageFile);
            const storageFile = firebase.bucket.file(`images/${person.imageFile}`);
            await storageFile.save(await fs.readFile(localImagePath), {
                metadata: { contentType: 'image/png' }
            });
            // 2. public URL ÏÉùÏÑ±
            const imageUrl = `https://storage.googleapis.com/${firebase.bucket.name}/images/${person.imageFile}`;
            // 3. FirestoreÏóê Ï†ÄÏû•
            await firebase.db.collection('people').doc(person.englishName).set({
                ...person,
                imageUrl
            });
            console.log(`ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å: ${person.englishName}`);
        }
    } catch (error) {
        console.error('ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìå®:', error);
        throw error;
    }
}

// people.json ‚Üí Firebase ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò API (Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©)
app.post('/api/migrate/people-to-firebase', async (req, res) => {
    try {
        await migratePeopleToFirebase();
        res.json({ success: true, message: 'ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// CSV ÌååÏùº ÏóÖÎ°úÎìúÎ•º ÏúÑÌïú multer ÏÑ§Ï†ï
const csvUpload = multer({
    storage: multer.memoryStorage(), // Î©îÎ™®Î¶¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÏÇ¨Ïö©
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB Ï†úÌïú
    fileFilter: (req, file, cb) => {
        const allowedTypes = ['text/csv', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'];
        if (allowedTypes.includes(file.mimetype) || file.originalname.endsWith('.csv')) {
            cb(null, true);
        } else {
            cb(new Error('CSV ÎòêÎäî Excel ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§.'), false);
        }
    }
});

// Î≤åÌÅ¨ ÏóÖÎ°úÎìú API
app.post('/api/people/bulk-upload', csvUpload.single('csvFile'), async (req, res) => {
    try {
        const file = req.file;
        const { conflictMode = 'skip' } = req.body;

        if (!file) {
            return res.status(400).json({ error: 'ÌååÏùºÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.' });
        }

        // CSV ÌååÏã±
        let csvData;
        try {
            // BOM Ï†úÍ±∞ Î∞è CSV ÌååÏã±
            let csvContent = file.buffer.toString('utf-8');
            // UTF-8 BOM Ï†úÍ±∞
            if (csvContent.charCodeAt(0) === 0xFEFF) {
                csvContent = csvContent.slice(1);
            }
            
            csvData = parse(csvContent, {
                columns: true,
                skip_empty_lines: true,
                trim: true
            });
        } catch (parseError) {
            return res.status(400).json({ error: 'CSV ÌååÏùº ÌååÏã±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + parseError.message });
        }

        if (!csvData || csvData.length === 0) {
            return res.status(400).json({ error: 'Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.' });
        }

        // ÌïÑÏàò Ïª¨Îüº ÌôïÏù∏
        const requiredColumns = ['ÌïúÍ∏ÄÏù¥Î¶Ñ', 'ÏòÅÎ¨∏Ïù¥Î¶Ñ'];
        const firstRow = csvData[0];
        const missingColumns = requiredColumns.filter(col => !(col in firstRow));
        
        if (missingColumns.length > 0) {
            return res.status(400).json({ 
                error: `ÌïÑÏàò Ïª¨ÎüºÏù¥ ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§: ${missingColumns.join(', ')}` 
            });
        }

        const results = {
            total: csvData.length,
            success: 0,
            failed: 0,
            skipped: 0,
            errors: []
        };

        // Firebase ÎòêÎäî Î°úÏª¨ ÌååÏùºÏãúÏä§ÌÖúÏóê Îî∞Îùº Ï≤òÎ¶¨
        if (firebase && firebase.db) {
            // Firebase Ï≤òÎ¶¨
            updateProgress('processing', 'ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë...', 30, {
                totalEntries: csvData.length,
                processedEntries: 0
            });
            
            for (let i = 0; i < csvData.length; i++) {
                // ÏßÑÌñâ ÏÉÅÌô© ÏóÖÎç∞Ïù¥Ìä∏ (30% ~ 70% Î≤îÏúÑÏóêÏÑú)
                const currentProgress = 30 + Math.floor((i / csvData.length) * 40);
                updateProgress('processing', `ÏÇ¨Ïö©Ïûê ${i + 1}/${csvData.length} Ï≤òÎ¶¨ Ï§ë...`, currentProgress, {
                    totalEntries: csvData.length,
                    processedEntries: i,
                    currentUser: csvData[i]['ÏòÅÎ¨∏Ïù¥Î¶Ñ'] || csvData[i]['ÌïúÍ∏ÄÏù¥Î¶Ñ'] || 'Unknown'
                });
                
                const row = csvData[i];
                try {
                    const personData = {
                        koreanName: row['ÌïúÍ∏ÄÏù¥Î¶Ñ'] || '',
                        englishName: row['ÏòÅÎ¨∏Ïù¥Î¶Ñ'] || '',
                        organization: row['Ï°∞ÏßÅ'] || '',
                        role: row['ÏßÅÎ¨¥'] || '',
                        position: row['ÏßÅÏúÑ'] || '',
                        email: row['Ïù¥Î©îÏùº'] || '',
                        imageUrl: ''
                    };

                    // ÏòÅÎ¨∏ Ïù¥Î¶Ñ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
                    if (!personData.englishName) {
                        results.failed++;
                        results.errors.push(`Ìñâ ${i + 2}: ÏòÅÎ¨∏Ïù¥Î¶ÑÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.`);
                        continue;
                    }

                    // Ï§ëÎ≥µ ÌôïÏù∏
                    const existingDoc = await firebase.db.collection('people').doc(personData.englishName).get();
                    
                    if (existingDoc.exists && conflictMode === 'skip') {
                        results.skipped++;
                        continue;
                    }

                    // FirestoreÏóê Ï†ÄÏû•
                    await firebase.db.collection('people').doc(personData.englishName).set(personData);
                    results.success++;
                } catch (error) {
                    results.failed++;
                    results.errors.push(`Ìñâ ${i + 2}: ${error.message}`);
                }
            }

            // Î†àÍ±∞Ïãú ÌååÏùº ÎèôÍ∏∞Ìôî
            await syncLegacyFilesFromFirestore();
        } else {
            // Î°úÏª¨ ÌååÏùºÏãúÏä§ÌÖú Ï≤òÎ¶¨
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                // ÌååÏùºÏù¥ ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥Î°ú ÏãúÏûë
            }

            for (let i = 0; i < csvData.length; i++) {
                const row = csvData[i];
                try {
                    const personData = {
                        koreanName: row['ÌïúÍ∏ÄÏù¥Î¶Ñ'] || '',
                        englishName: row['ÏòÅÎ¨∏Ïù¥Î¶Ñ'] || '',
                        organization: row['Ï°∞ÏßÅ'] || '',
                        role: row['ÏßÅÎ¨¥'] || '',
                        position: row['ÏßÅÏúÑ'] || '',
                        email: row['Ïù¥Î©îÏùº'] || '',
                        imageFile: `${row['ÏòÅÎ¨∏Ïù¥Î¶Ñ']}.png`
                    };

                    // ÏòÅÎ¨∏ Ïù¥Î¶Ñ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
                    if (!personData.englishName) {
                        results.failed++;
                        results.errors.push(`Ìñâ ${i + 2}: ÏòÅÎ¨∏Ïù¥Î¶ÑÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.`);
                        continue;
                    }

                    // Ï§ëÎ≥µ ÌôïÏù∏
                    const existingIndex = people.findIndex(p => p.englishName === personData.englishName);
                    
                    if (existingIndex !== -1 && conflictMode === 'skip') {
                        results.skipped++;
                        continue;
                    }

                    if (existingIndex !== -1) {
                        // ÎçÆÏñ¥Ïì∞Í∏∞
                        people[existingIndex] = { ...people[existingIndex], ...personData };
                    } else {
                        // ÏÉàÎ°ú Ï∂îÍ∞Ä
                        people.push(personData);
                    }
                    
                    results.success++;
                } catch (error) {
                    results.failed++;
                    results.errors.push(`Ìñâ ${i + 2}: ${error.message}`);
                }
            }

            // people.json ÌååÏùº Ï†ÄÏû•
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }

        res.json({
            success: true,
            message: 'Î≤åÌÅ¨ ÏóÖÎ°úÎìúÍ∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.',
            results
        });

    } catch (error) {
        console.error('Î≤åÌÅ¨ ÏóÖÎ°úÎìú ÏóêÎü¨:', error);
        res.status(500).json({ error: 'Î≤åÌÅ¨ ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message });
    }
});

// ZIP ÌååÏùºÏùÑ ÏúÑÌïú multer ÏÑ§Ï†ï
const zipUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 50 * 1024 * 1024 }, // 50MB Ï†úÌïú
    fileFilter: (req, file, cb) => {
        if (file.mimetype === 'application/zip' || file.originalname.endsWith('.zip')) {
            cb(null, true);
        } else {
            cb(new Error('ZIP ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§.'), false);
        }
    }
});

// ÏßÑÌñâ ÏÉÅÌô©ÏùÑ Ï†ÄÏû•Ìï† Í∞ùÏ≤¥
const uploadProgress = new Map();

// SSEÎ•º ÏúÑÌïú ÏßÑÌñâ ÏÉÅÌô© Ïä§Ìä∏Î¶º API
app.get('/api/upload-progress/:sessionId', (req, res) => {
    const sessionId = req.params.sessionId;
    
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
    });

    // Ï¶âÏãú Ïó∞Í≤∞ ÌôïÏù∏ Î©îÏãúÏßÄ Ï†ÑÏÜ°
    res.write(`data: ${JSON.stringify({ type: 'connected', sessionId })}\n\n`);

    // ÏßÑÌñâ ÏÉÅÌô© ÏóÖÎç∞Ïù¥Ìä∏Î•º ÌôïÏù∏ÌïòÎäî Ïù∏ÌÑ∞Î≤å
    const interval = setInterval(() => {
        const progress = uploadProgress.get(sessionId);
        if (progress) {
            res.write(`data: ${JSON.stringify(progress)}\n\n`);
            
            // ÏôÑÎ£åÎêòÎ©¥ ÏÑ∏ÏÖò Ï†ïÎ¶¨
            if (progress.type === 'completed' || progress.type === 'error') {
                uploadProgress.delete(sessionId);
                clearInterval(interval);
                res.end();
            }
        }
    }, 100);

    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ï¢ÖÎ£å Ï≤òÎ¶¨
    req.on('close', () => {
        clearInterval(interval);
        uploadProgress.delete(sessionId);
    });
});

// ZIP ÌååÏùº Î≤åÌÅ¨ ÏóÖÎ°úÎìú API
app.post('/api/people/bulk-upload-zip', zipUpload.single('zipFile'), async (req, res) => {
    try {
        const file = req.file;
        const { conflictMode = 'skip', sessionId } = req.body;

        if (!file) {
            return res.status(400).json({ error: 'ZIP ÌååÏùºÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.' });
        }

        // ÏßÑÌñâ ÏÉÅÌô© ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        const updateProgress = (type, message, progress = 0, details = {}) => {
            if (sessionId) {
                uploadProgress.set(sessionId, {
                    type,
                    message,
                    progress,
                    timestamp: Date.now(),
                    ...details
                });
            }
        };

        // ZIP ÌååÏùº Ï≤òÎ¶¨
        updateProgress('processing', 'ZIP ÌååÏùº Î∂ÑÏÑù Ï§ë...', 10);
        console.log('ZIP ÌååÏùº Ï≤òÎ¶¨ ÏãúÏûë...');
        const zipData = await processZipFile(file.buffer);
        console.log(`ZIP ÌååÏùº Î∂ÑÏÑù ÏôÑÎ£å - CSV: ${zipData.csv ? 'ÏûàÏùå' : 'ÏóÜÏùå'}, Ïù¥ÎØ∏ÏßÄ: ${Object.keys(zipData.images).length}Í∞ú`);
        console.log('Î∞úÍ≤¨Îêú Ïù¥ÎØ∏ÏßÄ ÌååÏùºÎì§:', Object.keys(zipData.images));
        
        updateProgress('processing', 'CSV Îç∞Ïù¥ÌÑ∞ ÌååÏã± Ï§ë...', 20, {
            totalImages: Object.keys(zipData.images).length
        });
        
        if (!zipData.csv) {
            return res.status(400).json({ error: 'ZIP ÌååÏùºÏóê CSV ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.' });
        }

        // CSV Îç∞Ïù¥ÌÑ∞ ÌååÏã±
        let csvData;
        try {
            // BOM Ï†úÍ±∞
            let csvContent = zipData.csv;
            if (csvContent.charCodeAt(0) === 0xFEFF) {
                csvContent = csvContent.slice(1);
            }
            
            csvData = parse(csvContent, {
                columns: true,
                skip_empty_lines: true,
                trim: true
            });
        } catch (parseError) {
            return res.status(400).json({ error: 'CSV ÌååÏùº ÌååÏã±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + parseError.message });
        }

        if (!csvData || csvData.length === 0) {
            return res.status(400).json({ error: 'Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.' });
        }

        // ÌïÑÏàò Ïª¨Îüº ÌôïÏù∏
        const requiredColumns = ['ÌïúÍ∏ÄÏù¥Î¶Ñ', 'ÏòÅÎ¨∏Ïù¥Î¶Ñ'];
        const firstRow = csvData[0];
        const missingColumns = requiredColumns.filter(col => !(col in firstRow));
        
        if (missingColumns.length > 0) {
            return res.status(400).json({ 
                error: `ÌïÑÏàò Ïª¨ÎüºÏù¥ ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§: ${missingColumns.join(', ')}` 
            });
        }

        const results = {
            total: csvData.length,
            success: 0,
            failed: 0,
            skipped: 0,
            errors: []
        };

        // Firebase ÎòêÎäî Î°úÏª¨ ÌååÏùºÏãúÏä§ÌÖúÏóê Îî∞Îùº Ï≤òÎ¶¨
        if (firebase && firebase.db) {
            // Firebase Ï≤òÎ¶¨
            updateProgress('processing', 'ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë...', 30, {
                totalEntries: csvData.length,
                processedEntries: 0
            });
            
            for (let i = 0; i < csvData.length; i++) {
                // ÏßÑÌñâ ÏÉÅÌô© ÏóÖÎç∞Ïù¥Ìä∏ (30% ~ 70% Î≤îÏúÑÏóêÏÑú)
                const currentProgress = 30 + Math.floor((i / csvData.length) * 40);
                updateProgress('processing', `ÏÇ¨Ïö©Ïûê ${i + 1}/${csvData.length} Ï≤òÎ¶¨ Ï§ë...`, currentProgress, {
                    totalEntries: csvData.length,
                    processedEntries: i,
                    currentUser: csvData[i]['ÏòÅÎ¨∏Ïù¥Î¶Ñ'] || csvData[i]['ÌïúÍ∏ÄÏù¥Î¶Ñ'] || 'Unknown'
                });
                
                const row = csvData[i];
                try {
                    const personData = {
                        koreanName: row['ÌïúÍ∏ÄÏù¥Î¶Ñ'] || '',
                        englishName: row['ÏòÅÎ¨∏Ïù¥Î¶Ñ'] || '',
                        organization: row['Ï°∞ÏßÅ'] || '',
                        role: row['ÏßÅÎ¨¥'] || '',
                        position: row['ÏßÅÏúÑ'] || '',
                        email: row['Ïù¥Î©îÏùº'] || '',
                        imageUrl: ''
                    };

                    if (!personData.englishName) {
                        results.failed++;
                        results.errors.push(`Ìñâ ${i + 2}: ÏòÅÎ¨∏Ïù¥Î¶ÑÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.`);
                        continue;
                    }

                    // Ï§ëÎ≥µ ÌôïÏù∏
                    const existingDoc = await firebase.db.collection('people').doc(personData.englishName).get();
                    
                    if (existingDoc.exists && conflictMode === 'skip') {
                        results.skipped++;
                        continue;
                    }

                    // Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨
                    const imageKey = `${personData.englishName}.png`;
                    const imageKeyJpg = `${personData.englishName}.jpg`;
                    const imageKeyJpeg = `${personData.englishName}.jpeg`;
                    
                    let imageBuffer = null;
                    let imageExt = null;
                    
                    if (zipData.images[imageKey]) {
                        imageBuffer = zipData.images[imageKey];
                        imageExt = 'png';
                    } else if (zipData.images[imageKeyJpg]) {
                        imageBuffer = zipData.images[imageKeyJpg];
                        imageExt = 'jpg';
                    } else if (zipData.images[imageKeyJpeg]) {
                        imageBuffer = zipData.images[imageKeyJpeg];
                        imageExt = 'jpeg';
                    }
                    
                    if (imageBuffer && imageExt) {
                        try {
                            updateProgress('uploading', `Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ï§ë: ${personData.englishName}.${imageExt}`, currentProgress + 5, {
                                totalEntries: csvData.length,
                                processedEntries: i,
                                currentUser: personData.englishName,
                                currentAction: 'uploading_image'
                            });
                            
                            console.log(`FirebaseÏóê Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏãúÏûë: ${personData.englishName}.${imageExt}`);
                            const imageUrl = await uploadImageToFirebase(imageBuffer, `${personData.englishName}.${imageExt}`);
                            personData.imageUrl = imageUrl;
                            console.log(`Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏÑ±Í≥µ: ${personData.englishName} -> ${imageUrl.substring(0, 100)}...`);
                        } catch (imageError) {
                            console.error(`Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå®: ${personData.englishName} -`, imageError.message);
                            results.errors.push(`Ìñâ ${i + 2}: Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå® - ${imageError.message}`);
                        }
                    } else {
                        console.log(`Ïù¥ÎØ∏ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: ${personData.englishName} (Ï∞æÏùÄ Ïù¥ÎØ∏ÏßÄ: ${Object.keys(zipData.images).join(', ')})`);
                    }

                    // FirestoreÏóê Ï†ÄÏû•
                    await firebase.db.collection('people').doc(personData.englishName).set(personData);
                    results.success++;
                } catch (error) {
                    results.failed++;
                    results.errors.push(`Ìñâ ${i + 2}: ${error.message}`);
                }
            }

            // Î†àÍ±∞Ïãú ÌååÏùº ÎèôÍ∏∞Ìôî
            await syncLegacyFilesFromFirestore();
        } else {
            // Î°úÏª¨ ÌååÏùºÏãúÏä§ÌÖú Ï≤òÎ¶¨
            let people = [];
            try {
                const peopleContent = await fs.readFile('./images/people.json', 'utf8');
                people = JSON.parse(peopleContent);
            } catch (error) {
                // ÌååÏùºÏù¥ ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥Î°ú ÏãúÏûë
            }

            for (let i = 0; i < csvData.length; i++) {
                const row = csvData[i];
                try {
                    const personData = {
                        koreanName: row['ÌïúÍ∏ÄÏù¥Î¶Ñ'] || '',
                        englishName: row['ÏòÅÎ¨∏Ïù¥Î¶Ñ'] || '',
                        organization: row['Ï°∞ÏßÅ'] || '',
                        role: row['ÏßÅÎ¨¥'] || '',
                        position: row['ÏßÅÏúÑ'] || '',
                        email: row['Ïù¥Î©îÏùº'] || '',
                        imageFile: `${row['ÏòÅÎ¨∏Ïù¥Î¶Ñ']}.png`
                    };

                    if (!personData.englishName) {
                        results.failed++;
                        results.errors.push(`Ìñâ ${i + 2}: ÏòÅÎ¨∏Ïù¥Î¶ÑÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.`);
                        continue;
                    }

                    // Ï§ëÎ≥µ ÌôïÏù∏
                    const existingIndex = people.findIndex(p => p.englishName === personData.englishName);
                    
                    if (existingIndex !== -1 && conflictMode === 'skip') {
                        results.skipped++;
                        continue;
                    }

                    // Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨
                    const imageKey = `${personData.englishName}.png`;
                    const imageKeyJpg = `${personData.englishName}.jpg`;
                    const imageKeyJpeg = `${personData.englishName}.jpeg`;
                    
                    let imageBuffer = null;
                    let imageExt = null;
                    
                    if (zipData.images[imageKey]) {
                        imageBuffer = zipData.images[imageKey];
                        imageExt = 'png';
                    } else if (zipData.images[imageKeyJpg]) {
                        imageBuffer = zipData.images[imageKeyJpg];
                        imageExt = 'jpg';
                    } else if (zipData.images[imageKeyJpeg]) {
                        imageBuffer = zipData.images[imageKeyJpeg];
                        imageExt = 'jpeg';
                    }
                    
                    if (imageBuffer && imageExt) {
                        try {
                            // Î°úÏª¨ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû•
                            const imagePath = `./images/${personData.englishName}.${imageExt}`;
                            await fs.writeFile(imagePath, imageBuffer);
                            personData.imageFile = `${personData.englishName}.${imageExt}`;
                            console.log(`Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• ÏÑ±Í≥µ: ${imagePath}`);
                        } catch (imageError) {
                            console.error(`Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• Ïã§Ìå®: ${personData.englishName} -`, imageError.message);
                            results.errors.push(`Ìñâ ${i + 2}: Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• Ïã§Ìå® - ${imageError.message}`);
                        }
                    } else {
                        console.log(`Ïù¥ÎØ∏ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå: ${personData.englishName} (Ï∞æÏùÄ Ïù¥ÎØ∏ÏßÄ: ${Object.keys(zipData.images).join(', ')})`);
                    }

                    if (existingIndex !== -1) {
                        // ÎçÆÏñ¥Ïì∞Í∏∞
                        people[existingIndex] = { ...people[existingIndex], ...personData };
                    } else {
                        // ÏÉàÎ°ú Ï∂îÍ∞Ä
                        people.push(personData);
                    }
                    
                    results.success++;
                } catch (error) {
                    results.failed++;
                    results.errors.push(`Ìñâ ${i + 2}: ${error.message}`);
                }
            }

            // people.json ÌååÏùº Ï†ÄÏû•
            await fs.writeFile('./images/people.json', JSON.stringify(people, null, 2), 'utf8');
        }

        // ÏôÑÎ£å ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        updateProgress('completed', 'ZIP ÌååÏùº ÏóÖÎ°úÎìúÍ∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.', 100, {
            totalEntries: results.total,
            successCount: results.success,
            failedCount: results.failed,
            skippedCount: results.skipped
        });

        res.json({
            success: true,
            message: 'ZIP ÌååÏùº ÏóÖÎ°úÎìúÍ∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.',
            results
        });

    } catch (error) {
        console.error('ZIP ÏóÖÎ°úÎìú ÏóêÎü¨:', error);
        
        // Ïò§Î•ò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        updateProgress('error', 'ZIP ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', 0, {
            errorMessage: error.message
        });
        
        res.status(500).json({ error: 'ZIP ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message });
    }
});

// ZIP ÌååÏùº Ï≤òÎ¶¨ Ìï®Ïàò
async function processZipFile(zipBuffer) {
    return new Promise((resolve, reject) => {
        const zipData = {
            csv: null,
            images: {}
        };

        yauzl.fromBuffer(zipBuffer, { lazyEntries: true }, (err, zipfile) => {
            if (err) {
                reject(new Error('ZIP ÌååÏùºÏùÑ ÏùΩÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ' + err.message));
                return;
            }

            let processedEntries = 0;
            let allEntries = [];

            // Î®ºÏ†Ä Î™®Îì† ÏóîÌä∏Î¶¨Î•º ÏàòÏßë
            zipfile.on('entry', (entry) => {
                console.log(`ZIP ÏóîÌä∏Î¶¨ Î∞úÍ≤¨: ${entry.fileName} (ÎîîÎ†âÌÜ†Î¶¨: ${/\/$/.test(entry.fileName)})`);
                allEntries.push(entry);
                zipfile.readEntry(); // Îã§Ïùå ÏóîÌä∏Î¶¨ ÏùΩÍ∏∞
            });

            zipfile.on('end', () => {
                console.log(`Ï¥ù ${allEntries.length}Í∞úÏùò ÏóîÌä∏Î¶¨ Î∞úÍ≤¨`);
                
                if (allEntries.length === 0) {
                    resolve(zipData);
                    return;
                }

                // Î™®Îì† ÏóîÌä∏Î¶¨Î•º ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
                let currentIndex = 0;
                
                const processNextEntry = () => {
                    if (currentIndex >= allEntries.length) {
                        console.log('Î™®Îì† ZIP ÏóîÌä∏Î¶¨ Ï≤òÎ¶¨ ÏôÑÎ£å');
                        resolve(zipData);
                        return;
                    }

                    const entry = allEntries[currentIndex];
                    currentIndex++;
                    
                    if (/\/$/.test(entry.fileName)) {
                        // ÎîîÎ†âÌÜ†Î¶¨Îäî Í±¥ÎÑàÎõ∞Í∏∞
                        console.log(`ÎîîÎ†âÌÜ†Î¶¨ Í±¥ÎÑàÎúÄ: ${entry.fileName}`);
                        processNextEntry();
                        return;
                    }

                    console.log(`ÌååÏùº Ï≤òÎ¶¨ ÏãúÏûë: ${entry.fileName}`);
                    zipfile.openReadStream(entry, (err, readStream) => {
                        if (err) {
                            reject(new Error(`ÌååÏùºÏùÑ ÏùΩÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${entry.fileName}`));
                            return;
                        }

                        const chunks = [];
                        readStream.on('data', (chunk) => {
                            chunks.push(chunk);
                        });

                        readStream.on('end', () => {
                            const buffer = Buffer.concat(chunks);
                            const fileName = path.basename(entry.fileName);
                            console.log(`ÌååÏùº Ï≤òÎ¶¨ ÏôÑÎ£å: ${fileName} (Ï†ÑÏ≤¥ Í≤ΩÎ°ú: ${entry.fileName}, ÌÅ¨Í∏∞: ${buffer.length})`);

                            // CSV ÌååÏùº Ï≤òÎ¶¨
                            if (fileName.toLowerCase().endsWith('.csv')) {
                                zipData.csv = buffer.toString('utf-8');
                                console.log(`CSV ÌååÏùº Î°úÎìú: ${fileName}`);
                            }
                            // Ïù¥ÎØ∏ÏßÄ ÌååÏùº Ï≤òÎ¶¨ (Í≤ΩÎ°úÏóê Í¥ÄÍ≥ÑÏóÜÏù¥ ÌååÏùºÎ™ÖÎßå ÏÇ¨Ïö©)
                            else if (/\.(png|jpg|jpeg)$/i.test(fileName)) {
                                zipData.images[fileName] = buffer;
                                console.log(`Ïù¥ÎØ∏ÏßÄ ÌååÏùº Î∞úÍ≤¨: ${fileName} (${entry.fileName}) - ${buffer.length} bytes`);
                            } else {
                                console.log(`Ïïå Ïàò ÏóÜÎäî ÌååÏùº ÌòïÏãù: ${fileName}`);
                            }

                            // Îã§Ïùå ÏóîÌä∏Î¶¨ Ï≤òÎ¶¨
                            processNextEntry();
                        });

                        readStream.on('error', (err) => {
                            reject(new Error(`ÌååÏùº ÏùΩÍ∏∞ Ïò§Î•ò: ${entry.fileName} - ${err.message}`));
                        });
                    });
                };

                // Ï≤´ Î≤àÏß∏ ÏóîÌä∏Î¶¨Î∂ÄÌÑ∞ Ï≤òÎ¶¨ ÏãúÏûë
                processNextEntry();
            });

            zipfile.on('error', (err) => {
                reject(new Error('ZIP ÌååÏùº Ï≤òÎ¶¨ Ïò§Î•ò: ' + err.message));
            });

            // Ï≤´ Î≤àÏß∏ ÏóîÌä∏Î¶¨ ÏùΩÍ∏∞ ÏãúÏûë
            zipfile.readEntry();
        });
    });
}

// Firebase StorageÏóê Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ìï®Ïàò
async function uploadImageToFirebase(imageBuffer, fileName) {
    if (!firebase || !firebase.bucket) {
        throw new Error('Firebase StorageÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
    }

    try {
        const bucket = firebase.bucket;
        const file = bucket.file(`images/${fileName}`);
        
        await file.save(imageBuffer, {
            metadata: {
                contentType: fileName.endsWith('.png') ? 'image/png' : 'image/jpeg'
            }
        });

        // ÏÑúÎ™ÖÎêú URL ÏÉùÏÑ± (1ÎÖÑ Ïú†Ìö®)
        const [url] = await file.getSignedUrl({
            action: 'read',
            expires: '12-31-2030'
        });

        return url;
    } catch (error) {
        throw new Error(`Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå®: ${fileName} - ${error.message}`);
    }
}

// ÏóêÎü¨ Ìï∏Îì§ÎßÅ ÎØ∏Îì§Ïõ®Ïñ¥
app.use((error, req, res, next) => {
  console.error('ÏÑúÎ≤Ñ ÏóêÎü¨:', error);
  
  if (error.code === 'LIMIT_FILE_SIZE') {
    return res.status(400).json({ 
      error: `ÌååÏùº ÌÅ¨Í∏∞Í∞Ä ÎÑàÎ¨¥ ÌÅΩÎãàÎã§. ÏµúÎåÄ ${maxFileSize / (1024 * 1024)}MBÍπåÏßÄ ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§.` 
    });
  }
  
  if (error.message.includes('ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌååÏùº ÌÉÄÏûÖ')) {
    return res.status(400).json({ 
      error: error.message 
    });
  }
  
  res.status(500).json({ 
    error: process.env.NODE_ENV === 'production' ? 'ÏÑúÎ≤Ñ ÎÇ¥Î∂Ä Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' : error.message 
  });
});

// ÎèôÏ†Å Î≤ÑÏ†Ñ Í¥ÄÎ¶¨Î•º ÏúÑÌïú ÎùºÏö∞Ìä∏
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.get('/index.html', (req, res) => {
    fs.readFile(path.join(__dirname, 'index.html'), 'utf8')
        .then(html => {
            // Î≤ÑÏ†Ñ Î¨∏ÏûêÏó¥ ÏûêÎèô ÍµêÏ≤¥
            const versionedHtml = html.replace(
                /main\.js\?v=[\d.]+/g, 
                `main.js?v=${appVersion}`
            );
            res.send(versionedHtml);
        })
        .catch(err => {
            console.error('index.html ÏùΩÍ∏∞ Ïò§Î•ò:', err);
            res.status(500).send('ÏÑúÎ≤Ñ Ïò§Î•ò');
        });
});

// 404 Ìï∏Îì§Îü¨
app.use((req, res) => {
  res.status(404).json({ error: 'ÏöîÏ≤≠Ìïú Î¶¨ÏÜåÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' });
});

// ÏÑúÎ≤Ñ Ïã§Ìñâ (ÏßÅÏ†ë Ïã§ÌñâÌï† ÎïåÎßå listen)
if (require.main === module) {
    app.listen(PORT, () => {
        console.log(`üöÄ ÏÑúÎ≤ÑÍ∞Ä http://localhost:${PORT} ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.`);
        console.log(`üìä Í¥ÄÎ¶¨Ïûê ÌéòÏù¥ÏßÄ: http://localhost:${PORT}/admin.html`);
        console.log(`üè† Î©îÏù∏ ÌéòÏù¥ÏßÄ: http://localhost:${PORT}/index.html`);
        console.log(`üîí ÌôòÍ≤Ω: ${process.env.NODE_ENV || 'development'}`);
        console.log(`üåê CORS ÌóàÏö© ÎèÑÎ©îÏù∏: ${process.env.ALLOWED_ORIGINS || 'http://localhost:3000'}`);
        console.log(`üìÅ ÌååÏùº ÏóÖÎ°úÎìú Ï†úÌïú: ${maxFileSize / (1024 * 1024)}MB, ÌÉÄÏûÖ: ${allowedFileTypes.join(', ')}`);
    });
}

// ÌÖåÏä§Ìä∏Ïö© app Í∞ùÏ≤¥ export
module.exports = app;

